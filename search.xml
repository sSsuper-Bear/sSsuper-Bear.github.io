<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bootdo项目通过jar包启动</title>
    <url>/2021/05/24/bootdo%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87jar%E5%8C%85%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="bootdo项目通过jar包启动"><a href="#bootdo项目通过jar包启动" class="headerlink" title="bootdo项目通过jar包启动"></a>bootdo项目通过jar包启动</h3><ul>
<li><p>本项目来自<a href="https://gitee.com/lcg0124/bootdo">gitee李春光</a>，具体<a href="https://gitee.com/lcg0124/bootdo/wikis/%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE?sort_id=64319">参考文档</a></p>
<p><img src="https://img.imgdb.cn/item/608b57c6d1a9ae528fa2373d.png" alt="image-20210304220122324"></p>
</li>
<li><p>首先在本地IDEA启动成功</p>
</li>
</ul>
<p><img src="https://img.imgdb.cn/item/608b57dbd1a9ae528fa2e9f5.png" alt="image-20210304215220295"></p>
<ul>
<li>进入网址</li>
</ul>
<p><img src="https://img.imgdb.cn/item/608b57ebd1a9ae528fa36741.png" alt="image-20210304215801788"></p>
<ul>
<li><p>使用maven打包bootdo并运行，bootdo项目生成jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven clean</span><br><span class="line">maven package</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/608b57fcd1a9ae528fa3f3c0.png" alt="image-20210408152239126"></p>
<ul>
<li>把test文件都给注释掉</li>
</ul>
</li>
<li><p>把jar包和Dockerfile文件放到同一目录下</p>
<p><img src="https://img.imgdb.cn/item/608b5812d1a9ae528fa4a47c.png" alt="image-20210408160354212"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dockerfile</span><br><span class="line">  1 FROM java:8</span><br><span class="line">  2 </span><br><span class="line">  3 VOLUME /tmp</span><br><span class="line">  4 </span><br><span class="line">  5 COPY bootdo-2.0.0.jar app.jar</span><br><span class="line">  6 </span><br><span class="line">  7 RUN bash -c &quot;touch /app.jar&quot;</span><br><span class="line">  8 </span><br><span class="line">  9 EXPOSE 8088</span><br><span class="line"> 10 </span><br><span class="line"> 11 ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;, &quot;--spring.profiles.active=test&quot;, &quot;--server.port=8088&quot;, &quot;&gt; /log/app.log&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p>运行指令将jar包打包成镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image build -t bootdo-2.0.0 .</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/608b582ad1a9ae528fa55ad7.png" alt="image-20210408160443433"></p>
</li>
<li><p>查看镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/608b5839d1a9ae528fa5d370.png" alt="image-20210408160750151"></p>
</li>
<li><p>通过jar包运行项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar study-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/608b584bd1a9ae528fa6621d.png" alt="image-20210422091705400"></p>
<p><img src="https://img.imgdb.cn/item/608b5859d1a9ae528fa6d3c6.png" alt="image-20210422091719557"></p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/qq_37525899/article/details/86736835">使用maven打包bootdo并运行</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2021/12/26/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Git三种工程区域-amp-文件状态"><a href="#Git三种工程区域-amp-文件状态" class="headerlink" title="Git三种工程区域 &amp; 文件状态"></a>Git三种工程区域 &amp; 文件状态</h3><h4 id="三种工程区域"><a href="#三种工程区域" class="headerlink" title="三种工程区域"></a>三种工程区域</h4><ol>
<li><p><strong>版本库（Repository）</strong></p>
<p>在工作区中有一个隐藏目录.git，这个文件夹就是Git的版本库，里面存放了Git用了管理该工程的所有版本数据，里面存放了Git用来管理该工程的所有版本数据，也叫<strong>本地仓库</strong>。</p>
</li>
<li><p><strong>工作区（Working Directory）</strong></p>
<p>日常工作的代码文件或者文档所在的文件夹。</p>
</li>
<li><p><strong>暂存区（stage）</strong></p>
<p>一般存放在工程根目录.git/index文件中。</p>
</li>
</ol>
<h4 id="三种文件状态"><a href="#三种文件状态" class="headerlink" title="三种文件状态"></a>三种文件状态</h4><ol>
<li><p>已提交（committed）</p>
<p>该文件已经被安全的保存在了本地数据库中了；</p>
</li>
<li><p>已修改（modified）</p>
<p>修改了某个文件，但还没有提交保存；</p>
</li>
<li><p>已暂存（staged）</p>
<p>把已修改的文件放在下次提交时要保存的清单中。</p>
</li>
</ol>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><p><strong>工程准备</strong></p>
<p>工程克隆——git clone</p>
<p><strong>查看工作区</strong></p>
<p>查看工作区的修改内容——git diff</p>
<p>查看工作区的文件状态——git status</p>
<p><strong>文件修改后提交推送</strong></p>
<p>新增/删除/移动文件到暂存区——git add/ git rm/ git mv</p>
<p>提交更改的文件——git commit</p>
<p>推送远端仓库——git push</p>
<p><strong>查看日志</strong></p>
<p>查看当前分支上的提交日志——git log</p>
<p><strong>分支管理</strong></p>
<p>列出本地分支——git branch</p>
<p>新建分支——git branch/ git checkout -b</p>
<p>删除分支——git branch -d</p>
<p>切换分支——git checkout</p>
<p>更新分支——git pull</p>
<p>合并分支——git merge</p>
<p><strong>撤销操作</strong></p>
<p>强制回退到历史节点——git reset</p>
<p>回退本地所有修改而未提交的——git checkout</p>
<p><strong>分支合并</strong></p>
<p>合并目标分支内容到当前分支——git merge/git rebase</p>
<h3 id="Git常用命令详解"><a href="#Git常用命令详解" class="headerlink" title="Git常用命令详解"></a>Git常用命令详解</h3><h4 id="工程准备"><a href="#工程准备" class="headerlink" title="工程准备"></a>工程准备</h4><p><strong><strong style="color:#00b0f0;">git clone </strong>用于克隆远端工程到本地磁盘</strong></p>
<p>执行命令<strong style="color:#00b0f0;">git clone [URL]</strong>或<strong style="color:#00b0f0;">git lfs clone [URL]</strong></p>
<p><strong style="color:#ff0000;">注：</strong>如果所在项目git服务器已支持git-lfs，对二进制文件进行了区别管理，那么克隆工程的时候务必使用git lfs clone，否则克隆操作无法下载到工程中的二进制文件，工程内容不完整。</p>
<h4 id="新增-删除-移动文件到暂存区"><a href="#新增-删除-移动文件到暂存区" class="headerlink" title="新增/删除/移动文件到暂存区"></a>新增/删除/移动文件到暂存区</h4><p><strong>在提交你修改的文件之前，需要<strong style="color:#00b0f0;">git add</strong>把文件添加到暂存区。</strong></p>
<p><strong style="color:#ff0000;">注：</strong>早期需要<strong style="color:#00b0f0;">git add</strong>再提交，较新版本的git中不需要。</p>
<p><strong><strong style="color:#00b0f0;">git rm</strong> 将指定文件彻底从当前分支的缓存区删除，因此它从当前分支的下一个提交快照中被删除。</strong></p>
<p>也可以直接硬盘上删除文件，然后对该文件执行<strong style="color:#00b0f0;">git commit</strong>，git会自动将删除的文件从索引中移除，效果一样。</p>
<p><strong><strong style="color:#00b0f0;">git mv</strong>命令用于移动文件，也可以用于重命名文件。</strong></p>
<p>例1：移动test.conf到config目录下：<strong style="color:#00b0f0;">git mv test.conf config</strong></p>
<p>例2: 将文件test.conf重命名为test1.conf：<strong style="color:#00b0f0;">git mv test.conf test1.conf</strong></p>
<h4 id="查看工作区"><a href="#查看工作区" class="headerlink" title="查看工作区"></a>查看工作区</h4><p><strong><strong style="color:#00b0f0;">git diff</strong>用于比较项目中任意两个版本（分支）的差异，也可以用来比较当前的索引和上次提交间的差异。</strong></p>
<p><strong><strong style="color:#00b0f0;">git status</strong>命令用于显示工作目录和暂存区的状态。</strong></p>
<p>使用此命令能看到修改的git文件是否被暂存，新增的文件是否纳入了git版本库的管理。</p>
<h4 id="提交更改的文件"><a href="#提交更改的文件" class="headerlink" title="提交更改的文件"></a>提交更改的文件</h4><p><strong style="color:#00b0f0;">git commit</strong><strong>主要是将暂存区里的文件改动提交到本地的版本库</strong></p>
<p><strong style="color:#ff0000;">注</strong>：提交这个动作是本地动作，是往本地的版本库中记录改动，不影响远端服务器。</p>
<p><strong style="color:#00b0f0;">git commit</strong>一般需要带描述信息，常见用法：<strong style="color:#00b0f0;">git commit file_name -m “commit message”</strong></p>
<p>如果要一次性提交所有在暂存区改动的文件到版本库，可以执行：<strong style="color:#00b0f0;">git commit -am “commit message”</strong></p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p><strong style="color:#00b0f0;">git log</strong><strong>用于查看提交历史</strong>。</p>
<h4 id="推送至远端仓库"><a href="#推送至远端仓库" class="headerlink" title="推送至远端仓库"></a>推送至远端仓库</h4><p><strong>在使用<strong style="color:#00b0f0;">git commit</strong>命令将自己的修改从暂存区提交到本地版本库之后，可以使用<strong style="color:#00b0f0;">git push</strong>将本地版本库的分支推送到远程服务器对应的分支。</strong></p>
<p>常用推送命令格式：<strong style="color:#00b0f0;">git push origin branch_name</strong></p>
<p><strong>本地分支名可以与推送到远端的分支名不同</strong>：<strong style="color:#00b0f0;">git push origin branch_name:new_branch_name</strong></p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p><strong><strong style="color:#00b0f0;">git branch</strong>命令即可查看本地工程的所有git分支名称</strong></p>
<p><strong style="color:#00b0f0;">git branch </strong>和<strong style="color:#00b0f0;">git checkout -b</strong>的异同：</p>
<p>相同点：</p>
<p>都可用于新建分支（默认基于当前分支节点创建）</p>
<p>不同点：</p>
<p><strong style="color:#00b0f0;">git branch</strong>新建分支后并不会切换到新分支；</p>
<p><strong style="color:#00b0f0;">git checkout -b</strong>新建分支后会自动切换到新分支。</p>
<p><strong>常用的新建分支命令格式</strong>：<strong style="color:#00b0f0;">git brack new_branch_name / git checkout -b branch_name</strong></p>
<p><strong style="color:#00b0f0;">git branch -d</strong>和<strong style="color:#00b0f0;">git branch -D</strong><strong>都可以用来删除本地分支</strong>，<strong>后者大写表示强制删除</strong>。</p>
<p><strong>常用的删除分支命令格式</strong>：<strong style="color:#00b0f0;">git branch -d branch_name/git branch -D branck_name</strong></p>
<p>删除服务器上的远程分支可以使用 <strong style="color:#00b0f0;">git branch -d -r branck_name</strong>，其中branch_name为本地分支名。</p>
<p>删除后，还要推送到服务器上才行，即<strong style="color:#00b0f0;">git push origin : branch_name</strong></p>
<p><strong style="color:#00b0f0;">git checkout</strong>命令除了创建分支，还用来切换分支。</p>
<p>有时候，当前分支工作区存在修改而未提交的文件，与目的分支上的内容冲突，会导致checkout切换失败，这时候，可以使用<strong style="color:#00b0f0;">git checkout -f</strong>进行强制切换。</p>
<p><strong>常用切换分支命令格式</strong>：<strong style="color:#00b0f0;">git checkout branch_name</strong></p>
<p><strong style="color:#00b0f0;">git pull</strong><strong>的作用是从远端服务器中获取某个分支的更新</strong>，<strong>在于本地指定的分支进行自动合并</strong>。</p>
<p><strong>常用的更新分支的命令格式</strong>：<strong style="color:#00b0f0;">git pull origin remote_branch:local_branch</strong></p>
<p>如果远程指定的分支与本地指定的分支相同，则可直接指向<strong style="color:#00b0f0;">git pull origin remote_branch</strong></p>
<p><strong style="color:#00b0f0;">git fetch</strong><strong>的作用是从远端服务器中获取某个分支的更新到本地仓库</strong>。</p>
<p><strong style="color:#ff0000;">注：</strong>与git pull不同，git fetch在获取到更新后，并不会进行合并操作，确认内容符合预期后，再决定是否手动合并节点。</p>
<p><strong>常用的获取远端分支更新命令格式</strong>：<strong style="color:#00b0f0;">git fetch origin remote_branch:local_branch</strong></p>
<p>如果远程指定的分支与本地指定的分支相同，则可直接执行<strong style="color:#00b0f0;">git fetch origin remote_branch</strong></p>
<h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p><strong style="color:#00b0f0;">git merge</strong><strong>命令是用于从指定的分支</strong>（<strong>节点</strong>）<strong>合并到当前分支的操作</strong></p>
<p>git会将指定的分支与当前分支进行比较，找出两者最近的一个共同节点base，之后将指定分支在base之后的分离节点合并到当前分支上。分支合并，实际上市分支间差异提交节点的合并。</p>
<p><strong>常用的切换分支命令格式</strong>：<strong style="color:#00b0f0;">git merge branch_name</strong></p>
<p><strong style="color:#00b0f0;">git rebase</strong><strong>用于合并目标分支内容到当前分支</strong>。</p>
<p>常用合并命令格式：<strong style="color:#00b0f0;">git rebase branch_name</strong></p>
<p><strong style="color:#ff0000;">注：</strong>git rebase、git merge背后的实现机制对合并后节点造成的影响有很大差异，各有风险存在。</p>
<h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p><strong><strong style="color:#00b0f0;">git reset</strong>通常用于撤销当前工作区中的某些<strong style="color:#00b0f0;">git add/commit</strong>操作，可将工作区内容回退到历史提交节点。</strong></p>
<p><strong style="color:#00b0f0;">git checkout . </strong>用于回退本地所有修改而未提交的文件内容。</p>
<p><strong style="color:#ff0000;">注：</strong>它会用暂存区的所有文件直接覆盖本地文件，不给用户确认机会，谨慎使用。</p>
<p>如果仅仅只想退回某个文件的未提交改动，可以使用<strong style="color:#00b0f0;">git checkout -filename</strong>来达到目的；如果想将工具区回退到某个提交版本，可以使用<strong style="color:#00b0f0;">git checkout commit_id</strong></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>数据库常用指令</title>
    <url>/2021/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="mysql-sql常用语句大全"><a href="#mysql-sql常用语句大全" class="headerlink" title="mysql sql常用语句大全"></a><a href="https://blog.csdn.net/hzw6991/article/details/87757426?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162514485316780264064821%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162514485316780264064821&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-87757426.pc_v2_rank_blog_default&utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1018.2226.3001.4450">mysql sql常用语句大全</a></h1><h3 id="一-、常用操作数据库的命令"><a href="#一-、常用操作数据库的命令" class="headerlink" title="一 、常用操作数据库的命令"></a>一 、常用操作数据库的命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.show databases; 查看所有的数据库</span><br><span class="line">2.create database test; 创建一个叫test的数据库</span><br><span class="line">3.drop database test;删除一个叫test的数据库</span><br><span class="line">4.use test;选中库 ,在建表之前必须要选择数据库</span><br><span class="line">5.show tables; 在选中的数据库之中查看所有的表</span><br><span class="line">6.create table 表名 (字段1 类型, 字段2 类型);</span><br><span class="line">7.desc 表名;查看所在的表的字段</span><br><span class="line">8.drop table 表名; 删除表</span><br><span class="line">9.show create database 库名;查看创建库的详细信息</span><br><span class="line">10.show create table 表名; 查看创建表的详细信息</span><br></pre></td></tr></table></figure>

<h3 id="二、修改表的命令"><a href="#二、修改表的命令" class="headerlink" title="二、修改表的命令"></a>二、修改表的命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.修改字段类型 alter table 表名 modify 字段 字段类型;</span><br><span class="line">2.添加新的字段 alter table 表名 add 字段 字段类型</span><br><span class="line">3.添加字段并指定位置  alter table 表名 add 字段 字段类型   after 字段;</span><br><span class="line">4.删除表字段  alter table 表名 drop 字段名;</span><br><span class="line">5.修改指定的字段  alter table 表名 change 原字段名字  新的字段名字 字段类型</span><br></pre></td></tr></table></figure>

<h3 id="三、对数据的操作"><a href="#三、对数据的操作" class="headerlink" title="三、对数据的操作"></a>三、对数据的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.增加数据(insert)3种方式</span><br><span class="line">    1.1 insert into 表名 values(值1，值2，...)(很少用)</span><br><span class="line">    1.2 insert into 表名(字段1，字段2...) values(值1，值2，....);（较常用）</span><br><span class="line">    1.3 insert into 表名(字段1，字段2...) values(值1，值2，....)，(值1，值2，....)，(值1，值2，....);</span><br><span class="line">2.删除数据(delete) delete from 表名 where 条件 注意：where 条件必须加，否则数据会被全部删除</span><br><span class="line">3.更新数据(update)  update 表名 set字段1 = 值1, 字段2 = 值2 where 条件</span><br><span class="line">4.查询数据(select)</span><br><span class="line">    4.1 查询表中的所有数据   select * from 表名</span><br><span class="line">    4.2 指定数据查询    select 字段 from 表名 </span><br><span class="line">    根据条件查询出来的数据  select 字段 from 表名 where 条件 (最常用的)</span><br><span class="line">    where 条件后面跟的条件</span><br><span class="line">     关系：&gt;,&lt;,&gt;=,&lt;=,!=  </span><br><span class="line">     逻辑：or, and </span><br><span class="line">     区间：id between 4 and 6 ;闭区间，包含边界</span><br><span class="line">5.排序</span><br><span class="line">select 字段 from 表 order by 字段  排序关键词(desc | asc)</span><br><span class="line">排序关键词 desc 降序 asc 升序(默认)</span><br><span class="line">    5.1 通过字段来排序</span><br><span class="line">    例如 ：select * from star orser by money desc, age asc;   </span><br><span class="line">    5.2 多字段排序</span><br><span class="line">    select 字段 from 表 order by 字段1  desc |asc,...字段n desc| asc;</span><br><span class="line">6.常用的统计函数 sum，avg，count，max,min</span><br><span class="line">    只分组:select * from 表 group by 字段</span><br><span class="line">    例子: select count(sex) as re,sex from star group by sex having re &gt; 3;</span><br><span class="line">    分组统计: select count(sex) from star group by sex;</span><br><span class="line">7.分组 select * from 表名  limit 偏移量,数量</span><br><span class="line">    说明:</span><br><span class="line">        8.1.不写偏移量的话就是默认的为0</span><br><span class="line">        8.2.实现分页的时候必须写偏移量</span><br><span class="line">        偏移量怎么计算？:</span><br><span class="line">        limit (n-1)*数量 ,数量 </span><br></pre></td></tr></table></figure>

<h3 id="四、多表联合查询"><a href="#四、多表联合查询" class="headerlink" title="四、多表联合查询"></a>四、多表联合查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.内连接</span><br><span class="line">隐式内连接 select username,name from user,goods where user,gid=gods,gid;</span><br><span class="line">显示内连接</span><br><span class="line">select username,from user inner join goods on user.gid=goods.gid;</span><br><span class="line">select * from user left join goods on user.gid=goods.gid;</span><br><span class="line">2.外链接</span><br><span class="line">左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录</span><br><span class="line">右连接 </span><br><span class="line">select * from user where gid in(select gid from goods);</span><br><span class="line">select * from user right jOin goods on user.gid=goods.gid;</span><br><span class="line">子嵌套查询</span><br><span class="line">数据联合查询</span><br><span class="line">select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid;</span><br><span class="line">两个表同时更新</span><br><span class="line">update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid;</span><br></pre></td></tr></table></figure>

<h3 id="五、DCL-数据控制语言"><a href="#五、DCL-数据控制语言" class="headerlink" title="五、DCL 数据控制语言"></a>五、DCL 数据控制语言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建用户:create user&#x27;xiaoming&#x27;@&#x27;localhost&#x27; identified by &#x27;666666&#x27;;</span><br><span class="line">2.授权用户:grant all on test.*to&#x27;xiaoming&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">3.刷新权限:flush privileges;</span><br><span class="line">4.取消授权:revoke all on test.* from &#x27;xiaoming&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">5.删除用户: drop user&#x27;xiaoming&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="六、DTL-数据事务语言"><a href="#六、DTL-数据事务语言" class="headerlink" title="六、DTL 数据事务语言"></a>六、DTL 数据事务语言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启事务：set autocommit=0;</span><br><span class="line">操作回滚：rollback;</span><br><span class="line">提交事务：commit;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一些简单题</title>
    <url>/2022/01/23/%E5%88%B7%E9%A2%98/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="NC120-二进制中1的个数"><a href="#NC120-二进制中1的个数" class="headerlink" title="NC120 二进制中1的个数"></a>NC120 二进制中1的个数</h3><p><strong>描述</strong></p>
<p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制中10的32位二进制表示为0000 0000 0000 0000 0000 0000 0000 1010，其中有两个1。       </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负数使用补码表示 ，-1的32位二进制表示为1111 1111 1111 1111 1111 1111 1111 1111，其中32个1    </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>计算机中存储数据都是补码的形式</li>
<li>正数的反码和补码是它本身</li>
<li>负数的反码是除符号位外的相反数，补码是反码加一</li>
<li>补码为反码+1</li>
<li>负数在计算机中存储形式为补码</li>
<li>负数右移符号位补1</li>
<li>采用与位左移代替数字右移</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) ans++;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC107-寻找峰值"><a href="#NC107-寻找峰值" class="headerlink" title="NC107 寻找峰值"></a>NC107 寻找峰值</h3><p><strong>描述</strong></p>
<p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] = nums[n] = -\infty−∞</p>
<p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1]</p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p>
<p>数据范围：</p>
<p>1 \le nums.length \le 2\times 10^5 \1≤<em>n<strong>u</strong>m**s</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>≤2×105 </p>
<p>-2^{31}&lt;= nums[i] &lt;= 2^{31} - 1−231&lt;=<em>n<strong>u</strong>m**s</em>[<em>i</em>]&lt;=231−1</p>
<p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,4,1,2,7,8,4]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4和8都是峰值元素，返回4的索引1或者8的索引5都可以     </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,1]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 是峰值元素，返回其索引 2    </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>注意第一位和最后一位</li>
<li>当前位比前一位小就说明前一位为峰值</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; tmp) <span class="keyword">return</span> (i-<span class="number">1</span>);</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="600-不含连续1的非负整数"><a href="#600-不含连续1的非负整数" class="headerlink" title="600. 不含连续1的非负整数"></a><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h4><p>难度困难138</p>
<p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 <strong>连续的1</strong> 的个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">下面是带有相应二进制表示的非负整数&lt;= 5：</span><br><span class="line">0 : 0</span><br><span class="line">1 : 1</span><br><span class="line">2 : 10</span><br><span class="line">3 : 11</span><br><span class="line">4 : 100</span><br><span class="line">5 : 101</span><br><span class="line">其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 1 &lt;= n &lt;= 109</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据构建斐波那也数列</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = getBinary(num);</span><br><span class="line">        <span class="comment">//一位位移动，不连续遇到1加上它</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res  += dp[numStr.length() - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numStr.charAt(i - <span class="number">1</span> ) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//整数 转 二进制数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBinary</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>,num &amp; <span class="number">1</span>);</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li>
<li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li>
<li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li>
<li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l: 左括号最少可能有多少个</span></span><br><span class="line">        <span class="comment">// r: 左括号最多可能有多少个</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 遇到&#x27;(&#x27;所有可能性加一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;)&#x27;所有可能性减一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;*&#x27;，最少的可能性可以变少，最多的可能性也同样可以变多，这取决于这个星号最终我们看成什么，但是可能性都在</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                l++; r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                l--; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l--; r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前左括号最少个数不能为负</span></span><br><span class="line">            l = Math.max(l, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这种情况其实发生在r本身是负数的时候，也就是我们常见的右括号太多了</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能取到0个左括号才是满足平衡的</span></span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC45-实现二叉树先序，中序和后序遍历"><a href="#NC45-实现二叉树先序，中序和后序遍历" class="headerlink" title="NC45 实现二叉树先序，中序和后序遍历"></a>NC45 实现二叉树先序，中序和后序遍历</h4><p><strong>描述</strong></p>
<p>给定一棵二叉树，分别按照二叉树先序，中序和后序打印所有的节点。</p>
<p>数据范围：0 \le n \le 10000≤<em>n</em>≤1000，树上每个节点的val值满足 0 \le val \le 1000≤<em>v<strong>a</strong>l</em>≤100</p>
<p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>样例解释：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/E61DCE88EB71683589EA3480498477F1" alt="img">如图二叉树结构</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1,2,3],[2,1,3],[2,3,1]]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如题面图  </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[],[],[]]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>先，中，后序遍历是根节点在先，中，后</li>
<li>定义全局变量存储先，中，后序遍历结果</li>
<li>递归实现先，中，后序，每次存储根节点</li>
<li>ArrayList&lt;&gt;存先，中，后序遍历结果</li>
<li>ArrayList&lt;ArrayList&lt;&gt;&gt;转list[][]</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; in = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; post = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] threeOrders (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line"><span class="comment">//         if (root == null) return new int[][] &#123;&#123;&#125;&#125;;</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preOrder(root);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        postOrder(root);</span><br><span class="line">        ans.add(pre);</span><br><span class="line">        ans.add(in);</span><br><span class="line">        ans.add(post);</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][ans.get(<span class="number">0</span>).size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.get(<span class="number">0</span>).size(); j++) &#123;</span><br><span class="line">                res[i][j] = ans.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        pre.add(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        in.add(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        post.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC15-求二叉树的层序遍历"><a href="#NC15-求二叉树的层序遍历" class="headerlink" title="NC15 求二叉树的层序遍历"></a><a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=117&&tqId=37723&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=117&page=1">NC15 求二叉树的层序遍历</a></h4><p><strong>描述</strong></p>
<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://gitee.com/sssuperbear/typora/raw/master/img/036DC34FF19FB24652AFFEB00A119A76" alt="img"><br>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7]</p>
<p>]</p>
<p>提示:</p>
<p>0 &lt;= 二叉树的结点数 &lt;= 1500</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1],[2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,#,#,5&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1],[2,3],[4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><p>声明一个成员变量供全局使用；</p>
</li>
<li><p>向下探索的递归方法，注意先从左边再从右边；每向下一层level+1</p>
</li>
<li><p>二维List来说，将根视为第0层，树的深度正好等于一维List的个数。</p>
</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        count(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level == res.size()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res.get(level).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count(node.left, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count(node.right, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h4 id="600-不含连续1的非负整数"><a href="#600-不含连续1的非负整数" class="headerlink" title="600. 不含连续1的非负整数"></a><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h4><p>难度困难138</p>
<p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 <strong>连续的1</strong> 的个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">下面是带有相应二进制表示的非负整数&lt;= 5：</span><br><span class="line">0 : 0</span><br><span class="line">1 : 1</span><br><span class="line">2 : 10</span><br><span class="line">3 : 11</span><br><span class="line">4 : 100</span><br><span class="line">5 : 101</span><br><span class="line">其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 1 &lt;= n &lt;= 109</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据构建斐波那也数列</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = getBinary(num);</span><br><span class="line">        <span class="comment">//一位位移动，不连续遇到1加上它</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res  += dp[numStr.length() - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numStr.charAt(i - <span class="number">1</span> ) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//整数 转 二进制数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBinary</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>,num &amp; <span class="number">1</span>);</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li>
<li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li>
<li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li>
<li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l: 左括号最少可能有多少个</span></span><br><span class="line">        <span class="comment">// r: 左括号最多可能有多少个</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 遇到&#x27;(&#x27;所有可能性加一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;)&#x27;所有可能性减一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;*&#x27;，最少的可能性可以变少，最多的可能性也同样可以变多，这取决于这个星号最终我们看成什么，但是可能性都在</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                l++; r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                l--; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l--; r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前左括号最少个数不能为负</span></span><br><span class="line">            l = Math.max(l, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这种情况其实发生在r本身是负数的时候，也就是我们常见的右括号太多了</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能取到0个左括号才是满足平衡的</span></span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC19-连续子数组的最大和"><a href="#NC19-连续子数组的最大和" class="headerlink" title="NC19 连续子数组的最大和"></a>NC19 连续子数组的最大和</h4><ul>
<li><strong>描述</strong></li>
</ul>
<p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求:时间复杂度为 O(n)<em>O</em>(<em>n</em>)，空间复杂度为 O(n)<em>O</em>(<em>n</em>)</p>
<p>进阶:时间复杂度为 O(n)<em>O</em>(<em>n</em>)，空间复杂度为 O(1)<em>O</em>(1)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18       </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[-10]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>array[i] 存当前的值+之前的值</li>
<li>array[i-1]为负数时舍去这个，重新从array[i]开始算和</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> max = array[<span class="number">0</span>];	</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                array[i] += array[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? array[i-<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">                max = Math.max(max, array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a></h4><p>给定平面上 <code>n</code> 对 <strong>互不相同</strong> 的点 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 。<strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p>
<p>返回平面上所有回旋镖的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[0,0],[1,0],[2,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑数组顺序，可以用排列组合的方式,枚举一个个算距离，存储距离相同的点的个数放入哈希表中，最后取出哈希表中的数据，一个个排列组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] p:points) &#123;</span><br><span class="line">            Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] q : points) &#123;</span><br><span class="line">                <span class="keyword">int</span> dis = ((p[<span class="number">0</span>] - q[<span class="number">0</span>])) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]) + (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] -  q[<span class="number">1</span>]);</span><br><span class="line">                cnt.put(dis, cnt.getOrDefault(dis, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = entry.getValue();</span><br><span class="line">                ans += m * (m-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>难度中等490收藏分享切换为英文接收动态反馈</p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0]</span><br><span class="line">输出：[-1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>
</ul>
<p><strong>思路：</strong>建一个hashmap 把它每个算出来是多少然后遍历出来。</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;nums.length; i++ ) &#123;</span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;nums.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) == <span class="number">1</span>) ans[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></h4><p>难度中等164</p>
<p>你在和朋友一起玩 <a href="https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>
<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>
<ul>
<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），</li>
<li>有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>
</ul>
<p>给你一个秘密数字 <code>secret</code> 和朋友猜测的数字 <code>guess</code> ，请你返回对朋友这次猜测的提示。</p>
<p>提示的格式为 <code>&quot;xAyB&quot;</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code> 表示奶牛。</p>
<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line">输出: &quot;1A3B&quot;</span><br><span class="line">解释: 数字和位置都对（公牛）用 &#x27;|&#x27; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line">&quot;1807&quot;</span><br><span class="line">  |</span><br><span class="line">&quot;7810&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line">输出: &quot;1A1B&quot;</span><br><span class="line">解释: 数字和位置都对（公牛）用 &#x27;|&#x27; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line">&quot;1123&quot;        &quot;1123&quot;</span><br><span class="line">  |      or     |</span><br><span class="line">&quot;0111&quot;        &quot;0111&quot;</span><br><span class="line">注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：secret = &quot;1&quot;, guess = &quot;0&quot;</span><br><span class="line">输出：&quot;0A0B&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：secret = &quot;1&quot;, guess = &quot;1&quot;</span><br><span class="line">输出：&quot;1A0B&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>
<li><code>secret.length == guess.length</code></li>
<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>数字位置都对的  +1</li>
<li>数字对位置不对的 哈希表存起来 +1</li>
<li>对比 哈希表中的数字，取小的</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        Map &lt;Character, Integer&gt; secret_map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map &lt;Character, Integer&gt; guess_map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> bull=<span class="number">0</span>, cow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;secret.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(secret.charAt(i) == guess.charAt(i)) &#123;</span><br><span class="line">                bull++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                secret_map.put(secret.charAt(i), secret_map.getOrDefault(secret.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                guess_map.put(guess.charAt(i), guess_map.getOrDefault(guess.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> k : secret_map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess_map.containsKey(k)) cow = cow + Math.min(secret_map.get(k), guess_map.get(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bull+<span class="string">&quot;A&quot;</span>+cow+<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="NC61-两数之和"><a href="#NC61-两数之和" class="headerlink" title="NC61 两数之和"></a><a href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&&tqId=37756&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=117&page=1">NC61 两数之和</a></h4><p><strong>描述</strong></p>
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。</p>
<p>（注：<strong>返回</strong>的数组下标从1开始算起）</p>
<p>数据范围：2≤<em>l<strong>e</strong>n</em>(<em>n<strong>u</strong>m<strong>b</strong>e<strong>r</strong>s</em>)≤1500，−10≤<em>n<strong>u</strong>m<strong>b</strong>e<strong>r</strong>s**i</em>≤109，0≤<em>t<strong>a</strong>r<strong>g</strong>e**t</em>≤109</p>
<p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)</p>
<p>例如：</p>
<p>给出的数组为 [20, 70, 110, 150] , 目标值为90</p>
<p>返回一个数组 [1,2] ，因为 numbers _1+numbers _2=20+70=90<em>n<strong>u</strong>m<strong>b</strong>e<strong>r</strong>s</em>1+<em>n<strong>u</strong>m<strong>b</strong>e<strong>r</strong>s</em>2=20+70=90</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,2,4],6</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 &lt; 下标3 ，所以返回[2,3]         </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[20,70,110,150],90</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>定义哈希表hashmap，其存放的键值对为&lt;取值，下标&gt;。</li>
<li>从开始处遍历数组，对于第i个位置，在哈希表中寻找target-nums[i]是否存在，若存在，将两个下标放入数组中返回；若不存在，将其添加至表中，继续遍历。</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum (<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; numbers.length; i++) &#123;</span><br><span class="line">            tmp = target - numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(tmp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(tmp)+<span class="number">1</span>, i+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>堆栈</title>
    <url>/2022/01/07/%E5%88%B7%E9%A2%98/%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<h3 id="NC76-用两个栈实现队列"><a href="#NC76-用两个栈实现队列" class="headerlink" title="NC76 用两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&&tqId=38552&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC76 用两个栈实现队列</a></h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<p>数据范围： n\le1000<em>n</em>≤1000</p>
<p>要求：存储n个元素的空间复杂度为 O(n)<em>O</em>(<em>n</em>) ，插入与删除的时间复杂度都是 O(1)<em>O</em>(1)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;PSH1&quot;:代表将1插入队列尾部</span><br><span class="line">&quot;PSH2&quot;:代表将2插入队列尾部</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回1</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回2   </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2,1</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>push操作就直接往stack1中push</li>
<li>pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据<strong>全部</strong>转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</li>
</ul>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty() &amp;&amp; stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC52-有效括号序列"><a href="#NC52-有效括号序列" class="headerlink" title="NC52 有效括号序列"></a>NC52 有效括号序列</h3><p><strong>描述</strong></p>
<p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p>
<p>数据范围：字符串长度 0\le n \le 100000≤<em>n</em>≤10000</p>
<p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[]&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>先进后出的话hashMap不好解决</li>
<li>利用栈的先后进先出</li>
<li>每次匹配左半边括号push右半边</li>
<li>匹配右半边括号pop</li>
<li>为空或者匹配不等于最近push进去的值则退出</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4><p>难度中等1064</p>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1]]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2],[3,4]]</span><br><span class="line">输出：[[3,1],[4,2]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>matrix.length == n</code></li>
<li><code>matrix[i].length == n</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong>先转置，后中心轴对称，<strong>巧</strong></p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,left=<span class="number">0</span>,right=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 转置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt; matrix.length; j++) &#123;</span><br><span class="line">                tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中间轴对称</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123;</span><br><span class="line">                tmp=matrix[i][left];</span><br><span class="line">                matrix[i][left]=matrix[i][right];</span><br><span class="line">                matrix[i][right]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>经典题</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    <content><![CDATA[<h3 id="数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合。"><a href="#数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合。" class="headerlink" title="数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。"></a>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</h3><p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong>暴力递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        generateAll(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>*n], <span class="number">0</span>, combinations);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateAll</span><span class="params">(<span class="keyword">char</span>[] current, <span class="keyword">int</span> pos, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == current.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> String(current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current[pos]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">            current[pos]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[] current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : current ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                balance++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p> 解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算每个数出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title">countNums</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!counts.containsKey(num)) counts.put(num,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> counts.put(num, counts.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 打擂台选出最大数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; counts = countNums(nums);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(majorityEntry == <span class="keyword">null</span> || entry.getValue() &gt; majorityEntry.getValue()) majorityEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2022/01/08/%E5%88%B7%E9%A2%98/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="NC68-跳台阶"><a href="#NC68-跳台阶" class="headerlink" title="NC68 跳台阶"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&&tqId=38622&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC68 跳台阶</a></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：0≤<em>n</em>≤40</p>
<p>要求：时间复杂度：$O(n)$ ，空间复杂度： $O(1)$</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2     </span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul>
<li>你可以想如果青蛙当前在第n级台阶上，那它上一步是在哪里呢？</li>
<li>显然，由于它可以跳1级台阶或者2级台阶，所以<strong>它上一步必定在第n-1,或者第n-2级台阶</strong>，也就是说<strong>它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和</strong>。</li>
<li>设跳上 $i$级台阶有 $f(n)$ 种跳法，则它跳上n级的台阶有$f(n)=f(n-1)+f(n-2)$种跳法。</li>
</ul>
<h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            c = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="NC78-反转链表"><a href="#NC78-反转链表" class="headerlink" title="NC78 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&&tqId=38547&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC78 反转链表</a></h3><p><strong>描述</strong></p>
<p>给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。</p>
<p>数据范围： n\leq1000<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1)<em>O</em>(1) ，时间复杂度 O(n)<em>O</em>(<em>n</em>) 。</p>
<p>如当输入链表{1,2,3}时，</p>
<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>
<p>以上转换过程如下图所示：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/4A47A0DB6E60853DEDFCFDF08A5CA249.jpg" alt="img"></p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空链表则输出空         </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>利用next往head列表下一步走</li>
<li>利用pre来保存拼接信息</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211226122019794.png" alt="image-20211226122019794"></p>
<h3 id="NC4-判断链表中是否有环"><a href="#NC4-判断链表中是否有环" class="headerlink" title="NC4 判断链表中是否有环"></a>NC4 判断链表中是否有环</h3><p><strong>描述</strong></p>
<p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<p>数据范围：链表长度 0 \le n \le 100000≤<em>n</em>≤10000，链表中任意节点的值满足 |val| &lt;= 100000∣<em>v<strong>a</strong>l</em>∣&lt;=100000</p>
<p>要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>输入分为2部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p>
<p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/9A058E6590B998B9F7B637155842F993.jpg" alt="img"></p>
<p>可以看出环的入口结点为从头结点开始的第1个结点，所以输出true。</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3,2,0,-4&#125;,1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一部分&#123;3,2,0,-4&#125;代表一个链表，第二部分的1表示，-4到位置1，即-4-&gt;3存在一个链接，组成传入的head为一个带环的链表，返回true        </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,-1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一部分&#123;1&#125;代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false        </span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;-1,-7,7,-4,19,6,-9,-5,-2,-5&#125;,6</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>构建快慢指针</li>
<li>快的走两步，慢的走一步</li>
<li>判断每次只能判断当前与下一步的所指情况，否则容易出现越界的问题（null.next）</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NC3-链表中环的入口结点"><a href="#NC3-链表中环的入口结点" class="headerlink" title="NC3 链表中环的入口结点"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=117&&tqId=37713&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=117&page=1">NC3 链表中环的入口结点</a></h3><p><strong>描述</strong></p>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>
<p>数据范围：n*≤10000，1&lt;=结点值&lt;=10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/DA92C945EF643F1143567935F20D6B46" alt="img"></p>
<p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p>
<p><strong>输入描述：</strong></p>
<p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<p><strong>返回值描述：</strong></p>
<p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2&#125;,&#123;3,4,5&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3   </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;,&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;null&quot;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有环，返回对应编程语言的空结点，后台程序会打印&quot;null&quot;   </span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2   </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>设置快慢指针，假如有环，他们最后一定相遇。</li>
<li>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode low = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == low) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        low = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast!=low) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC50-链表中的节点每k个一组翻转"><a href="#NC50-链表中的节点每k个一组翻转" class="headerlink" title="NC50 链表中的节点每k个一组翻转"></a>NC50 链表中的节点每k个一组翻转</h3><p><strong>描述</strong></p>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p>
<p>数据范围： \ 0 \le n \le 2000 0≤<em>n</em>≤2000 ， 1 \le k \le 20001≤<em>k</em>≤2000 ，链表中每个元素都满足 0 \le val \le 10000≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>例如：</p>
<p>给定的链表是 1\to2\to3\to4\to51→2→3→4→5</p>
<p>对于 k = 2<em>k</em>=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5</p>
<p>对于 k = 3<em>k</em>=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125;,2</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;2,1,4,3,5&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>写一个计算链表长度的子函数，并对链表进行分块</li>
<li>设置一个result存返回值，一个now=result对now进行操作，实际改变了result的值</li>
<li>每一块进行反转<ul>
<li>一个for循环，每次head向前移一位</li>
<li>head.next存tmp</li>
<li>tmp存当前head值</li>
</ul>
</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">int</span> len = length(head);</span><br><span class="line">        <span class="keyword">int</span> block = len/k;</span><br><span class="line">        </span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);    <span class="comment">//用来返回值，保存结果</span></span><br><span class="line">        ListNode now = result;    <span class="comment">//用来移动，操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block; i++) &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++) &#123;    <span class="comment">//将第i块的元素翻转</span></span><br><span class="line">                ListNode bl = head.next;</span><br><span class="line">                head.next = tmp;</span><br><span class="line">                tmp = head;</span><br><span class="line">                head = bl;</span><br><span class="line">            &#125;</span><br><span class="line">            now.next = tmp; </span><br><span class="line">            <span class="keyword">while</span>(now.next != <span class="keyword">null</span>) now = now.next;    <span class="comment">//将now更新到最前的一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">        now.next = head;    <span class="comment">//这里的head已经移到了最后一块不可分割的地方</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (now!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NC96-判断一个链表是否为回文结构"><a href="#NC96-判断一个链表是否为回文结构" class="headerlink" title="NC96 判断一个链表是否为回文结构"></a>NC96 判断一个链表是否为回文结构</h3><p><strong>描述</strong></p>
<p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。</p>
<p>数据范围： 链表节点数 0 \le n \le 10^70≤<em>n</em>≤107，链表中每个节点的值满足 |val| \le 10^7∣<em>v<strong>a</strong>l</em>∣≤107</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;2,1&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2-&gt;1    </span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,2,2,1&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1-&gt;2-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>a链表=b链表 a变b也变</li>
<li>快慢指针找到中点</li>
<li>只反转后半段</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow.next;</span><br><span class="line">        fast = reverse(fast);</span><br><span class="line">        <span class="keyword">while</span>(fast !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != fast.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC40-两个链表生成相加链表"><a href="#NC40-两个链表生成相加链表" class="headerlink" title="NC40 两个链表生成相加链表"></a>NC40 两个链表生成相加链表</h3><p><strong>描述</strong></p>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。</p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。</p>
<p>数据范围：0 \le n,m \le 10000000≤<em>n</em>,<em>m</em>≤1000000，链表任意值 0 \le val \le 90≤<em>v<strong>a</strong>l</em>≤9<br>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/C2DB572B01B0FDC03C097BE7ABA45114" alt="img"></p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[9,3,7],[6,3]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1,0,0,0&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如题面解释   </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0],[6,3]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;6,3&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 \leq n, m \leq 10^61≤n,m≤106</span><br><span class="line">0 \leq a_i, b_i \leq 90≤ai,bi≤9</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>反转相加，注意进位</li>
<li>构造新的链表 （一定得有初始值）       ListNode head = new ListNode(-1);</li>
<li>添加链表的节点需要new一个新的链表  cur.next = new ListNode(val % 10)</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((head1 != <span class="keyword">null</span>) || (head2 != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = carry;</span><br><span class="line">            <span class="keyword">if</span> (head1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                val += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                val += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(val % <span class="number">10</span>);</span><br><span class="line">            carry = val / <span class="number">10</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> reverse(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a><a href="https://leetcode-cn.com/problems/7WHec2/">剑指 Offer II 077. 链表排序</a></h4><p>给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<ul>
<li>先存入数组，然后sort排序，然后存回链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先存入数组，然后sort排序，然后存回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        ListNode p = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            p.val = list.get(i);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>python实现发送邮件</title>
    <url>/2021/05/24/%E5%B0%8F%E8%84%9A%E6%9C%AC/python%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="python实现发送邮件"><a href="#python实现发送邮件" class="headerlink" title="python实现发送邮件"></a>python实现发送邮件</h1><h3 id="申请STMP授权码"><a href="#申请STMP授权码" class="headerlink" title="申请STMP授权码"></a>申请STMP授权码</h3><ol>
<li>在QQ邮箱主界面里面开启POP/SMTP服务：设置-账户-开启pop/smtp服务</li>
</ol>
<p><img src="https://img.imgdb.cn/item/607a9dd78322e6675c8be16b.png" alt="img"></p>
<p><img src="https://img.imgdb.cn/item/607a9dd78322e6675c8be16f.png" alt="img"></p>
<p>2.点击开启pop/smtp服务后，会弹出验证密保，就是通过密保手机号，发送“配置邮件客户端”到1069 0700 69，（自己用手机弄一下就好了），用自己手机发送完后点击“我已发送”</p>
<p><img src="https://img.imgdb.cn/item/607a9dd78322e6675c8be179.png" alt="img"></p>
<p>3.点击“我已发送”后会弹出一个开启POP3/SMTP服务的授权码，这个授权码很重要，要记住这个授权码：授权码很重要，然后点击确定。</p>
<p><img src="https://img.imgdb.cn/item/607a9dd78322e6675c8be193.png" alt="img"></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import formataddr</span><br><span class="line"></span><br><span class="line">my_sender = &#x27;XXXXXXXXX@qq.com&#x27;  # 发件人邮箱账号</span><br><span class="line">my_pass = &#x27;XXXXXXXXXXXXXXXXX&#x27;  # 发件人SMTP授权码</span><br><span class="line">my_user = &#x27;XXXXXXXXX@qq.com&#x27;  # 收件人邮箱账号，我这边发送给自己</span><br><span class="line">msg = MIMEText(&#x27;出bug了&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">msg[&#x27;From&#x27;] = formataddr([&quot;xxxxxx&quot;, my_sender])  # 括号里的对应发件人邮箱昵称、发件人邮箱账号</span><br><span class="line">msg[&#x27;To&#x27;] = formataddr([&quot;xxxxxx&quot;, my_user])  # 括号里的对应收件人邮箱昵称、收件人邮箱账号</span><br><span class="line">msg[&#x27;Subject&#x27;] = &quot;bug&quot;  # 邮件的主题，也可以说是标题</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465)  # 发件人邮箱中的SMTP服务器</span><br><span class="line">server.login(my_sender, my_pass)  # 括号中对应的是发件人邮箱账号、邮箱密码</span><br><span class="line">server.sendmail(my_sender, [my_user, ], msg.as_string())  # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件</span><br><span class="line">server.quit()  # 关闭连接</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://blog.csdn.net/weixin_38166074/article/details/91350457?utm_term=qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%82%AE%E4%BB%B6api&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-91350457&spm=3001.4430">java编写QQ邮箱发送邮件_调用QQ邮箱接口</a><br><a href="https://juejin.cn/post/6844903865083494408">Python3实现邮箱发送</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>图片压缩</title>
    <url>/2021/05/27/%E5%B0%8F%E8%84%9A%E6%9C%AC/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><div class="note info modern">
            <p>最近想做一个相册，图片需要上传到图床然后，调用图床链接进行相册图片显示。为实现图片快速加载，以及节约图床存储空间，写了一个实现图片压缩的小脚本。</p>
          </div>

<p>所用图床：<a href="https://imgtu.com/">路过图床</a></p>
<!-- 最近想做一个相册，图片需要上传到图床然后，调用图床链接进行相册图片显示。为实现图片快速加载，以及节约图床存储空间，写了一个实现图片压缩的小脚本 -->

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree 压缩图片</span></span><br><span class="line">|-- compress</span><br><span class="line">|-- compressPic.py</span><br><span class="line">|-- finish</span><br><span class="line">`-- prepare</span><br><span class="line">    |-- test</span><br><span class="line">    |   `-- IMG1.JPG</span><br><span class="line">    `-- test2</span><br><span class="line">        `-- IMG2.JPG</span><br></pre></td></tr></table></figure>

<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2021/5/25 14:54 </span></span><br><span class="line"><span class="comment"># @Author : SuperBear</span></span><br><span class="line"><span class="comment"># @File : compressPic.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片压缩批处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compressImage</span>(<span class="params">srcPath, dstPath</span>):</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(srcPath):</span><br><span class="line">        <span class="comment"># 如果不存在目的目录则创建一个，保持层级结构</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dstPath):</span><br><span class="line">            os.makedirs(dstPath)</span><br><span class="line">        <span class="comment"># 拼接完整的文件或文件夹路径</span></span><br><span class="line">        srcFile = os.path.join(srcPath, filename)</span><br><span class="line">        dstFile = os.path.join(dstPath, filename)</span><br><span class="line">        <span class="comment"># 如果是文件就处理</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(srcFile):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 打开原图片缩小后保存，可以用if srcFile.endswith(&quot;.jpg&quot;)或者split，splitext等函数等针对特定文件压缩</span></span><br><span class="line">                sImg = Image.<span class="built_in">open</span>(srcFile)</span><br><span class="line">                w, h = sImg.size</span><br><span class="line">                dImg = sImg.resize((<span class="built_in">int</span>(w / <span class="number">1.5</span>), <span class="built_in">int</span>(h / <span class="number">1.5</span>)), Image.ANTIALIAS)  <span class="comment"># 设置压缩尺寸和选项，注意尺寸要用括号</span></span><br><span class="line">                dImg.save(dstFile)  <span class="comment"># 也可以用srcFile原路径保存,或者更改后缀保存，save这个函数后面可以加压缩编码选项JPEG之类的</span></span><br><span class="line">                <span class="built_in">print</span>(dstPath+ dstFile + <span class="string">&quot; 成功！&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="built_in">print</span>(dstFile + <span class="string">&quot;失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果是文件夹就递归</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(srcFile):</span><br><span class="line">            <span class="comment"># print(srcFile)</span></span><br><span class="line">            compressImage(srcFile, dstFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 遍历压缩图片</span></span><br><span class="line">    compressImage(<span class="string">&quot;./prepare&quot;</span>, <span class="string">&quot;./compress&quot;</span>)</span><br><span class="line">    <span class="comment"># 移动文件夹prepare到finish</span></span><br><span class="line">    src_path = <span class="string">&#x27;./prepare/&#x27;</span></span><br><span class="line">    target_path = <span class="string">&#x27;./finish/&#x27;</span></span><br><span class="line">    file_list = os.listdir(src_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(file_list) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">            shutil.move(src_path + file, target_path + file)</span><br></pre></td></tr></table></figure>

<p>github源代码：<a href="https://github.com/sSsuper-Bear/compressPicture/tree/master">https://github.com/sSsuper-Bear/compressPicture/tree/master</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib绘图技巧</title>
    <url>/2022/02/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Matplotlib%E7%BB%98%E5%9B%BE%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Matplotlib绘图技巧"><a href="#Matplotlib绘图技巧" class="headerlink" title="Matplotlib绘图技巧"></a>Matplotlib绘图技巧</h1><h2 id="x轴y轴有小数"><a href="#x轴y轴有小数" class="headerlink" title="x轴y轴有小数"></a><a href="https://blog.csdn.net/qq_36170511/article/details/115525728">x轴y轴有小数</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MaxNLocator</span><br><span class="line">plt.gca().xaxis.set_major_locator(MaxNLocator(integer=<span class="literal">True</span>))</span><br><span class="line">plt.gca().yaxis.set_major_locator(MaxNLocator(integer=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Python中Matplotlib的点（绘制散点图）"><a href="#Python中Matplotlib的点（绘制散点图）" class="headerlink" title="Python中Matplotlib的点（绘制散点图）"></a><a href="https://blog.csdn.net/hesongzefairy/article/details/113527780">Python中Matplotlib的点（绘制散点图）</a></h2><ul>
<li>常用标记点形状：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">‘.’：点(point marker)</span><br><span class="line">‘,’：像素点(pixel marker)</span><br><span class="line">‘o’：圆形(circle marker)</span><br><span class="line">‘v’：朝下三角形(triangle_down marker)</span><br><span class="line">‘^’：朝上三角形(triangle_up marker)</span><br><span class="line">‘&lt;‘：朝左三角形(triangle_left marker)</span><br><span class="line">‘&gt;’：朝右三角形(triangle_right marker)</span><br><span class="line">‘1’：(tri_down marker)</span><br><span class="line">‘2’：(tri_up marker)</span><br><span class="line">‘3’：(tri_left marker)</span><br><span class="line">‘4’：(tri_right marker)</span><br><span class="line">‘s’：正方形(square marker)</span><br><span class="line">‘p’：五边星(pentagon marker)</span><br><span class="line">‘*’：星型(star marker)</span><br><span class="line">‘h’：1号六角形(hexagon1 marker)</span><br><span class="line">‘H’：2号六角形(hexagon2 marker)</span><br><span class="line">‘+’：+号标记(plus marker)</span><br><span class="line">‘x’：x号标记(x marker)</span><br><span class="line">‘D’：菱形(diamond marker)</span><br><span class="line">‘d’：小型菱形(thin_diamond marker)</span><br><span class="line">‘|’：垂直线形(vline marker)</span><br><span class="line">‘_’：水平线形(hline marker)</span><br></pre></td></tr></table></figure>

<ul>
<li>常用线形：linestyle</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">‘-‘：实线(solid line style)</span><br><span class="line"></span><br><span class="line">‘–-‘：虚线(dashed line style)</span><br><span class="line"></span><br><span class="line">‘-.’：点划线(dash-dot line style)</span><br><span class="line"></span><br><span class="line">‘:’：点线(dotted line style)</span><br></pre></td></tr></table></figure>

<ul>
<li>常用颜色：color</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;b&#x27;</span>          蓝色</span><br><span class="line"><span class="string">&#x27;g&#x27;</span>          绿色</span><br><span class="line"><span class="string">&#x27;r&#x27;</span>          红色</span><br><span class="line"><span class="string">&#x27;c&#x27;</span>          青色</span><br><span class="line"><span class="string">&#x27;m&#x27;</span>          品红</span><br><span class="line"><span class="string">&#x27;y&#x27;</span>          黄色</span><br><span class="line"><span class="string">&#x27;k&#x27;</span>          黑色</span><br><span class="line"><span class="string">&#x27;w&#x27;</span>          白色</span><br></pre></td></tr></table></figure>

<ul>
<li>更多颜色：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;+&#x27;</span>, color=<span class="string">&#x27;coral&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210201194636191.png" alt="img"></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>Typora自动上传图片</title>
    <url>/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="Typora-图片自动上传服务器设置"><a href="#Typora-图片自动上传服务器设置" class="headerlink" title="Typora 图片自动上传服务器设置"></a>Typora 图片自动上传服务器设置</h1><ul>
<li>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>（比较稳定建议使用）</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/1972718-20200323210552751-1313111323.png" alt="img"></p>
<ul>
<li><p>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，有两个插件都可以用</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323194553126.png" alt="image-20200323194553126"></p>
</li>
<li><p>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323195546145.png" alt="image-20200323195546145"></p>
</li>
<li><p>token获取：进入码云，点击进入设置页</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323200633225.png" alt="image-20200323200847954"></p>
</li>
<li><p>在PicGo配置Gitee</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220103171035455.png" alt="image-20220103171035455"></p>
</li>
<li><p>配置Typora，点击 文件，偏好设置，选择图像，设置PicGo二进制文件的路径</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323201738802.png" alt="image-20200323201738802"></p>
</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/">https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</a></li>
<li><a href="https://www.cnblogs.com/qtzd/p/12554902.html">https://www.cnblogs.com/qtzd/p/12554902.html</a></li>
<li><a href="https://blog.csdn.net/weixin_41800884/article/details/104718367">https://blog.csdn.net/weixin_41800884/article/details/104718367</a></li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>伪代码</title>
    <url>/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><ol>
<li><p>for,end for,do,while, end while,if,else都用加粗</p>
</li>
<li><p>变量要用花体</p>
</li>
<li><p>不要使用括号，而是使用缩进表示代码块</p>
</li>
<li><p>需要有input，output</p>
</li>
<li><p>需要有行标</p>
</li>
</ol>
<h2 id="伪代码规范"><a href="#伪代码规范" class="headerlink" title="伪代码规范"></a>伪代码规范</h2><p>伪代码是一种接近自然语言的算法描述形式，其目的是在不涉及具体实现（各种编程语言）的情况下将算法的流程和含义清楚的表达出来，因此它没有一个统一的规范，有的仅仅是在长期的实践过程中形成的一些约定俗成的表达样式。下图是一个简单的例子<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:1">1</a>，但已经包含了大多数主要元素</p>
<p><img src="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20210118_%E7%A4%BA%E4%BE%8B%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt="示例伪代码"></p>
<p>首先需要一个<strong>标题</strong>来描述整个算法，一般还会有一个与之一起的编号。在上图中，算法的标题为「Acesscontrol algorithm flow」，编号为「Algorithm 1」。标题与编号一般位于算法顶部，但也有人放在底部，编号多按全文的算法总数进行索引，但也可以按章节分别进行索引。</p>
<p>其次，在正式的算法流之前需要声明<strong>输入和输出</strong>。通常使用关键字 Input 和 Output 来声明，但也有人使用关键字 Data 和 Result。</p>
<p>顺序、选择与循环结构是算法的主体。通常，不同的程序块使用缩进来保持结构清晰，但也有不少人使用垂直连接线进行进一步划分，如上图。另外，和编程语言类似，伪代码中的选择和循环使用 if-then-else、while-do 和 for-do 等关键字和结构来描述<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:2">2</a>，举例如下，其中，每个程序块结束的 end 关键字有人选择写，也有人选择不写。</p>
<p><img src="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20210118_%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="算法流程结构">算法流程结构</p>
<p>赋值操作一般使用左箭头「&lt;—」表示。A[i] 用来表示数组 A 的第 i 个元素，A[1…j] 则表示下标从 1 到 j 的子数组；函数调用使用函数名+传入参数的形式；返回值使用 return 关键字，这些都和常规编程语言相同。需要注意的是，未声明而使用的变量都可以视为算法内的局部变量，如果是全局变量则需要进行解释，可以在上下文中，也可以使用注释；注释的形式也和传统语言相同，使用 // 或 /<em>……</em>/。</p>
<p>算法整体通常使用三线框包围，但也有少部分人使用一个完整的框。</p>
<p>伪代码的语句一般不需要在末尾使用分号，但行首通常会添加行号。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://shuzang.github.io/2021/pseudocode-specification/">科研基础3-伪代码规范</a></li>
<li>怎么在要投稿发表的论文里添加 好看的规范格式的伪代码？ - 张熠的回答 - 知乎 <a href="https://www.zhihu.com/question/29907421/answer/243307404">https://www.zhihu.com/question/29907421/answer/243307404</a></li>
<li><a href="https://blog.csdn.net/u010126059/article/details/51077514">伪代码规范</a></li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>word绘制三线表</title>
    <url>/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/word%E7%BB%98%E5%88%B6%E4%B8%89%E7%BA%BF%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="word绘制三线表"><a href="#word绘制三线表" class="headerlink" title="word绘制三线表"></a>word绘制三线表</h1><ul>
<li><p>插入表格</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115217794.png" alt="image-20220121115217794"></p>
</li>
<li><p>全选表格-右键点击表格属性</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115451664.png" alt="image-20220121115451664"></p>
</li>
<li><p>选择边框和底纹，左边选择“无”</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115532407.png" alt="image-20220121115532407"></p>
</li>
<li><p>手动设置宽度1.5磅，完成下图后确定</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115649343.png" alt="image-20220121115649343"></p>
</li>
<li><p>选择第一行的表格重复上面动作，设置不同宽度的线</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115745079.png" alt="image-20220121115745079"></p>
</li>
<li><p>然后就完成了</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115805179.png" alt="image-20220121115805179"></p>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36890370/article/details/107854266">论文中的三线表绘制（word）</a></li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>添加git快捷方式</title>
    <url>/2021/12/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0git%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Git-右键添加Git-Bash"><a href="#Git-右键添加Git-Bash" class="headerlink" title="Git 右键添加Git Bash"></a>Git 右键添加Git Bash</h2><ol>
<li><strong>win + r</strong></li>
<li><strong>输入regedit</strong></li>
<li><strong>进入 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</strong></li>
<li><strong>新建如下的项 git bash 和 command</strong></li>
</ol>
<p><img src="https://pic.imgdb.cn/item/61c867322ab3f51d91d28270.jpg" alt="img"></p>
<ol start="5">
<li><strong>在git bash 中添加字符串值 Icon ，数值位于git 安装目录下\Git\mingw64\share\git\git-for-windows.ico</strong><img src="https://pic.imgdb.cn/item/61c8674a2ab3f51d91d289b4.jpg" alt="img"></li>
<li><strong>在command 中添加运行的命令，修改默认的数值 \Git\git-bash.exe</strong><img src="https://pic.imgdb.cn/item/61c867662ab3f51d91d2ac8f.jpg" alt="img"></li>
</ol>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.cnblogs.com/mythdoraemon/p/9865567.html">Git 右键添加Git Bash</a></li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>论文添加引用标签</title>
    <url>/2022/01/15/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%AE%BA%E6%96%87%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="论文添加引用标签"><a href="#论文添加引用标签" class="headerlink" title="论文添加引用标签"></a>论文添加引用标签</h1><h2 id="设置引用序号"><a href="#设置引用序号" class="headerlink" title="设置引用序号"></a>设置引用序号</h2><ol>
<li>References中选中引用的文章</li>
</ol>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111622025.png" alt="image-20220114111622025"></p>
<ol start="2">
<li><p>定义新编号格式</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111650945.png" alt="image-20220114111650945"></p>
</li>
<li><p>在编号格式中选择文献引用序号[1]</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111757233.png" alt="image-20220114111757233"></p>
<h2 id="序号引用插入文章中"><a href="#序号引用插入文章中" class="headerlink" title="序号引用插入文章中"></a>序号引用插入文章中</h2><ol>
<li>鼠标插入要引用的位置</li>
<li>点击插入——交叉引用</li>
<li>选择你引用的文章编号</li>
</ol>
</li>
</ol>
<p>​            <img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114112057170.png" alt="image-20220114112057170"></p>
<h2 id="更新序号"><a href="#更新序号" class="headerlink" title="更新序号"></a>更新序号</h2><ul>
<li><p>右键需要更新的序号点击更新域</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114112201454.png" alt="image-20220114112201454"></p>
</li>
<li><p>对所有引用更新</p>
<ul>
<li>ctrl+a全选文章</li>
<li>按F9快捷更新</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/fandroid/article/details/42060883?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&utm_relevant_index=2">word中自动生成参考文献引用及自动更新文献编号</a></li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HPA 使用自定义指标进行伸缩</title>
    <url>/2022/11/14/%E5%B7%A5%E7%A8%8B/HPA%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E6%A0%87%E8%BF%9B%E8%A1%8C%E4%BC%B8%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="HPA-使用自定义指标进行伸缩"><a href="#HPA-使用自定义指标进行伸缩" class="headerlink" title="HPA 使用自定义指标进行伸缩"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#hpa-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E6%A0%87%E8%BF%9B%E8%A1%8C%E4%BC%B8%E7%BC%A9">HPA 使用自定义指标进行伸缩</a></h1><p>Kubernetes 默认提供 CPU 和内存作为 HPA 弹性伸缩的指标，如果有更复杂的场景需求，比如基于业务单副本 QPS 大小来进行自动扩缩容，可以考虑自行安装 <a href="https://github.com/DirectXMan12/k8s-prometheus-adapter">prometheus-adapter</a> 来实现基于自定义指标的 Pod 弹性伸缩。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></h2><p>Kubernetes 提供了 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md">Custom Metrics API</a> 与 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/external-metrics-api.md">External Metrics API</a> 来对 HPA 的指标进行扩展，让用户能够根据实际需求进行自定义。</p>
<p>prometheus-adapter 对这两种 API 都有支持，通常使用 Custom Metrics API 就够了，本文也主要针对此 API 来实现使用自定义指标进行弹性伸缩。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">前提条件</a></h2><ul>
<li>部署有 Prometheus 并做了相应的自定义指标采集。</li>
<li>已安装 <a href="https://helm.sh/docs/intro/install/">helm</a> 。</li>
</ul>
<h2 id="业务暴露监控指标"><a href="#业务暴露监控指标" class="headerlink" title="业务暴露监控指标"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E4%B8%9A%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87">业务暴露监控指标</a></h2><p>这里使用Promethues+SpringBoot结合的指标暴露服务，</p>
<p>该示例程序暴露了 <code>httpserver_requests_total</code> 指标，记录 HTTP 的请求，通过这个指标可以计算出该业务程序的 QPS 值。</p>
<h2 id="部署业务程序"><a href="#部署业务程序" class="headerlink" title="部署业务程序"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E9%83%A8%E7%BD%B2%E4%B8%9A%E5%8A%A1%E7%A8%8B%E5%BA%8F">部署业务程序</a></h2><p>将前面的程序打包成容器镜像，然后部署到集群，比如使用 Deployment 部署:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metricdemoapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">metricdemoapp</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">        <span class="attr">prometheus.io/path:</span> <span class="string">&quot;/actuator/prometheus&quot;</span></span><br><span class="line">        <span class="attr">prometheus.io/port:</span> <span class="string">&quot;http&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metricdemoapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/hardy_clouddo/metrics-demo-app:v1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">&quot;/actuator/prometheus&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">metricdemoapp</span></span><br></pre></td></tr></table></figure>

<h2 id="Prometheus-采集业务监控"><a href="#Prometheus-采集业务监控" class="headerlink" title="Prometheus 采集业务监控"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#prometheus-%E9%87%87%E9%9B%86%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7">Prometheus 采集业务监控</a></h2><p>业务部署好了，我们需要让我们的 Promtheus 去采集业务暴露的监控指标。</p>
<h3 id="方式一-配置-Prometheus-采集规则"><a href="#方式一-配置-Prometheus-采集规则" class="headerlink" title="方式一: 配置 Prometheus 采集规则"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E6%96%B9%E5%BC%8F%E4%B8%80-%E9%85%8D%E7%BD%AE-promtheus-%E9%87%87%E9%9B%86%E8%A7%84%E5%88%99">方式一: 配置 Prometheus 采集规则</a></h3><p>在 Promtheus 的采集规则配置文件添加采集规则（k8s部署的没找到promethues.yaml）:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">httpserver</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">  <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">httpserver</span></span><br><span class="line">  <span class="attr">relabel_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">    <span class="attr">source_labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">__meta_kubernetes_service_label_app</span></span><br><span class="line">    <span class="attr">regex:</span> <span class="string">httpserver</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">    <span class="attr">source_labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">__meta_kubernetes_endpoint_port_name</span></span><br><span class="line">    <span class="attr">regex:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>

<h3 id="方式二-配置-ServiceMonitor"><a href="#方式二-配置-ServiceMonitor" class="headerlink" title="方式二: 配置 ServiceMonitor"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E6%96%B9%E5%BC%8F%E4%BA%8C-%E9%85%8D%E7%BD%AE-servicemonitor">方式二: 配置 ServiceMonitor</a></h3><p>若已安装 prometheus-operator，则可通过创建 ServiceMonitor 的 CRD 对象配置 Prometheus。示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.coreos.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceMonitor</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metricdemoapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/prometheus</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchNames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">metricdemoapp</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">metricdemoapp</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-prometheus-adapter"><a href="#安装-prometheus-adapter" class="headerlink" title="安装 prometheus-adapter"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E5%AE%89%E8%A3%85-prometheus-adapter">安装 prometheus-adapter</a></h2><p>我们使用 helm 安装 <a href="https://artifacthub.io/packages/helm/prometheus-community/prometheus-adapter">prometheus-adapter</a>，安装前最重要的是确定并配置自定义指标，按照前面的示例，我们业务中使用 <code>httpserver_requests_total</code> 这个指标来记录 HTTP 请求，那么我们可以通过类似下面的 PromQL 计算出每个业务 Pod 的 QPS 监控:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(rate(http_requests_total[2m])) by (pod)</span><br></pre></td></tr></table></figure>

<p>我们需要将其转换为 prometheus-adapter 的配置，准备一个 <code>values.yaml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">custom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">seriesQuery:</span> <span class="string">&#x27;micro_req_total&#x27;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">&lt;&lt;.Resource&gt;&gt;</span></span><br><span class="line">    <span class="attr">name:</span></span><br><span class="line">      <span class="attr">matches:</span> <span class="string">&quot;micro_req_total&quot;</span></span><br><span class="line">      <span class="attr">as:</span> <span class="string">&quot;httpserver_requests_qps&quot;</span> <span class="comment"># PromQL 计算出来的 QPS 指标</span></span><br><span class="line">    <span class="attr">metricsQuery:</span> <span class="string">sum(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[1m]))</span> <span class="string">by</span> <span class="string">(&lt;&lt;.GroupBy&gt;&gt;)</span></span><br><span class="line"><span class="attr">prometheus:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://10.1.13.113</span> <span class="comment"># 替换 Prometheus API 的地址 (不写端口)</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">31186</span></span><br></pre></td></tr></table></figure>

<p>执行 helm 命令进行安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line"><span class="comment"># Helm 3</span></span><br><span class="line">helm install prometheus-adapter prometheus-community/prometheus-adapter -f values.yaml</span><br><span class="line"><span class="comment"># Helm 2</span></span><br><span class="line"><span class="comment"># helm install --name prometheus-adapter prometheus-community/prometheus-adapter -f values.yaml</span></span><br></pre></td></tr></table></figure>



<h2 id="测试是否安装正确"><a href="#测试是否安装正确" class="headerlink" title="测试是否安装正确"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%AD%A3%E7%A1%AE">测试是否安装正确</a></h2><p>如果安装正确，是可以看到 Custom Metrics API 返回了我们配置的 QPS 相关指标:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;APIResourceList&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;groupVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resources&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jobs.batch/httpserver_requests_qps&quot;</span>,</span><br><span class="line">      <span class="string">&quot;singularName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;namespaced&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">      <span class="string">&quot;verbs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;get&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pods/httpserver_requests_qps&quot;</span>,</span><br><span class="line">      <span class="string">&quot;singularName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;namespaced&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">      <span class="string">&quot;verbs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;get&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;namespaces/httpserver_requests_qps&quot;</span>,</span><br><span class="line">      <span class="string">&quot;singularName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;namespaced&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">      <span class="string">&quot;verbs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;get&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也能看到业务 Pod 的 QPS 值:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1/namespaces/httpserver/pods/*/httpserver_requests_qps</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;selfLink&quot;</span>: <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta1/namespaces/httpserver/pods/%2A/httpserver_requests_qps&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;items&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;describedObject&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">        <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;httpserver&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;httpserver-6f94475d45-7rln9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;/v1&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;metricName&quot;</span>: <span class="string">&quot;httpserver_requests_qps&quot;</span>,</span><br><span class="line">      <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-11-17T09:14:36Z&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;500m&quot;</span>,</span><br><span class="line">      <span class="string">&quot;selector&quot;</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面示例 QPS 为 <code>500m</code>，表示 QPS 值为 0.5</p>
</blockquote>
<h2 id="测试-HPA"><a href="#测试-HPA" class="headerlink" title="测试 HPA"></a><a href="https://imroc.cc/kubernetes/best-practices/autoscaling/hpa-with-custom-metrics.html#%E6%B5%8B%E8%AF%95-hpa">测试 HPA</a></h2><p>假如我们设置每个业务 Pod 的平均 QPS 达到 50，就触发扩容，最小副本为 1 个，最大副本为1000，HPA 可以这么配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpserver</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">httpserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">httpserver</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">httpserver_requests_qps</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br></pre></td></tr></table></figure>

<p>然后对业务进行压测，观察是否扩容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get hpa</span><br><span class="line">NAME         REFERENCE               TARGETS     MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">httpserver   Deployment/httpserver   83933m/50   1         1000      2          18h</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                          READY   STATUS              RESTARTS   AGE</span><br><span class="line">httpserver-6f94475d45-47d5w   1/1     Running             0          3m41s</span><br><span class="line">httpserver-6f94475d45-7rln9   1/1     Running             0          37h</span><br><span class="line">httpserver-6f94475d45-6c5xm   0/1     ContainerCreating   0          1s</span><br><span class="line">httpserver-6f94475d45-wl78d   0/1     ContainerCreating   0          1s</span><br></pre></td></tr></table></figure>

<p>扩容正常则说明已经实现 HPA 基于业务自定义指标进行弹性伸缩。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Promethues结合Springboot</title>
    <url>/2022/11/14/%E5%B7%A5%E7%A8%8B/Prometheus%E7%BB%93%E5%90%88Springboot/</url>
    <content><![CDATA[<h1 id="Promethues结合Springboot"><a href="#Promethues结合Springboot" class="headerlink" title="Promethues结合Springboot"></a>Promethues结合Springboot</h1><p>项目地址：<a href="https://gitee.com/sssuperbear/promethues-metricdemo.git">https://gitee.com/sssuperbear/promethues-metricdemo.git</a></p>
<h3 id="Metrics指标类型以及使用场景："><a href="#Metrics指标类型以及使用场景：" class="headerlink" title="Metrics指标类型以及使用场景："></a>Metrics指标类型以及使用场景：</h3><ul>
<li>Counter，只增不减的计数器</li>
<li>Gauge，可增可减的仪表盘</li>
<li>Histogram，自带buckets区间用于统计分布统计图</li>
<li>Summary， 客户端定义的数据分布统计图 除了上述方法我们也可以通过<code>拦截器/过滤器</code>：用于统计所有应用请求的情况等</li>
</ul>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="添加application-yaml"><a href="#添加application-yaml" class="headerlink" title="添加application.yaml"></a>添加application.yaml</h2><p>添加application.yaml之后，可以查询路径变为：/actuator/prometheus</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus-example</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="添加MetricInterceptor类"><a href="#添加MetricInterceptor类" class="headerlink" title="添加MetricInterceptor类"></a>添加MetricInterceptor类</h2><p>该类规定了自定义的一些指标count的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry meterRegistry;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Timer.Sample&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 总计数 + 1</span></span><br><span class="line">        meterRegistry.counter(<span class="string">&quot;micro_req_total&quot;</span>, Tags.of(<span class="string">&quot;url&quot;</span>, request.getRequestURI(), <span class="string">&quot;method&quot;</span>, request.getMethod())).increment();</span><br><span class="line">        <span class="comment">// 处理中计数 +1</span></span><br><span class="line">        meterRegistry.gauge(<span class="string">&quot;micro_process_req&quot;</span>, Tags.of(<span class="string">&quot;url&quot;</span>, request.getRequestURI(), <span class="string">&quot;method&quot;</span>, request.getMethod()), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Timer.Sample sample = Timer.start();</span><br><span class="line">        threadLocal.set(sample);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            meterRegistry.gauge(<span class="string">&quot;micro_process_req&quot;</span>, Tags.of(<span class="string">&quot;url&quot;</span>, request.getRequestURI(), <span class="string">&quot;method&quot;</span>, request.getMethod()), -<span class="number">1</span>);</span><br><span class="line">            Timer timer = Timer.builder(<span class="string">&quot;micro_req_histogram&quot;</span>).minimumExpectedValue(Duration.ofMillis(<span class="number">1</span>)).maximumExpectedValue(Duration.ofMinutes(<span class="number">3</span>))</span><br><span class="line">                    .sla(Duration.ofMillis(<span class="number">10</span>), Duration.ofMillis(<span class="number">50</span>), Duration.ofMillis(<span class="number">100</span>), Duration.ofMillis(<span class="number">300</span>), Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">                    .tags(Tags.of(<span class="string">&quot;url&quot;</span>, request.getRequestURI(), <span class="string">&quot;method&quot;</span>, request.getMethod(), <span class="string">&quot;code&quot;</span>, String.valueOf(response.getStatus())))</span><br><span class="line">                    .register(meterRegistry);</span><br><span class="line">            threadLocal.get().stop(timer);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="主程序中添加注册代码"><a href="#主程序中添加注册代码" class="headerlink" title="主程序中添加注册代码"></a>主程序中添加注册代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.interceptor.MetricInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span>  <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MetricInterceptor <span class="title">metricInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MetricInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(metricInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Controller中添加查询注册代码"><a href="#Controller中添加查询注册代码" class="headerlink" title="Controller中添加查询注册代码"></a>Controller中添加查询注册代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，这个是注册的核心代码块</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MeterRegistryCustomizer&lt;MeterRegistry&gt; <span class="title">configurer</span><span class="params">(<span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span> String applicationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (registry) -&gt; registry.config().commonTags(<span class="string">&quot;application&quot;</span>, applicationName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>PsTips</title>
    <url>/2022/01/03/%E6%91%84%E5%BD%B1/PsTips/</url>
    <content><![CDATA[<ul>
<li>[ 画笔增大</li>
<li>] 画笔减小</li>
<li>ctrl+i 反向</li>
<li>ctrl+t 自由变换工具</li>
<li>调出红色非选区遮罩：快捷键shift+alt + 点</li>
</ul>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
  </entry>
  <entry>
    <title>人像嘴唇颜色更改</title>
    <url>/2021/06/04/%E6%91%84%E5%BD%B1/%E4%BA%BA%E5%83%8F%E5%98%B4%E5%94%87%E9%A2%9C%E8%89%B2%E6%9B%B4%E6%94%B9/</url>
    <content><![CDATA[<h3 id="人像嘴唇颜色更改"><a href="#人像嘴唇颜色更改" class="headerlink" title="人像嘴唇颜色更改"></a>人像嘴唇颜色更改</h3><ul>
<li><p>打开图片</p>
<p><img src="https://pic.imgdb.cn/item/60b9d4138355f7f718862da7.png" alt="image-20210604112727351"></p>
</li>
<li><p>方法一</p>
<ul>
<li><p>新建一个空白图层，图层混合模式设为<em><strong>“颜色”</strong></em>，这样只会更改它的颜色，而不会更改他的质感。</p>
</li>
<li><p>选择画笔工具调整不透明度（51%）+流量（56%）</p>
</li>
<li><p>找到所需要的颜色，找到之后就可以直接画了</p>
</li>
<li><p>涂完之后如果觉得有点太过了的话，可以降低一点他的透明度。</p>
<p><img src="https://pic.imgdb.cn/item/60b9d4298355f7f7188811e5.png" alt="image-20210604113032303"></p>
</li>
</ul>
</li>
<li><p>方法二</p>
<ul>
<li><p>建立一个纯色图层</p>
<p><img src="https://pic.imgdb.cn/item/60b9d4348355f7f71888f1d2.png" alt="image-20210604141536603"></p>
</li>
<li><p>ctrl+i  反向蒙版颜色</p>
</li>
<li><p>把图层模式改成颜色</p>
</li>
<li><p>调节不透明度使其自然</p>
</li>
</ul>
</li>
<li><p>方法三</p>
<ul>
<li>对于已经涂了口红的图，嘴唇的颜色杂色不多的情况下</li>
<li>复制图层，选择滤镜—&gt;camera raw</li>
<li>HSL调整—&gt;饱和度—&gt;红色</li>
<li>如果不想影响其他地方红色，选择蒙版，把她嘴唇涂出来</li>
</ul>
</li>
<li><p>方法四</p>
<ul>
<li><p>添加选择可选颜色图层</p>
<p><img src="https://pic.imgdb.cn/item/60b9d4448355f7f7188a45c7.png" alt="image-20210604150219774"></p>
</li>
<li><p>调节颜色之后，添加蒙版，选择嘴唇</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>PS</tag>
        <tag>人像</tag>
      </tags>
  </entry>
  <entry>
    <title>人像眉毛精致化处理</title>
    <url>/2021/06/04/%E6%91%84%E5%BD%B1/%E4%BA%BA%E5%83%8F%E7%9C%89%E6%AF%9B%E7%B2%BE%E8%87%B4%E5%8C%96%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="人像眉毛精致化处理"><a href="#人像眉毛精致化处理" class="headerlink" title="人像眉毛精致化处理"></a>人像眉毛精致化处理</h3><ul>
<li>导入图像，稍微调整一下曝光度(+0.25)+对比度(+6)使眉毛比较明显。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60b9d34d8355f7f71875cddc.png" alt="image-20210604101144306"></p>
<ul>
<li><p>放大图片，看一下眉毛所存在的问题</p>
<ul>
<li>眉毛中间有很多空缺</li>
<li>外面存在杂发、杂眉毛</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60b9d35d8355f7f718771b44.png" alt="image-20210604101722568"></p>
<ul>
<li><p>处理步骤</p>
<ul>
<li><p>复制图层，用修补工具把外面杂乱的眉毛修掉</p>
<p><img src="https://pic.imgdb.cn/item/60b9d3788355f7f718796aa5.png" alt="image-20210604102339995"></p>
</li>
<li><p>用锁套工具将长得比较好的眉毛截选出来，然后将截选出的眉毛拷贝成一个图层</p>
<p><img src="https://pic.imgdb.cn/item/60b9d3898355f7f7187ac111.png" alt="image-20210604102640501"></p>
</li>
<li><p>将眉毛移动到眉毛空缺的地方</p>
</li>
<li><p>利用自有变换工具（ctrl+t）调整角度，使其纹理走向与原图匹配</p>
</li>
<li><p>将图层混合模式改成深色</p>
<p><img src="https://pic.imgdb.cn/item/60b9d3988355f7f7187bf9e0.png" alt="image-20210604103202011"></p>
</li>
<li><p>创建蒙版，<em><strong>ctrl+i</strong></em>蒙版反向（蒙版黑色不可见，白色可见）</p>
<p><img src="https://pic.imgdb.cn/item/60b9d3a78355f7f7187d3db4.png" alt="image-20210604103253913"></p>
<p><img src="https://pic.imgdb.cn/item/60b9d3b48355f7f7187e5391.png" alt="image-20210604103800722"></p>
</li>
<li><p>使用画笔，将画笔颜色改成白色，降低画笔不透明度（这里不透明度为54%）。</p>
</li>
<li><p>将眉毛用白色画笔画出来</p>
</li>
<li><p>如果还不够就新建一个图层</p>
</li>
<li><p>利用吸管工具吸取一个眉毛中比较深的颜色</p>
</li>
<li><p>将画笔调小一点（2）不透明度调低一点（36%）</p>
</li>
<li><p>调整完毕之后就大功告成了</p>
<p><img src="https://pic.imgdb.cn/item/60b9d3cb8355f7f718803ef7.png" alt="image-20210604112307771"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>PS</tag>
        <tag>人像</tag>
      </tags>
  </entry>
  <entry>
    <title>后期PS处理调色思路</title>
    <url>/2021/06/07/%E6%91%84%E5%BD%B1/%E5%90%8E%E6%9C%9FPS%E5%A4%84%E7%90%86%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="后期PS处理调色思路"><a href="#后期PS处理调色思路" class="headerlink" title="后期PS处理调色思路"></a>后期PS处理调色思路</h4><ul>
<li>基础调整<ul>
<li>白平衡<ul>
<li>色温：控制照片冷暖感觉的工具</li>
<li>色调：照片整体的一个色彩倾向（一般默认不调）</li>
</ul>
</li>
<li>曝光：调节照片的明暗</li>
<li>高光：压低高光，可以找回高光区的细节</li>
<li>白色：压低白色，找回照片中白色的细节</li>
<li>阴影：控制照片中偏暗的部分</li>
<li>黑色：控制照片中黑色看不到细节的部分</li>
</ul>
</li>
<li>HSL调整<ul>
<li>色相：色彩的相貌<ul>
<li>把某个颜色定义成自己拖动到的颜色</li>
</ul>
</li>
<li>饱和度：颜色的纯度<ul>
<li>数字越大说明纯度越高</li>
</ul>
</li>
<li>明亮度：颜色的明暗程度<ul>
<li>拉高橙色，画面中橙色就会变亮一些，拉低橙色，画面中的橙色就会变暗一些</li>
</ul>
</li>
<li>如何使用？<ul>
<li>亚洲人的皮肤<em><strong>橙色</strong></em>是最多的，亚洲人的皮肤关键在于橙色<ul>
<li>降低橙色饱和度，使其皮肤通透点</li>
<li>提高橙色明亮度，使其皮肤白皙水嫩</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>控制相机对焦参数</title>
    <url>/2021/06/06/%E6%91%84%E5%BD%B1/%E6%8E%A7%E5%88%B6%E7%9B%B8%E6%9C%BA%E5%AF%B9%E7%84%A6%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="控制相机对焦的参数"><a href="#控制相机对焦的参数" class="headerlink" title="控制相机对焦的参数"></a>控制相机对焦的参数</h3><h4 id="画面清晰"><a href="#画面清晰" class="headerlink" title="画面清晰"></a>画面清晰</h4><ul>
<li><p>什么是对焦</p>
</li>
<li><p>对焦区域</p>
<ul>
<li><p>区域自动对焦，大区域自动对焦</p>
<ul>
<li>特点：精度一般</li>
<li>适合场景：运动员/运动题材</li>
</ul>
</li>
<li><p>45点自动对焦</p>
<ul>
<li>特点：对焦容易/精确度较差</li>
<li>适合场景：风格/大场景</li>
</ul>
</li>
<li><p>单点自动对焦</p>
<ul>
<li>特点：精确度高</li>
<li>适合场景：人物/产品/特写</li>
</ul>
</li>
</ul>
</li>
<li><p>对焦模式</p>
<ul>
<li><p>AF（自动对焦）</p>
<ul>
<li>使用<ul>
<li>半按快门</li>
</ul>
</li>
<li>分类<ul>
<li>单次自动对焦—&gt;半按快门对焦一次，适合拍静止物体</li>
<li>人工智能伺服对焦——半按快门对焦多次，适合拍运动物体</li>
<li>人工智能自动对焦——适合拍无法准确预判是否运动的物体</li>
</ul>
</li>
</ul>
</li>
<li><p>MF（手动对焦）</p>
<ul>
<li><p>使用</p>
<ul>
<li><p>转动对焦环对焦</p>
<p><img src="https://pic.imgdb.cn/item/60bc351d8355f7f718b747fa.png" alt="image-20210606101212207"></p>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>暗环境下拍摄<ul>
<li>在AF自动对焦模式下，经常会出现对焦困难的情况</li>
</ul>
</li>
<li>逆光环境<ul>
<li>光线进入镜头很多，有较强烈的眩光效果，用AF可能不太好对焦</li>
</ul>
</li>
<li>光斑等特殊效果拍摄<ul>
<li>转动对焦环，直到出现较漂亮的光斑效果，再进行拍摄</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>控制相机曝光参数</title>
    <url>/2021/06/06/%E6%91%84%E5%BD%B1/%E6%8E%A7%E5%88%B6%E7%9B%B8%E6%9C%BA%E6%9B%9D%E5%85%89%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="控制相机曝光的参数"><a href="#控制相机曝光的参数" class="headerlink" title="控制相机曝光的参数"></a>控制相机曝光的参数</h3><h4 id="明暗合适"><a href="#明暗合适" class="headerlink" title="明暗合适"></a>明暗合适</h4><ul>
<li><p>曝光三要素</p>
<ul>
<li><p>光圈</p>
<ul>
<li>光圈在相机中是F来表示，F后面的数字越小，表示光圈越大（光圈越大—&gt;进光量越多）</li>
<li>F+数字越小—&gt;光圈越大</li>
<li>光圈越大，背景虚化越强    光圈越小，背景虚化越弱</li>
<li>使用<ul>
<li>当相机在<em><strong>Av光圈</strong></em>优先模式下，可以通过转动<em><strong>快门附近的拨盘</strong></em>进行调节。</li>
<li>当相机在<em><strong>M手动模式</strong></em>的时候，转动<em><strong>DIAL FUNC拨盘</strong></em>进行调节。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60bc357f8355f7f718bc2167.png" alt="image-20210605183802551"></p>
</li>
<li><p>快门</p>
<ul>
<li>快门时间长—&gt;进光量多—&gt;照片亮</li>
<li>1/60或60表示1/60秒，1’’表示1秒</li>
<li>短快门—&gt;抓拍瞬间，长快门—&gt;记录轨迹</li>
<li>使用<ul>
<li>Tv快门优先和M手动模式都是通过<em><strong>快门拨盘</strong></em>来调节</li>
</ul>
</li>
</ul>
</li>
<li><p>ISO（感光度）</p>
<ul>
<li>感光度是感光元件对光线的敏感程度与，简称ISO</li>
<li>数字越大—&gt;对光线越敏感，数字越小—&gt;对光线越不敏感</li>
<li>ISO越高—&gt;噪点越多—&gt;画面越粗糙，ISO越低—&gt;噪点越少—&gt;画面越细腻</li>
<li>手持排夜景、抓拍运动物体、长焦镜头拍摄可调高ISO</li>
</ul>
</li>
</ul>
</li>
<li><p>光圈、快门、ISO之间的关系</p>
<ul>
<li><p>以水龙头作为比喻</p>
<ul>
<li>阀门打开的大小—&gt;光圈大小</li>
<li>水流的时间—&gt;快门时间</li>
<li>流出水的总量—&gt;进光量</li>
</ul>
</li>
<li><p>在光线比较充足的情况下，为了保证照片的画质，我们通常会选择100-200之间的低ISO，ISO作为一个相对固定的参数，我们暂时不予考虑</p>
</li>
<li><p>进光量一定 光圈越大—&gt;快门时间越短，光圈越小—&gt;快门时间越长</p>
</li>
<li><p>虚化效果—&gt;大光圈+短快门</p>
</li>
<li><p>运动轨迹/慢门效果—&gt;长快门+小光圈</p>
</li>
</ul>
</li>
<li><p>曝光模式</p>
<ul>
<li><p>A+    全自动模式</p>
<ul>
<li>光圈、快门、ISO都由相机自动设置</li>
</ul>
</li>
<li><p>P      程序自动模式</p>
<ul>
<li>光圈、快门由相机自动设置，ISO可以手动设置</li>
</ul>
</li>
<li><p>Tv     快门优先模式</p>
<ul>
<li>快门时间、ISO可手动设置，光圈由相机自动匹配</li>
</ul>
</li>
<li><p>Av     光圈优先模式(很多人喜欢这种模式)</p>
<ul>
<li>光圈、ISO可手动设置，快门速度由相机自动匹配</li>
</ul>
</li>
<li><p>M      全手动模式</p>
<ul>
<li>光圈、快门、ISO都由我们手动设置</li>
</ul>
</li>
<li><p>SCN  场景自动模式</p>
<ul>
<li>人像：相机会自动采用大光圈形成背景虚化突出人物</li>
<li>风光：相机自动采用小光圈使整体清晰</li>
<li>运动：相机自动提高快门速度跟容易抓拍运动物体</li>
</ul>
</li>
</ul>
</li>
<li><p>测光模式</p>
<ul>
<li><p>测光模式：相机可以自动侦测周围光线情况，侦测光线的方式不同就有了不同的测光模式</p>
</li>
<li><p>新手常用的测光模式：</p>
<ul>
<li>评价测光（矩阵）：把画面分成若干个区域进行测光，加权平均后作为曝光基准（适合生活中90%的拍摄场景）</li>
<li>点测光：对画面中的“点”进行测光作为曝光基准（适合在逆光等复杂的环境下进行拍摄）</li>
</ul>
</li>
</ul>
</li>
<li><p>曝光补偿</p>
<ul>
<li>什么是曝光补偿：曝光补偿就是对画面亮度的补偿效果，在Av/Tv/P这种半自动模式下，可以手动调整曝光补偿改变画面亮度。</li>
<li>曝光补偿在相机中是如何表示的：曝光补偿在相机中是以刻度表的形式呈现的，并且可以调节正负</li>
<li>如何使用<ul>
<li>白加黑减（拍白色占比比较大的物体加一点曝光补偿，拍黑色占比比较大的物体减一些曝光补偿）</li>
<li>明快小清新风格照片：交易点曝光补偿，让照片微微过曝</li>
<li>剪影效果照片：减一点曝光补偿，让剪影效果更加明显</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>控制相机色彩参数</title>
    <url>/2021/06/06/%E6%91%84%E5%BD%B1/%E6%8E%A7%E5%88%B6%E7%9B%B8%E6%9C%BA%E8%89%B2%E5%BD%A9%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="控制相机色彩的参数"><a href="#控制相机色彩的参数" class="headerlink" title="控制相机色彩的参数"></a>控制相机色彩的参数</h3><h4 id="色彩合理"><a href="#色彩合理" class="headerlink" title="色彩合理"></a>色彩合理</h4><ul>
<li><p>白平衡</p>
<ul>
<li><p>白平衡可以帮助我们在复杂光源下，还原物体本身的颜色</p>
</li>
<li><p>几种白平衡模式</p>
<ul>
<li><p>自动（AWB）</p>
</li>
<li><p>日光</p>
</li>
<li><p>阴影</p>
<ul>
<li>拍摄夕阳是，想要营造暖色调，故意调到阴影白平衡，让相机给画面加入更多的暖色调</li>
</ul>
</li>
<li><p>阴天</p>
</li>
<li><p>钨丝灯</p>
</li>
<li><p>白色荧光灯</p>
<ul>
<li>拍摄大海时，为了突出大海碧蓝的清冷效果，也可以故意设置成白色荧光灯白平衡，让相机为画面加入更多的蓝色调</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影经验——转载</title>
    <url>/2021/06/07/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E7%BB%8F%E9%AA%8C%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="人像摄影怎么拍"><a href="#人像摄影怎么拍" class="headerlink" title="人像摄影怎么拍"></a>人像摄影怎么拍</h3><h2 id="1-构图"><a href="#1-构图" class="headerlink" title="1. 构图"></a><strong>1. 构图</strong></h2><p>首先，是人像拍摄中，构图的问题。</p>
<p>关于构图在摄影中的重要性大家都有自己的认知，面对于不同的摄影风格，有的风格讲究构图讲究严谨，例如古风，有的风格构图上更倾向于自然不拘谨，例如很多日系生活感的照片拍摄，有的风格会倾向于以画面的张力和情绪为优先考虑，而完全不会被构图束缚。例如我们都听说的日本荒木老前辈，所以摄影的构图该如何去做，其实取决于你所喜欢并想要做到极致的那一类摄影风格而定。</p>
<p>我今天就说一下我自己的构图习惯，我的拍摄风格，多数是安静的画面，画面感比较干净，构图也算是偏向严谨类方向的类型，当然我的风格也可能会慢慢转变，毕竟这些都是受自己的审美所影响的，审美发生了变化，风格也会慢慢的发生变化。</p>
<p>我的很多学生，来找我报名课程系统学习摄影的时候，他们多数都是近似一张白纸，在这样的情况下，面对构图的问题，我基本会对他们有两点要求：就是<strong>先用好居中构图和三分之一构图。</strong>用好这两种构图方法的同时再慢慢去找到自己在摄影中的风格和感觉，当这两种构图方法能运用得心应手的时候， 再去在画面中尝试加入别的变化也是很轻松的事情。</p>
<p>你可能会说：老师，你说的这两种方法我都懂都明白，这也太简单了吧？其实，你能把居中构图和三分之一构图用明白，用好，并不是一件看上去那么简单的事情呦~~~</p>
<p>我对学生的要求是：用三分之一构图去拍照，画面的人物主体虽然在这个位置，但是<strong>你要尝试用别的方法让他们在画面中找到平衡感</strong>；使用居中构图的时候，<strong>尝试用你的创意让的照片变的与众不同</strong>。</p>
<p><img src="https://pic2.zhimg.com/v2-22c0ce4a3965d372445b1af9f364720d_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L，客户的拍摄，青海茶卡盐湖</p>
<p>例如这张照片，如果从构图上说，他就是一个很普通的居中构图，但是因为加入了多重曝光的创意配合夕阳时的美丽景色，让照片变的不那么普通。</p>
<p><img src="https://pic4.zhimg.com/v2-bc609a0d431d430d607c4fe65e86b7f3_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p><img src="https://pic4.zhimg.com/v2-8537eddd6a8ac347b287c858661e4247_b.jpg" alt="img"></p>
<p>这是一张三分之一构图的照片,人物位于照片中的三分之一的位置，虽然只是简单的坐在那里，但是因为<strong>人物视线的方向与光线的互动</strong>，给阅读这张照片的读者做出了读图的引导，也是因为这样简单的互动，让照片有了氛围感。</p>
<p><img src="https://pic1.zhimg.com/v2-ac0ed4d69b7c1b8fe37ebb729c96f5c4_b.jpg" alt="img"></p>
<p>佳能胶片机EOS1V+2470 2.8L+portra400 拍摄于香港</p>
<p><img src="https://pic4.zhimg.com/v2-53160f3e08573c69bb18a77b51e49e7f_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p>而这两张照片人物也是所处于三分之一的位置，通过线条的延伸感和画面中其他的色块，来让画面变的平衡。</p>
<p>我在拍摄当中，极少出现那类地平线歪歪斜斜的画面，<strong>多数都是这类四平八稳的构图方式。</strong>但是就像给大家展示的思路那样，我喜欢用画面中其他的元素，让这类构图简单的画面，变得不那么普通。</p>
<p>虽然看似基础，但可以变化的思路真的是超级多，构图的其他思路就真的太多了，什么框式构图，什么线条，什么构图中的三角形，但觉得你不妨先把最基本的做到最好，我总会和学生们墨迹一句话:对于摄影师来说，好的拍摄习惯一旦养成以后，就会像吃饭，睡觉一样变成你的一种习惯，好的构图习惯和用光方式也是一样可以成为这样的习惯。</p>
<p>其实我自己现在在拍照的时候很多都是习惯性的就那样去拍摄了，拍摄的当时并没有刻意 的去烧脑纠结什么构图之类的，希望这个思路可以对大家有点启发。</p>
<h2 id="2-引导模特"><a href="#2-引导模特" class="headerlink" title="2. 引导模特"></a><strong>2. 引导模特</strong></h2><p>人像拍摄中，如何沟通引导被拍摄的人，拍出自然的感觉呢？</p>
<p>关于引导的思路很多摄影师都是不一样的，我今天就和大家说一下最简单的方法，这个引导的思路也有很多摄影师都提到过。可能你们都听腻了，我管这类方法称为<strong>《代入法》</strong>。</p>
<p>有些同学一听这个名字就能猜到个七七八八，有些同学听到这个名词的时候一脸懵逼。我举个例子，很多同学都关心的，怎么把女孩拍得好看拍得自然。我觉得当你以男朋友的视角去代入自己的角色，那时想到的画面都不会很做作，尝试脑补女孩子和男朋友互动的画面感，然后去做引导多数都会比较自然。</p>
<p><img src="https://pic1.zhimg.com/v2-86306b8ffa8d7a6ca4d23f13c114d410_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p><img src="https://pic4.zhimg.com/v2-d3c9dfb4326bfcfdf3ba868b9d47c10f_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p><img src="https://pic3.zhimg.com/v2-f41d6a3d8c2d0b29d8bd21bab7b66592_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p><img src="https://pic4.zhimg.com/v2-4c00007666f61d07cb2637cad08324df_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，来自我的广州面授摄影教学课程</p>
<p>我比较喜欢拍外景的环境人像，觉得那样会有更多的元素可以互动，这套照片是我在给报名面授课程的同学们，上课时所拍摄的。那次也是第一次尝试室内生活感的主题，我当时设计主题时的思路就是想拍那种假日和女朋友腻在家里的感觉，在拍摄之前就事先通过民宿的照片，观看到场地的情况，<strong>脑补了很多情侣之间可能会发生的场景</strong>。</p>
<p>例如周末赖床，男朋友给女朋友做早餐，女朋友在衣柜中淘气的画面等，虽然不像严谨的商业摄影那种会写成ppt的格式，但<strong>每个场景也都是自己脑补带入过的</strong>。只有这样，你到了拍摄场地，才能用语言把你想要的感觉比较清晰的告诉给模特，当语言不能清晰传达的时候，我甚至会直接在那个位置做一个我脑海中动作，我很多面授同学我看到过这一幕都……</p>
<p>我猜，看这篇文章的朋友，肯定有好多，在拍摄面对模特，连自己想要的感觉都用语言说不清楚的吧? 你要想一下，<strong>你自己都说不出来的东西怎么指望模特可以很好的理解呢</strong></p>
<p><img src="https://pic1.zhimg.com/v2-2288251b24c93aff73d5346c1bf76408_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于香港</p>
<p>这张照片在拍摄的时候，我很简单的和小青说: 闭上眼睛，感觉阳光照在脸上很舒服的感觉。其实很多的时候，你脑中有了画面感，再用语言表达，就是一件很简单的事情了。</p>
<p><img src="https://pic1.zhimg.com/v2-336f690b0ae39d568a7c5eedf77c0d5c_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于斯里兰卡</p>
<p>这张照片，是我和朋友一起在斯里兰卡旅行的时候拍摄的，当时是暴风雨的前夕，乌云就是那么恐怖的，其实当时的引导很简单，我当时告诉楠楠：你感觉远方的云在和你说话，你把手放在耳边闭上眼睛在安静的听他和你说话。实际上当时乌云密布老恐怖了……你明白自己想要的画面，就可以做出轻松的引导。</p>
<p><img src="https://pic2.zhimg.com/v2-e6283ef36ab4884c9ad17f94fa2e4a15_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于大理</p>
<p>这是我帮朋友在云南大理拍摄的全家福，引导的时候，我和圆圆（孩子的妈妈）说，你和女儿商量一句话，然后你们一起在老公的耳边用手挡住感觉要说悄悄话，当时母女俩说的好像是：爸爸是大坏蛋。然后老公很自然地就笑了，<strong>因为预估到会有很多真实感的画面，所以这张照片拍摄的时候，我是开连拍模式拍摄的</strong>。</p>
<p><img src="https://pic1.zhimg.com/v2-03a838da35a3bdbace9e4b8ba4f50154_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于大理</p>
<p>这张在拍摄的时候，我让他们夫妻俩紧紧的亲孩子的脸颊，小宝贝的脸肉嘟嘟的被爸爸妈妈的嘴挤住，一笑自然就是这样的小表情了。</p>
<p>另外作为一位也是从萌新小白走过来的摄影师说句心里话，<strong>你闷头在家里就算是看过1万位顶级大咖的经验分享，都不如自己去认真的策划拍个10场</strong>，别看我和你说的好像很简单 ，你也感觉是理解了，但是自己上手去做也还是需要很多临场经验的，所以，别懒别仅仅是看纸上谈兵，动起来多去实现你心中的想法，引导的经验都是这样越来越丰富的。</p>
<h2 id="3-天气"><a href="#3-天气" class="headerlink" title="3. 天气"></a><strong>3. 天气</strong></h2><p>如何在各种不同天气情况下，无论光线是否完美，都可以很好的完成拍摄呢？</p>
<p>我到现在好像就只有下雪天没拍过了，面对各种各样的天气我也算是见过世面了，昨天和前天还在济州岛一边拍摄一边被风吹雨打。</p>
<p>我们一步一步来说，首先是阳光晴好的日子，一般在日照正常的地区，如果拍摄的时间你可以控制，我比较建议上午选择10点30-11点之前的时间进行室外部分的拍摄，下午选择三点半左右到日落结束的时间，因为<strong>这些时间段的阳光没有那么强烈</strong>，相机的宽容度你前期控制一下都没有太大问题的。</p>
<p>晴天的日子室内就不必说了，都不会有太大的影响，但是如果你是想玩光影创意的话，例如这样：</p>
<p><img src="https://pic4.zhimg.com/v2-fa4c546c8023df7f71ea65422b0c57f3_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于深圳</p>
<p><img src="https://pic3.zhimg.com/v2-c5b7a87b3eba8635559e9f90651de69e_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于深圳</p>
<p>这类的室内光影创意就比较建议参考刚才所说的室外拍摄时间段了，也是因为光线会比较好控制。</p>
<p>然后我们说说<strong>阴天</strong>的时候，阴天的时候，我的建议是多找顺光的位置去进行拍摄，虽然阴天没有直射光，但是你找到顺光的位置面部的光线质感应该也都不会很差，例如这几张照片我就是狂风暴雨前后拍摄的。</p>
<p><img src="https://pic4.zhimg.com/v2-cf139d2453fbe1d42efc103416f9ebaf_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于我的香港摄影面授课程</p>
<p><img src="https://pic2.zhimg.com/v2-c0e2a470097f32a76c6104565f3a5385_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L ，拍摄于我的香港摄影面授课程</p>
<p>大家可以看到，天空阴的云都完全没有层次了，面部的光感还是可以拍到和打了闪光灯一样的效果，虽然有些许的后期辅助，但是前期的拍摄至关重要，<strong>这就是在阴天顺光拍摄的一个思路</strong>，希望对大家有些许的帮助。</p>
<p>另外关于白平衡，我都是<strong>自动白平衡</strong>的，现在相机的电子化程度我觉得白平衡是可以信任的，我自己使用的是一台佳能5D4相机。就算是自动白平衡有些许的偏差，我们在LR里面都是可以很轻松的去做白平衡统一。</p>
<h2 id="4-策划思路"><a href="#4-策划思路" class="headerlink" title="4. 策划思路"></a><strong>4. 策划思路</strong></h2><p>下面我们说一下：关于一次人像拍摄的策划思路。这个问题我用之前拍摄的一套作品作为案例，<strong>真实的还原一下我当时策划的情况</strong>。这样分析案例，应该比生硬地和大家说道理效果会更好。</p>
<p><img src="https://pic4.zhimg.com/v2-88f39d4aebcd212e765d8b8329db5527_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L</p>
<p>就是这组照片，听课的同学应该有很多都会去图虫看片的吧，这组在图虫挺受欢迎的，之前报名京东的摄影比赛，还得了最受欢迎作品奖，最受欢迎作品完全是看网友人气来评选的。</p>
<p>我在拍摄的初期是在手机浏览民宿的时候看到了一家位于深圳很有感觉的场地，当时看到的场景是这样的：</p>
<p><img src="https://pic2.zhimg.com/v2-41831df41c26f9b93570e7154849c815_b.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-24761009ccaf3d0f978adfc268021578_b.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-d8cdc211b7c01d6324d3e98eb56c40ec_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-28fa4d3bf39e06c5e007912570b42723_b.jpg" alt="img"></p>
<p>那段时间广州的天气如果没有空调真的是痛不欲生，所以我对室内的拍摄特别的感兴趣。看到这么干净的场景，脑子里立刻就有了这样的色彩组合。</p>
<p><img src="https://pic1.zhimg.com/v2-ce6386cf00619092ff0e6fd805518d4c_b.jpg" alt="img"></p>
<p>我可能是因为有了一些拍摄的经验，所以面对这类很干净的拍摄场地很快就可以找到服装和环境色搭配的感觉，如果对这类搭配你们开始找不到感觉的时候，<strong>可以尝试网上找一些配色表</strong>，把环境色往里面套用一下。</p>
<p><img src="https://pic1.zhimg.com/v2-5efabd3e62a884dbc88c72384876d64c_b.jpg" alt="img"></p>
<p>色彩都是有自己的语言的，另外什么颜色搭配在一起也都是有讲究的。刚开始对于没有经验的萌新来说，<strong>巧用配色表是比较有效率有质量的配色解决办法</strong>。我是在自己定下了照片的色彩配比以后购买了一件蓝色的男士衬衣，出片效果来看这样的男朋友款式衬衣效果还蛮不错的。</p>
<p>拍摄的前期准备都到位了，在拍摄当天我也是像前面和同学们说的那样，有代入感地去和模特在拍摄中沟通。这位朋友叫妙妙，我在拍摄之前和妙妙沟通说想拍一套一个女孩周末自己在家，那种没有肉欲的清冷私房，其实拍摄的时候妙妙上下都有穿打底的，但是因为角度控制到位，基本出片的感觉传达到了，基本是这样的：</p>
<p><img src="https://pic4.zhimg.com/v2-ba9e88e0f42c485fde00666ab2b3419f_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L 拍摄于深圳</p>
<p><img src="https://pic3.zhimg.com/v2-19e34862855e03bec10dbe86ffc3fca2_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L 拍摄于深圳</p>
<p><img src="https://pic4.zhimg.com/v2-7a3a9620aad6c2859c2632f3bb0d8037_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L 拍摄于深圳</p>
<p><img src="https://pic3.zhimg.com/v2-5fb3fad81b506037a590cf5e3d1b842e_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L 拍摄于深圳</p>
<p>顺便一提中间还有小插曲，我们拍着拍着老板的狗来巡场了。被我顺手抓来入境，然后效果还不错，所以拍摄的时候也要多随机应变。说道这里，大家应该明白了，一次有质量的拍摄：踩点，适合场景的选择，服装和场景色彩的搭配，以及模特的引导都是同样重要的。</p>
<h2 id="5-皮肤如何后期"><a href="#5-皮肤如何后期" class="headerlink" title="5. 皮肤如何后期"></a><strong>5.</strong> <strong>皮肤如何后期</strong></h2><p>关于通透的问题我给大家看一张原片：</p>
<p><img src="https://pic3.zhimg.com/v2-2dd8f9327c6eeabc99c71bbb78f677f2_b.jpg" alt="img"></p>
<p>佳能5D4+24 70 2.8L 拍摄于我在广州的摄影面授课程</p>
<p>这是一张只有曝光度调整的原片，我是想和大家说一个道理。很多同学有误区，觉得照片舒服都是靠后期的。<strong>实际前期的拍摄非常的重要</strong>，后期是实现前期想法的辅助工具，关于皮肤处理的部分这个真的就不是一小时能说完的问题了。</p>
<p>（悄悄告诉大家，<strong>我和AIRPHOTO最近合作了一期人像修肤的课程</strong>，对这块感兴趣的小伙伴，可以查看<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s/ctrX1btn0hyAlxJH8l0taA">这么好的皮肤质感，为什么不是我修的？！</a>报名哦）</p>
<p><img src="https://pic4.zhimg.com/v2-2abd7b92c13de7e924ca21c185bec6cf_b.jpg" alt="img"></p>
<h2 id="6-如何约漂亮女生"><a href="#6-如何约漂亮女生" class="headerlink" title="6. 如何约漂亮女生"></a><strong>6.</strong> <strong>如何约漂亮女生</strong></h2><p>其实我想说，我刚才以上说的几个问题，分享的经验思路。你全都很好地做到了，就可以轻松的靠实力约到好看的妹子当模特了。这个是最实在的大实话，其他的撩妹技巧都是浮云。</p>
<p><img src="https://pic2.zhimg.com/v2-75e7224167ed9416b3dd39b659a9b071_b.jpg" alt="img"></p>
<h3 id="转载自：-https-zhuanlan-zhihu-com-p-30879193"><a href="#转载自：-https-zhuanlan-zhihu-com-p-30879193" class="headerlink" title="转载自： https://zhuanlan.zhihu.com/p/30879193"></a>转载自： <a href="https://zhuanlan.zhihu.com/p/30879193">https://zhuanlan.zhihu.com/p/30879193</a></h3>]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>人像</tag>
      </tags>
  </entry>
  <entry>
    <title>AI斗地主</title>
    <url>/2021/07/20/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%9C%E8%A5%BF/AI%E6%96%97%E5%9C%B0%E4%B8%BB/</url>
    <content><![CDATA[<h2 id="DouZero分析"><a href="#DouZero分析" class="headerlink" title="DouZero分析"></a>DouZero分析</h2><h3 id="1-DouZero介绍"><a href="#1-DouZero介绍" class="headerlink" title="1.DouZero介绍"></a>1.DouZero介绍</h3><p>DouZero项目地址：<a href="https://github.com/kwai/DouZero">https://github.com/kwai/DouZero</a></p>
<p>在线Demo地址：<a href="https://www.douzero.org/">https://www.douzero.org/</a></p>
<p>原理我就不过多说明，有兴趣的可以查看论文：<a href="https://arxiv.org/abs/2106.06135">https://arxiv.org/abs/2106.06135</a></p>
<p>运行程序，评估胜率只需三步：进入项目目录，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt    <span class="comment"># 安装依赖</span></span><br><span class="line">python3 generate_eval_data.py        <span class="comment"># 生成评估用的数据</span></span><br><span class="line">python3 evaluate.py                    <span class="comment"># 开始评估</span></span><br></pre></td></tr></table></figure>

<p>运行结果是以胜率的形式展现。<br>关于如何训练以及更多参数设置，请查看DouZero项目的说明文档。</p>
<p>当然现在这样对实际应用是没有直接帮助的，所以要改造一下，利用训练好的AI来帮我们出牌。</p>
<h3 id="2-DouZero源码分析"><a href="#2-DouZero源码分析" class="headerlink" title="2.DouZero源码分析"></a>2.DouZero源码分析</h3><p>项目结构十分清晰，<code>douzero</code>目录包含主要代码文件，<code>baselines</code>目录放置预训练模型。根目录下的 <code>evaluate.py</code>为入口，拿到参数后传递到 <code>douzero/evaluation/simulation.py</code>中的 <code>evaluate()</code>函数，再将数据分配给多个进程调用 <code>mp_simulate()</code>函数。</p>
<p><img src="https://tqraf.cn/images/image-210713-1.png" alt="项目结构"></p>
<center>项目结构</center>

<p><code>mp_simulate()</code>函数中，players为三个生成的AI，代表斗地主中的三个角色。<code>GameEnv()</code>类表示游戏环境，控制一局游戏流程的进行与结束。</p>
<p><img src="https://tqraf.cn/images/image-210713-2.png" alt="mp_simulate()函数"></p>
<center>mp_simulate()函数</center>

<p>看到这里，整个项目就清晰了，可以着手按照需求定制AI了。</p>
<h2 id="DouZero定制"><a href="#DouZero定制" class="headerlink" title="DouZero定制"></a>DouZero定制</h2><ul>
<li><p>首先，三个AI互斗肯定是不可行的，我们只需要一个，并且代表了玩家的角色。只要给这个AI输入开局时我的手牌和三张底牌，并且告诉它谁是地主，再输入每轮中其他两人的出牌，那么AI就能够给出最优出牌决策。</p>
</li>
<li><p>对于生成AI，可以控制只生成玩家角色对应的AI。开局时获取玩家的位置(<strong>地主上家、地主、地主下家</strong>），并用 <code>0, 1, 2</code>分别表示。</p>
</li>
<li><p>对于获取手牌等信息，<code>DouZero</code>项目中有对扑克牌进行转换。注意到在 <code>DouZero</code>与 <code>rlcard-showdown</code>两个项目中，这种对应关系有些许差异，这是因为将 <code>10</code>用 <code>T</code>来代替就可以将扑克牌用一串字符串来表示，便于参数传递。因此本项目也采取这种做法。</p>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DouZero</span></span><br><span class="line">EnvCard2RealCard = &#123;<span class="number">3</span>: <span class="string">&#x27;3&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;4&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;5&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;6&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">                  <span class="number">8</span>: <span class="string">&#x27;8&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;9&#x27;</span>, <span class="number">10</span>: <span class="string">&#x27;10&#x27;</span>, <span class="number">11</span>: <span class="string">&#x27;J&#x27;</span>, <span class="number">12</span>: <span class="string">&#x27;Q&#x27;</span>,</span><br><span class="line">                  <span class="number">13</span>: <span class="string">&#x27;K&#x27;</span>, <span class="number">14</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">17</span>: <span class="string">&#x27;2&#x27;</span>, <span class="number">20</span>: <span class="string">&#x27;X&#x27;</span>, <span class="number">30</span>: <span class="string">&#x27;D&#x27;</span>&#125;</span><br><span class="line">RealCard2EnvCard = &#123;<span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                  <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;10&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">                  <span class="string">&#x27;K&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="comment"># rlcard-showdown</span></span><br><span class="line">EnvCard2RealCard = &#123;<span class="number">3</span>: <span class="string">&#x27;3&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;4&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;5&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;6&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">                  <span class="number">8</span>: <span class="string">&#x27;8&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;9&#x27;</span>, <span class="number">10</span>: <span class="string">&#x27;T&#x27;</span>, <span class="number">11</span>: <span class="string">&#x27;J&#x27;</span>, <span class="number">12</span>: <span class="string">&#x27;Q&#x27;</span>,</span><br><span class="line">                  <span class="number">13</span>: <span class="string">&#x27;K&#x27;</span>, <span class="number">14</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">17</span>: <span class="string">&#x27;2&#x27;</span>, <span class="number">20</span>: <span class="string">&#x27;X&#x27;</span>, <span class="number">30</span>: <span class="string">&#x27;D&#x27;</span>&#125;</span><br><span class="line">RealCard2EnvCard = &#123;<span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                  <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;T&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">                  <span class="string">&#x27;K&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于预测胜率，<code>DouZero</code>项目中并未给出，但是在 <code>rlcard-showdown</code>中能看到该参数，由 <code>deep.py</code>文件中 <code>DeepAgent()</code>类的 <code>act()</code>函数计算得到。</p>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_action_confidence = y_pred[best_action_index]</span><br></pre></td></tr></table></figure></li>
<li><p>感谢Couwisdet指点，变量 <code>y_pred</code>是预测的所有合法动作的Q值，取其中最大的一个对应的策略即为最优策略。对于 <code>WP</code>模型，取值在 <code>[-1, 1]</code>，可以按比例换算成胜率，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win_rates = &#123;&#125;</span><br><span class="line">win_rate = max(best_action_confidence, -1)</span><br><span class="line">win_rate = min(win_rate, 1)</span><br><span class="line">win_rate = str(round(float((win_rate + 1) / 2), 4))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制台版本"><a href="#控制台版本" class="headerlink" title="控制台版本"></a>控制台版本</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><ul>
<li>这个版本仅仅通过<strong>控制台</strong>进行交互。</li>
</ul>
<p><img src="https://tqraf.cn/images/image-210713-3.png" alt="控制台版本"></p>
<center>控制台版本</center>

<ul>
<li>开局的时候玩家要把自己的手牌，地主的位置，三张底牌手动输入进去。手牌输入按照 <code>333456789TJQKA2XD</code>的形式，然后输入玩家的角色：<code>0-地主上家, 1-地主, 2-地主下家</code>，最后输入三张底牌，例如 <code>2XD</code>。</li>
<li>然后就开始轮流出牌，在其它两个人出牌后都需要将对应的牌输入，用于AI决策，这样在轮到玩家出牌时，AI就能告知最优策略。</li>
<li>不出的话，直接 <code>Enter</code>即可，会返回空列表。同理，当AI返回空列表时表示不出。</li>
<li>这么做的优点就是，逻辑简单，并且工作量少哇。主要是想第一时间测试AI在实战斗地主中的实力。</li>
<li>缺点很明显，十分拼手速，并且没有撤销机制与输入检测，如果着急输错了，那么程序就会崩溃。</li>
</ul>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><ul>
<li>去除了不必要的文件以及参数，根目录只保留 <code>start.py</code>用于启动。</li>
<li><code>evaluate()</code>函数要求输入玩家手牌、玩家角色、三张底牌。由于原先评估代码中太多处涉及对其他角色手牌的操作如删除和检测，为避免大量改动原项目代码，需要为其他两个角色分配手牌。</li>
<li>这里就将整幅牌减去玩家手牌，再按角色分配给它们。为避免其他玩家出牌时，在其手牌中找不到该牌，将<strong>在其他玩家手牌中删除刚出的牌</strong>改为<strong>在其他玩家手牌中删除与刚出的牌等量的牌</strong>。这么做的依据是：AI决策时只需要考虑其他角色手牌数量而不需要知道具体是什么牌。</li>
<li>创建AI时根据玩家角色来创建，并且在 <code>env.step()</code>中，调用 <code>act()</code>函数获取AI决策前判断一下当前是否为玩家出牌，是则通过AI决策，否则由玩家输入。</li>
<li>当任意角色手牌数量为0时则代表游戏结束。</li>
</ul>
<blockquote>
<p>俗话说得好，一个成熟的AI，是应该能够自己看牌出牌的。于是我又改出了pyqt5版本，实现部分<strong>自动化操作</strong>。</p>
</blockquote>
<h2 id="pyqt5版本"><a href="#pyqt5版本" class="headerlink" title="pyqt5版本"></a>pyqt5版本</h2><h3 id="1-用法-1"><a href="#1-用法-1" class="headerlink" title="1.用法"></a>1.用法</h3><ul>
<li>打开欢乐斗地主，需要<strong>窗口模式下最大化</strong>运行，并且要求屏幕分辨率 <code>1920x1080</code>，程序窗口需要移至<strong>右下角</strong>，不能遮挡<strong>手牌、地主标志、底牌、历史出牌</strong></li>
</ul>
<p><img src="https://tqraf.cn/images/image-210713-4.png" alt="pyqt5版本"></p>
<center>pyqt5版本</center>

<ul>
<li>在抢地主结束后，手牌出现、底牌出现、地主角色确认，点击<strong>开始</strong>，耗时几秒完成扑克牌的识别。</li>
<li>窗口内显示识别结果，地主角色使用淡红色标出。识别完成自动开始记录出牌。</li>
<li>观察AI建议的出牌，在游戏中手动选择并打出。游戏结束后会弹出对话框提示输赢。</li>
<li>识别错误或无反应导致错过出牌，可通过<strong>结束</strong>按钮停止本局。至于游戏，就自己手动打完吧。</li>
</ul>
<h3 id="2-分析-1"><a href="#2-分析-1" class="headerlink" title="2.分析"></a>2.分析</h3><ul>
<li>利用 <code>pyqt5</code>设计一个简单的窗体用于展示出牌信息</li>
</ul>
<p><img src="https://tqraf.cn/images/image-210713-5.png" alt="主窗口"></p>
<center>主窗口</center>

<ul>
<li>使用 <code>pyautogui</code>来实现自动化。借鉴了<a href="https://github.com/ZDZX-T/cardRecorder">cardRecorder</a>项目的部分代码以及模板图片，用于识别扑克牌。</li>
</ul>
<p><img src="https://tqraf.cn/images/image-210713-6.png" alt="图片模板"></p>
<center>图片模板</center>

<ul>
<li>通过 <code>pyautogui.locateAll()</code>函数将所有扑克牌的模板图片与屏幕特定区域的截图进行对比，获取手牌、底牌与出牌。</li>
<li>由于出牌区域显示的牌较小，因此使用一大一小两套模板。而底牌则更小，通过 <code>resize()</code>函数将截图区域放大，在进行模板比对。</li>
<li><code>pyautogui.locateOnScreen</code>用于白块检测与“不出”检测，“地主”检测，用来自动识别出牌流程。这里仍有一点Bug，例如王炸时出牌特效时间较长，有一定几率导致只能识别出一个王。但是缩短等待时间又会导致两人连续“不出”时无法自动切换到下一个人出牌的状态。</li>
<li>另外，由于像素级操作过于局限，并且识别过程容易出错，有小几率Bug，因此放弃完全自动化的想法，即通过 <code>pyautogui</code>来点击屏幕自动出牌。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至少现在，这个AI可以辅助我们出牌了，虽然AI的思路可能跟我们完全不一样。</li>
<li>要注意到，斗地主是个<strong>运气成分很强</strong>的游戏，牌好的时候，闭着眼睛打也能赢。牌烂的时候，高手也救不了（例如被“春天”）。所以只有在自己的牌不好也不烂的时候，AI的优势才能被明显体现出来。</li>
<li>综合来看，在发完牌后，自己没有把握打赢又不至于直接认输的情况下，用AI辅助是不错的选择。毕竟，它天生自带记牌器，能够合理配合，做农民的时候是个不错的队友。</li>
<li>github项目地址：<a href="https://github.com/tianqiraf/DouZero_For_HappyDouDiZhu">DouZero_For_HappyDouDiZhu</a></li>
<li>演示视频链接：<a href="https://www.zhihu.com/zvideo/1398424460945444864">知乎视频</a></li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul>
<li>有时候程序中自己的牌堆显示会与实际手牌不同</li>
<li>使用AI的胜率一般，不知道大家的体验如何</li>
</ul>
<h3 id="转载自：使用DouZero玩欢乐斗地主"><a href="#转载自：使用DouZero玩欢乐斗地主" class="headerlink" title="转载自：使用DouZero玩欢乐斗地主"></a>转载自：<a href="https://tqraf.cn/2021/07/DouZero-For-HappyDouDiZhu.html">使用DouZero玩欢乐斗地主</a></h3>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>InterestingCode</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币和区块链</title>
    <url>/2021/05/24/%E7%A7%91%E6%99%AE/%E6%AF%94%E7%89%B9%E5%B8%81%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h3 id="一：比特币：数字货币"><a href="#一：比特币：数字货币" class="headerlink" title="一：比特币：数字货币"></a>一：比特币：数字货币</h3><p><img src="https://pic.imgdb.cn/item/607a6b148322e6675c121da4.png" alt="image-123"></p>
<ul>
<li>2008年11月1日 中本聪《白皮书》</li>
<li>去中心化的电子<strong>记账</strong>系统<ul>
<li>现在的中心化是谁的：银行，谁谁谁用了多少钱，还剩多少钱*</li>
<li>很多条交易记录进行打包连接成一个区块，区块再连接起来，成为区块链</li>
<li>三个问题<ul>
<li>以谁为准</li>
<li>为何记账</li>
<li>如何防伪</li>
</ul>
</li>
<li>记账奖励<ul>
<li>手续费</li>
<li>打包奖励<ul>
<li>每10分钟打一个包，最开始会奖励打包者50个比特币，过了4年之后奖励25个比特币……</li>
<li>一共有多少个比特币<ul>
<li>50x6x24x365x4x(1+1/2+1/2*1/2+….)=2100万</li>
</ul>
</li>
</ul>
</li>
<li>以谁为准<ul>
<li>工作量证明（挖矿）：每一个参与的用户都要做一个很难的数学题，这个数学题没有一个人能够通过脑子把它算出来，我们必须一个一个去试，只有你把它尝试出来了才能获得这个奖励，这个过程称之为挖矿。</li>
<li>挖矿原理<ul>
<li>哈希函数：<ul>
<li>我们能够把一个字符串通过一定的运算转换为摘要的形式</li>
<li>正着算容易反着算难</li>
<li>sha256（美国国家安全局发明的一种算法）<ul>
<li>比如输入“Apple”输出一个256位的二进制数</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>字符串：前块头部+账单信息+时间戳+随机数<ul>
<li>改变这个随机数不断去试</li>
</ul>
</li>
<li>hash=sha256（sha256（字符串））</li>
<li>前n位必须为0</li>
<li>如果你算对了，你就有资格去打包，就可以把你的哈希值作为新块的头部打一个包，再把这个包接到区块链的后面去。（每个块有头部+信息）</li>
</ul>
</li>
<li>难度n的确定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考资料：<a href="https://www.youtube.com/watch?v=g_fSistU3MQ">比特币和区块链啥原理？矿机挖矿咋回事？李永乐老师讲比特币(1)</a></p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>源代码包”和“二进制包”的区别</title>
    <url>/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="“源代码包”和“二进制包”的区别"><a href="#“源代码包”和“二进制包”的区别" class="headerlink" title="“源代码包”和“二进制包”的区别"></a><a href="https://blog.csdn.net/Tomstrong_369/article/details/51741012">“源代码包”和“二进制包”的区别</a></h1><p>源代码方式和二进制包是软件包的两种形式。二进制包里面包括了已经经过编译，可以马上运行的程 序。你只需要下载和解包（安装）它们以后，就马上可以使用。源代码包里面包括了程序原始的程序代码，需要在你的计算机上进行编译以后才可以产生可以运行程 序,所以从源代码安装的时间会比较长。</p>
<p>source code 是程序員寫的碼， binary code 是機器跑的碼。 source code 得經過 compile 才能成為 binary code 。 </p>
<p>RPM 有分兩種：binary rpm 跟 source rpm 。<br>前者是編好的 binary ，安裝就可用。<br>後者是還沒編好的 source ，需 rebuild 之後才能安裝。</p>
<p>rpm格式很好区分，二进制格式的包名字很长，都带有版本号、适应平台、适应的硬件类型等，而源码格式仅仅就是一个版本号的tar包。<br>mysql-5.0.45.tar.gz 是 源码包    像这样的 mysql-5.0.45-linux-x86_64-glibc23.tar.gz   是二进制包</p>
<p>如果你用过压缩工具就会明白，压缩包未必就是软件，它也可能是备份的许多图片，也可能是打包在一起的普通资料，要分辨它到底是什么最好的办法就是查看包里的文件清单，使用命令tar ztvf *. 或者tar ytvf *.bz2</p>
<p>源代码包里的文件往往会含有种种源代码文件，头文件*.h、c代码源文件*.c、C++代码源文件*.cc/*.cpp等；而二进制包里的文件则会有可执行文件（与软件同名的往往是主执行文件），标志是其所在路径含有名为bin的目录（仅有少数例外）</p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
  </entry>
  <entry>
    <title>移动通讯技术</title>
    <url>/2021/05/24/%E7%A7%91%E6%99%AE/%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="移动通讯技术"><a href="#移动通讯技术" class="headerlink" title="移动通讯技术"></a><a href="https://www.cnblogs.com/SssuperBear/p/14670473.html">移动通讯技术</a></h3><p><img src="https://img.imgdb.cn/item/607a6b0c8322e6675c1209ff.png" alt="image-20210107123834018"></p>
<h4 id="一：移动通讯技术"><a href="#一：移动通讯技术" class="headerlink" title="一：移动通讯技术"></a>一：移动通讯技术</h4><ul>
<li><p>1G：移动蜂窝技术 </p>
<ul>
<li>传输的是模拟信号，只能传输语音不能传输文字，保密性很差，而且通话质量也不好</li>
</ul>
<p><img src="https://img.imgdb.cn/item/607a6b0c8322e6675c120a06.png" alt="image-20210107124105969"></p>
</li>
<li><p>2G：数字信号</p>
<ul>
<li>一段语音，进行采样，转换为数字，再转换为二进制码传输</li>
<li>这样既能传输语音也能传输文字还能进行加密</li>
</ul>
</li>
<li><p>3G：CDMA（码分多址）</p>
</li>
<li><p>4G：OFDMA（正交频分多址）</p>
<p><img src="https://img.imgdb.cn/item/607a6b0c8322e6675c120a0f.png" alt="image-20210107124612998"></p>
<ul>
<li>他可以在同一个频段内传输很多个信号。信号彼此是正交的，一个信号最强的时候其他信号为0。这样一来，虽然他们都在一个频段内却不会彼此干扰。</li>
</ul>
</li>
</ul>
<h4 id="二：5G-5G毫米波"><a href="#二：5G-5G毫米波" class="headerlink" title="二：5G/5G毫米波"></a>二：5G/5G毫米波</h4><ul>
<li>高速率<ul>
<li>4G 5G速率对比<ul>
<li>4G：100Mbps（大约是10M字节每秒）</li>
<li>5G：2Gbps</li>
</ul>
</li>
<li>香农公式  C=Wlog2（1+S/N）<ul>
<li>C：速率极限（再怎么编码都超不过这个速率）</li>
<li>W：频带宽度（1Ghz-2Ghz的频率那么频宽就有1Ghz）</li>
<li>S：信号功率</li>
<li>N：噪声功率</li>
</ul>
</li>
<li>4G频段<ul>
<li>中国移动885M-909Mhz（24Mhz带宽） 930M-954Mhz（24Mhz带宽）</li>
</ul>
</li>
<li>5G频段<ul>
<li>6Ghz以下（sub6 5G）<ul>
<li>大概是5倍的4G</li>
<li>中国移动拿到两个5G频段<ul>
<li>2515M-2575M（160M带宽）</li>
<li>4800M-4900M（100M带宽）</li>
</ul>
</li>
</ul>
</li>
<li>24Ghz以上（毫米波5G）（24-100Ghz）<ul>
<li>大概是4倍的sub6 5G</li>
</ul>
</li>
<li>VR眼镜带的时间长了会头晕？<ul>
<li>视频不够高清</li>
<li>延迟比较严重</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>低延迟<ul>
<li>4G：10ms-100ms</li>
<li>5G-sub6：1ms</li>
<li>5G-毫米波：0.1ms</li>
<li>工业、远程医疗</li>
</ul>
</li>
<li>大容量<ul>
<li>4G：2000个/平方公里</li>
<li>5G：100万个/平方公里</li>
<li>万物互联</li>
</ul>
</li>
</ul>
<h3 id="三毫米波5G挑战"><a href="#三毫米波5G挑战" class="headerlink" title="三毫米波5G挑战"></a>三毫米波5G挑战</h3><ul>
<li><p>频率高、衰减快、覆盖范围小</p>
</li>
<li><p>波长短、衍射差（播不能绕过障碍物）、易于遮挡</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>波束赋形</p>
<ul>
<li>好几根天线，彼此之间相位不同，发生干涉，结果导致向一个方向发射比较强的电磁波</li>
</ul>
<p><img src="https://img.imgdb.cn/item/607a6b0c8322e6675c120a18.png" alt="image-20210107130727862"></p>
</li>
<li><p>波束追踪</p>
<p><img src="https://img.imgdb.cn/item/607a6b148322e6675c121d9d.png" alt="image-20210107130937454"></p>
<ul>
<li>走哪跟到哪</li>
</ul>
</li>
<li><p>波束反射</p>
<ul>
<li>通过墙的反射</li>
</ul>
</li>
<li><p>波束切换</p>
<ul>
<li>手机在多个基站之间进行切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考文献：<a href="https://www.youtube.com/watch?v=VdSFah46d7Y">5G到底是什么？它能成为创造未来的新科技吗？</a></p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>ADF检验</title>
    <url>/2021/12/26/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/ADF%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="ADF检验"><a href="#ADF检验" class="headerlink" title="ADF检验"></a>ADF检验</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在使用很多时间序列模型的时候，如ARMA、ARIMA，都会要求时间序列是平稳的，所以一般在研究一段时间序列的时候，第一步都需要进行平稳性检验，除了用肉眼检测的方法，另外比较常用的严格的统计检验方法就是<strong>ADF检验</strong>，也叫做<strong>单位根检验</strong>。</p>
<p>ADF检验全程是Augmented Dickey-Fuller test，顾名思义，ADF是Dickey-Fuller检验的增广形式。DF检验只能应用于一阶情况，当序列存在高阶的滞后相关时，可以使用ADF检验，所以说ADF是对DF检验的扩展。</p>
<h2 id="单位根（unit-root）"><a href="#单位根（unit-root）" class="headerlink" title="单位根（unit root）"></a>单位根（unit root）</h2><p>在做ADF检验，也就是单位根检验时，需要先明白一个概念，也就是要检验的对象——单位根。</p>
<p>在一个自回归的过程中：</p>
<p>$$<br>y _ { t } = b y _ { t - 1 } + a + \epsilon _ { t }<br>$$</p>
<p>，如果滞后项系数b为1，就称为单位根。当单位根存在时，自变量和因变量之间的关系具有欺骗性，因为残差序列的任何误差都不会随着样本量（即时期数）增大而衰退，也就是说模型中的残差的影响是永久的。这种回归又称为伪回归。如果单位根存在，这个过程就是一个随机漫步（random walk）。</p>
<h2 id="ADF检验的原理"><a href="#ADF检验的原理" class="headerlink" title="ADF检验的原理"></a>ADF检验的原理</h2><p>ADF检验就是判断序列是否存在单位根：<strong>如果序列平稳，就不存在单位根；否则，就会存在单位根。</strong></p>
<p>所以，ADF检验的H0假设就是存在单位根，如果得到的显著性检验统计量小于三个置信度（10%， 5%， 1%），则对应有（90%， 95%， 99%）的把握来拒绝假设。</p>
<h2 id="ADF检验的python实现"><a href="#ADF检验的python实现" class="headerlink" title="ADF检验的python实现"></a>ADF检验的python实现</h2><p>adfuller函数的参数意义分别是：</p>
<ol>
<li>x：一维的数据序列。</li>
<li>maxlag：最大滞后数目。</li>
<li>regression：回归中的包含项（c：只有常数项，默认；ct：常数项和趋势项；ctt：常数项，线性二次项；nc：没有常数项和趋势项）</li>
<li>autolag：自动选择滞后数目（AIC：赤池信息准则，默认；BIC：贝叶斯信息准则；t-stat：基于maxlag，从maxlag开始并删除一个滞后直到最后一个滞后长度基于 t-statistic 显著性小于5%为止；None：使用maxlag指定的滞后）</li>
<li>store：True False，默认。</li>
<li>regresults：True 完整的回归结果将返回。False，默认。</li>
</ol>
<p>返回值意义为：</p>
<ol>
<li>adf：Test statistic，T检验，假设检验值。</li>
<li>pvalue：假设检验结果。</li>
<li>usedlag：使用的滞后阶数。</li>
<li>nobs：用于ADF回归和计算临界值用到的观测值数目。</li>
<li>icbest：如果autolag不是None的话，返回最大的信息准则值。</li>
<li>resstore：将结果合并为一个dummy</li>
</ol>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adfuller</span>(<span class="params">x, maxlag=<span class="literal">None</span>, regression=<span class="string">&quot;c&quot;</span>, autolag=<span class="string">&#x27;AIC&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             store=<span class="literal">False</span>, regresults=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Augmented Dickey-Fuller unit root test</span></span><br><span class="line"><span class="string">    The Augmented Dickey-Fuller test can be used to test for a unit root in a</span></span><br><span class="line"><span class="string">    univariate process in the presence of serial correlation.</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    x : array_like, 1d</span></span><br><span class="line"><span class="string">        data series</span></span><br><span class="line"><span class="string">    maxlag : int</span></span><br><span class="line"><span class="string">        Maximum lag which is included in test, default 12*(nobs/100)^&#123;1/4&#125;</span></span><br><span class="line"><span class="string">    regression : &#123;&#x27;c&#x27;,&#x27;ct&#x27;,&#x27;ctt&#x27;,&#x27;nc&#x27;&#125;</span></span><br><span class="line"><span class="string">        Constant and trend order to include in regression</span></span><br><span class="line"><span class="string">        * &#x27;c&#x27; : constant only (default)</span></span><br><span class="line"><span class="string">        * &#x27;ct&#x27; : constant and trend</span></span><br><span class="line"><span class="string">        * &#x27;ctt&#x27; : constant, and linear and quadratic trend</span></span><br><span class="line"><span class="string">        * &#x27;nc&#x27; : no constant, no trend</span></span><br><span class="line"><span class="string">    autolag : &#123;&#x27;AIC&#x27;, &#x27;BIC&#x27;, &#x27;t-stat&#x27;, None&#125;</span></span><br><span class="line"><span class="string">        * if None, then maxlag lags are used</span></span><br><span class="line"><span class="string">        * if &#x27;AIC&#x27; (default) or &#x27;BIC&#x27;, then the number of lags is chosen</span></span><br><span class="line"><span class="string">          to minimize the corresponding information criterion</span></span><br><span class="line"><span class="string">        * &#x27;t-stat&#x27; based choice of maxlag.  Starts with maxlag and drops a</span></span><br><span class="line"><span class="string">          lag until the t-statistic on the last lag length is significant</span></span><br><span class="line"><span class="string">          using a 5%-sized test</span></span><br><span class="line"><span class="string">    store : bool</span></span><br><span class="line"><span class="string">        If True, then a result instance is returned additionally to</span></span><br><span class="line"><span class="string">        the adf statistic. Default is False</span></span><br><span class="line"><span class="string">    regresults : bool, optional</span></span><br><span class="line"><span class="string">        If True, the full regression results are returned. Default is False</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    adf : float</span></span><br><span class="line"><span class="string">        Test statistic</span></span><br><span class="line"><span class="string">    pvalue : float</span></span><br><span class="line"><span class="string">        MacKinnon&#x27;s approximate p-value based on MacKinnon (1994, 2010)</span></span><br><span class="line"><span class="string">    usedlag : int</span></span><br><span class="line"><span class="string">        Number of lags used</span></span><br><span class="line"><span class="string">    nobs : int</span></span><br><span class="line"><span class="string">        Number of observations used for the ADF regression and calculation of</span></span><br><span class="line"><span class="string">        the critical values</span></span><br><span class="line"><span class="string">    critical values : dict</span></span><br><span class="line"><span class="string">        Critical values for the test statistic at the 1 %, 5 %, and 10 %</span></span><br><span class="line"><span class="string">        levels. Based on MacKinnon (2010)</span></span><br><span class="line"><span class="string">    icbest : float</span></span><br><span class="line"><span class="string">        The maximized information criterion if autolag is not None.</span></span><br><span class="line"><span class="string">    resstore : ResultStore, optional</span></span><br><span class="line"><span class="string">        A dummy class with results attached as attributes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller <span class="keyword">as</span> ADF</span><br><span class="line">adf = ADF(data)</span><br><span class="line"><span class="built_in">print</span>(adf)</span><br><span class="line"></span><br><span class="line">(-<span class="number">0.45153867687808574</span>, <span class="number">0.9011315454402649</span>, <span class="number">1</span>, <span class="number">198</span>, &#123; <span class="string">&#x27;1%&#x27;</span>: -<span class="number">3.4638151713286316</span>, <span class="string">&#x27;5%&#x27;</span>: -<span class="number">2.876250632135043</span>,<span class="string">&#x27;10%&#x27;</span>: -<span class="number">2.574611347821651</span>&#125;, <span class="number">1172.4579344852016</span>)</span><br></pre></td></tr></table></figure>

<p>看到t-statistic的值-0.451要大于10%，所以无法拒绝原假设，另外，p-value的值也很大。</p>
<h3 id="如何确定该序列能否平稳呢？主要看："><a href="#如何确定该序列能否平稳呢？主要看：" class="headerlink" title="如何确定该序列能否平稳呢？主要看："></a>如何确定该序列能否平稳呢？主要看：</h3><p>1、1%、%5、%10不同程度拒绝原假设的统计值和ADF Test result的比较，ADF Test result同时小于1%、5%、10%即说明非常好地拒绝该假设，本数据中，adf结果为-9， 小于三个level的统计值。<br>2、P-value是否非常接近0。</p>
<p>ADF检验的原假设是存在单位根，只要这个统计值是小于1%水平下的数字就可以极显著的拒绝原假设，认为数据平稳。注意，ADF值一般是负的，也有正的，但是它只有小于1%水平下的才能认为是及其显著的拒绝原假设。<br>对于ADF结果在1% 以上 5%以下的结果，也不能说不平稳，关键看检验要求是什么样子的。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://blog.csdn.net/FrankieHello/article/details/86766625?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.nonecase">时间序列分析之ADF检验</a></li>
<li><a href="https://blog.csdn.net/weixin_44342108/article/details/102300595?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&spm=1001.2101.3001.4242.1">时间序列—-ADF检验</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ARIMA</title>
    <url>/2021/12/26/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/ARIMA/</url>
    <content><![CDATA[<h1 id="（差分自回归移动平均）ARIMA"><a href="#（差分自回归移动平均）ARIMA" class="headerlink" title="（差分自回归移动平均）ARIMA"></a>（差分自回归移动平均）ARIMA</h1><h2 id="1-时间序列平稳性"><a href="#1-时间序列平稳性" class="headerlink" title="1. 时间序列平稳性"></a>1. 时间序列平稳性</h2><h3 id="1-1-平稳性"><a href="#1-1-平稳性" class="headerlink" title="1.1 平稳性"></a>1.1 平稳性</h3><p>平稳性就是要求经由样本时间序列锁得到的拟合曲线在未来一段时间内仍能顺着现有的形态惯性地延续下去。平稳性要求序列的均值和方差不发生明显的变化。</p>
<h4 id="严平稳"><a href="#严平稳" class="headerlink" title="严平稳"></a>严平稳</h4><p>严平稳表示的分布不随时间的改变而改变。如白噪声（正态分布），无论怎么取，都是期望为0，方差为1</p>
<h4 id="宽平稳"><a href="#宽平稳" class="headerlink" title="宽平稳"></a>宽平稳</h4><p>期望与相关系数（依赖性）不变。未来某时刻的t的值$Xt$就要依赖于它的过去的信息，所以需要依赖性。这种依赖性不能有明显的变化</p>
<h3 id="1-2-差分法"><a href="#1-2-差分法" class="headerlink" title="1.2 差分法"></a>1.2 差分法</h3><p>使用差分法可以使得数据更平稳，常用的方法就是一阶差分和二阶差分。</p>
<p>时间序列差分值的求解可以直接通过pandas中的diff函数得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 一阶差分</span><br><span class="line">data = data.diff(<span class="number">1</span>)</span><br><span class="line">// 二阶差分</span><br><span class="line">data = data.diff(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-ARIMA模型介绍"><a href="#2-ARIMA模型介绍" class="headerlink" title="2. ARIMA模型介绍"></a>2. ARIMA模型介绍</h2><h3 id="2-1-自回归模型AR"><a href="#2-1-自回归模型AR" class="headerlink" title="2.1 自回归模型AR"></a>2.1 自回归模型AR</h3><p>自回归模型描述当前值与历史值之间的关系，用变量自身的历史数据对自身进行预测。自回归模型必须满足平稳性的要求。</p>
<p>自回归模型首先需要确定一个阶数p，表示用几期的值来预测当前值。p阶自回归模型的公式定义为：<br>$$<br>y _ { t } = \mu + \sum _ { i = 1 } ^ { p } \gamma _ { i } y _ { t - i } + \epsilon _ { t }<br>$$<br>上式中$yt$是当前值，$\mu$是常数项，$p$ 是阶数，$\gamma i$是自相关系数， $\epsilon_t$是误差</p>
<p>自回归模型有很多限制：</p>
<ul>
<li>自回归模型是用自身的数据进行预测</li>
<li>时间序列数据必须具有平稳性</li>
<li>自回归只适用于预测与自身前期相关的现象</li>
</ul>
<h3 id="2-2-移动平均模型MA"><a href="#2-2-移动平均模型MA" class="headerlink" title="2.2 移动平均模型MA"></a>2.2 移动平均模型MA</h3><p>移动平均模型关注的是自回归模型中的误差项的累加，q阶自回归的过程的公式定义如下：<br>$$<br>y _ { t } = \mu + \epsilon _ { t } + \sum _ { i = 1 } ^ { q } \theta _ { i } \epsilon_{t - i}​<br>$$<br>移动平均法能有效地消除预测中的随机波动。</p>
<h3 id="2-3-自回归移动平均ARMA"><a href="#2-3-自回归移动平均ARMA" class="headerlink" title="2.3 自回归移动平均ARMA"></a>2.3 自回归移动平均ARMA</h3><p>自回归模型AR和移动平均模型MA模型相结合，我们就得到了自回归移动平均模型ARMA(p,q)，计算公式如下：<br>$$<br>y _ { t } = \mu + \sum _ { i = 1 } ^ { p } \gamma _ { i }  y _ { t - i } + \epsilon _ { t } + \sum _ { i = 1 } ^ { q } \theta _ { i } \epsilon _ { t - i }<br>$$</p>
<h3 id="2-4-差分自回归移动平均模型ARIMA"><a href="#2-4-差分自回归移动平均模型ARIMA" class="headerlink" title="2.4 差分自回归移动平均模型ARIMA"></a>2.4 差分自回归移动平均模型ARIMA</h3><p>将自回归模型、移动平均模型和差分算法结合，我们就得到了差分自回归移动平均模型ARIMA(p,d,q)，其中d是需要对数据进行差分和阶数。</p>
<h2 id="3、建立ARIMA模型的过程"><a href="#3、建立ARIMA模型的过程" class="headerlink" title="3、建立ARIMA模型的过程"></a>3、建立ARIMA模型的过程</h2><p>一般来说，建立ARIMA模型一般有三个阶段，分别是模型识别和定阶、参数估计和模型检验。</p>
<h3 id="3-1-模型识别和定阶"><a href="#3-1-模型识别和定阶" class="headerlink" title="3.1 模型识别和定阶"></a>3.1 模型识别和定阶</h3><p>模型的识别问题和定阶问题，主要是确定p,d,q三个参数，差分的阶数d一般通过观察图示，1阶或2阶即可。这里我们主要介绍p和q的确定。我们首先介绍两个函数。</p>
<h4 id="自相关函数ACF-autocorrelation-function"><a href="#自相关函数ACF-autocorrelation-function" class="headerlink" title="自相关函数ACF(autocorrelation function)"></a>自相关函数ACF(autocorrelation function)</h4><p>自相关函数ACF描述的是时间序列观测值与其过去的观测值之间的线性相关性。计算公式如下：<br>$$<br>A C F ( k ) = \rho  _ { k } = \frac { C ov ( y _ { t } , y _ { t - k } ) } { V a r ( y _ { t } ) }<br>$$<br>其中k表示滞后期数，如果$k$=2，则代表$y_t$和$y_{t-2}$</p>
<h4 id="偏自相关函数PACF-partial-autocorrelation-function"><a href="#偏自相关函数PACF-partial-autocorrelation-function" class="headerlink" title="偏自相关函数PACF(partial autocorrelation function)"></a>偏自相关函数PACF(partial autocorrelation function)</h4><p>偏自相关函数PACF描述的是在给定中间观测值的条件下，时间序列观测值预期过去的观测值之间的线性相关性。</p>
<p>举个例子：假设k=3，那么我们描述的是$y_t$和$y_{t-3}$之间的相关性，但是这个相关性还收到yt-1和yt-2的影响。PACF剔除了这个影响，而ACF包含了这个影响。</p>
<h4 id="拖尾和截尾"><a href="#拖尾和截尾" class="headerlink" title="拖尾和截尾"></a>拖尾和截尾</h4><p>拖尾指序列以指数率单调递减或震荡衰减，而截尾指序列从某个时点变得非常小：</p>
<p><img src="https://pic.imgdb.cn/item/61c833332ab3f51d91bdf3da.png" alt="img"></p>
<p>出现以下情况，通常是为（偏）自相关系数d阶截尾：</p>
<ol>
<li>在最初的d阶明显大于2倍标准差范围以内</li>
<li>之后几乎95%的（偏）自相关系数都落在2倍标准差范围以内</li>
<li>且由非零自相关系数衰减为在零附近小值波动的过程非常突然</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/61c8335c2ab3f51d91be05a6.png" alt="img"></p>
<p>出现以下情况，通常视为（偏）自相关系数拖尾：</p>
<ol>
<li>如果有超过5%的样本（偏）自相关系数都落入2倍标准差范围之外</li>
<li>或者是由显著非0的（偏）自相关系数衰减为小值波动的过程比较缓慢或非常连续</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/61c833792ab3f51d91be1186.png" alt="img"></p>
<h4 id="p，q阶数的确定"><a href="#p，q阶数的确定" class="headerlink" title="p，q阶数的确定"></a>p，q阶数的确定</h4><p>根据刚才判定截尾和拖尾的准则，p， q的确定基于如下规则：</p>
<table>
<thead>
<tr>
<th>模型（序列）</th>
<th>AR（p）</th>
<th>MA（q）</th>
<th>ARMA（p,q）</th>
</tr>
</thead>
<tbody><tr>
<td>自相关函数</td>
<td>拖尾</td>
<td>第q个后截尾</td>
<td>拖尾</td>
</tr>
<tr>
<td>偏自相关函数</td>
<td>第p个后拖尾</td>
<td>拖尾</td>
<td>拖尾</td>
</tr>
</tbody></table>
<h3 id="3-2-参数估计"><a href="#3-2-参数估计" class="headerlink" title="3.2 参数估计"></a>3.2 参数估计</h3><p>通过拖尾和截尾对模型进行定阶的方法，往往具有很强的主观性，回想我们之前在参数预估的时候往往是怎么做的，不就是和损失和正则项的加权么？我们这里能不能结合最终的预测误差来确定p，q的阶数呢？在相同的预测误差情况下，根据奥斯卡姆剃刀准则，模型越小是越好的。那么，平均预测误差和参数个数，我们可以根据信息准则函数法，来确定模型的阶数。预测误差通常用平方误差即残差平方和来表示。</p>
<p>常用的信息准则函数法有下面几种：</p>
<h4 id="AIC准则"><a href="#AIC准则" class="headerlink" title="AIC准则"></a>AIC准则</h4><p>AIC准则全称为最小信息量准则（Akaike Information Criterion），计算公式如下：</p>
<p>AIC=2*(模型参数的个数) -2ln(模型的极大似然估计函数)</p>
<h4 id="BIC准则"><a href="#BIC准则" class="headerlink" title="BIC准则"></a>BIC准则</h4><p>AIC准则存在一定的不足之处。当样本容量很大时，在AIC准则中拟合误差提供的信息就要受到样本容量的放大，</p>
<p>而参数个数的惩罚因子却和样本容量没关系（一直是2），因此当样本容量很大时，使用AIC准则选择的模型不收敛与真实模型，它通常比真实模型所含的未知参数个数要多。BIC（Bayesian InformationCriterion）贝叶斯信息准则弥补了AIC的不足，计算公式如下：</p>
<p>BIC = ln(n) * (模型中参数的个数) - 2ln(模型的极大似然函数值)，n是样本容量</p>
<p>我们通过类似网格搜索二等方式来寻找我们模型的最佳p，q组合吧。我们可以使用简单的方法来得到p和q的最优值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_results = sm.tsa.arma_order_select_ic(train, ic=[<span class="string">&#x27;aic&#x27;</span>, <span class="string">&#x27;bic&#x27;</span>], trend=<span class="string">&#x27;nc&#x27;</span>, max_ar=<span class="number">8</span>, max_ma=<span class="number">8</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;AIC&#x27;</span>, train_results.aic_min_order)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;BIC&#x27;</span>, train_results.bic_min_order)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AIC (1, 0)</span><br><span class="line">BIC (1, 0)</span><br></pre></td></tr></table></figure>

<p>表明我们应该选择AR(1)模型。</p>
<p>一般来说，BIC准则得到的ARMA模型的阶数较AIC的低。</p>
<h3 id="3-3-模型检验"><a href="#3-3-模型检验" class="headerlink" title="3.3 模型检验"></a>3.3 模型检验</h3><p>这里的模型检验主要有两个：</p>
<ol>
<li>检验参数估计的显著性（t检验）</li>
<li>检验残差序列的随机性，即残差直接是独立的</li>
</ol>
<p>残差序列的随机性可以通过自相关函数法来检验，即做残差的自相关函数图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = sm.tsa.ARIMA(train, order=(1, 0, 0))</span><br><span class="line">results = model.fit()</span><br><span class="line">resid = results.resid #赋值</span><br><span class="line">fig = plt.figure(figsize=(12,8))</span><br><span class="line">fig = sm.graphics.tsa.plot_acf(resid.values.squeeze(), lags=40)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/61c832f52ab3f51d91bdd962.png" alt="img"></p>
<p>这里很明显的检测是通过的。</p>
<h3 id="3-4-模型训练"><a href="#3-4-模型训练" class="headerlink" title="3.4 模型训练"></a>3.4 模型训练</h3><p>预测主要有两个函数，一个是<strong>predict</strong>函数，一个是<strong>forecast</strong>函数。</p>
<p><strong>predict中进行预测的时间段必须在我们训练ARIMA模型的数据中。</strong></p>
<p><strong>forecast则是对训练数据集末尾下一个时间段的值进行预估。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = sm.tsa.ARIMA(data, order=(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">results = model.fit()</span><br><span class="line">predict_sunspots = results.predict(start=<span class="built_in">str</span>(<span class="string">&#x27;2014-04&#x27;</span>),end=<span class="built_in">str</span>(<span class="string">&#x27;2014-05&#x27;</span>),dynamic=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>预估下一个值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">results.forecast()[0]</span><br></pre></td></tr></table></figure>



<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li><a href="https://blog.csdn.net/sunnyxidian/article/details/92946542">ARIMA模型原理及实现</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>传统算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Savitzky-Golay 滤波器</title>
    <url>/2021/12/24/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/Savitzky-Golay%20%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h4 id="Savitzky-Golay-滤波器"><a href="#Savitzky-Golay-滤波器" class="headerlink" title="Savitzky-Golay 滤波器"></a>Savitzky-Golay 滤波器</h4><p>Savitzky-Golay平滑滤波是光谱预处理中常用滤波方法，它的<strong>核心思想是对一定长度窗口内的数据点进行k阶多项式拟合，从而得到拟合后的结果</strong>。对他进行离散化处理后，<strong>S-G滤波其实是一种移动窗口的加权平均算法，</strong>但是其加权系数不是简单的窗口函数，而是通过在滑动窗口内对定高阶多项式的最小二乘拟合得出。</p>
<p>Savitzky-Golay平滑滤波被广泛地运用于数据流平滑除噪，是一种在时域内基于局域多项式最小二乘法拟合的滤波方法。<strong>这种滤波器最大的特点在于在滤除噪声的同时可以确保信号的形状、宽度不变。</strong></p>
<p>使用平滑滤波器对信号滤波时，<strong>实际上是拟合了信号中的低频成分，而将高频成分平滑出去了</strong>。如果噪声在高频端，那么滤波的结果就是去除了噪声，反之，若噪声在低频段，那么滤波的结果就是留下了噪声。</p>
<p>总之，平滑滤波是光谱分析中常用的预处理方法之一。用Savitzky-Golay方法进行平滑滤波，可以提高光谱的平滑性，并降低噪音的干扰。S-G平滑滤波的效果，随着选取窗宽不同而不同，可以满足多种不同场合的要求。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y_smooth = scipy.signal.savgol_filter(y,5,3)  </span><br><span class="line"></span><br><span class="line"># 备注：</span><br><span class="line">y：代表曲线点坐标（x,y）中的y值数组</span><br><span class="line">window_length：窗口长度，该值需为正奇整数。例如：此处取值53</span><br><span class="line">k值：polyorder为对窗口内的数据点进行k阶多项式拟合，k的值需要小于window_length。例如：此处取值3</span><br><span class="line">mode：确定了要应用滤波器的填充信号的扩展类型。（This determines the type of extension to use for the padded signal to which t</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>window_length和K这两个值对曲线的影响。</p>
<ul>
<li>window_length对曲线的平滑作用：window_length的值越小，曲线月贴近真实曲线，window_length值越大，平滑效果越厉害（该值必须为正奇整数）</li>
<li>k值对曲线的平滑作用：k值越大，曲线越贴近真实曲线；k值越小，曲线平滑越厉害。另外，当k值较大时，受窗口长度限制，拟合会出现问题，高频曲线会变成直线。</li>
</ul>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="https://www.cnblogs.com/manuowen-123/p/14967367.html">https://www.cnblogs.com/manuowen-123/p/14967367.html</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>希腊字母表</title>
    <url>/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h1><table>
<thead>
<tr>
<th>希腊字母小写、大写</th>
<th>LaTeX形式</th>
<th>希腊字母小写、大写</th>
<th>LaTeX形式</th>
</tr>
</thead>
<tbody><tr>
<td>α <em><strong>A</strong></em></td>
<td>\alpha A</td>
<td>μ <em><strong>N</strong></em></td>
<td>\mu N</td>
</tr>
<tr>
<td>β <em><strong>B</strong></em></td>
<td>\beta B</td>
<td>ξ Ξ</td>
<td>\xi \Xi</td>
</tr>
<tr>
<td>γ Γ</td>
<td>\gamma \Gamma</td>
<td><strong>o</strong> <em><strong>O</strong></em></td>
<td>o O</td>
</tr>
<tr>
<td>δ Δ</td>
<td>\delta \ Delta</td>
<td>π Π</td>
<td>\pi \Pi</td>
</tr>
<tr>
<td>ϵ ε <em><strong>E</strong></em></td>
<td>\epsilon \varepsilon E</td>
<td>ρ ϱ <em><strong>P</strong></em></td>
<td>\rho \varrho P</td>
</tr>
<tr>
<td>ζ <em><strong>Z</strong></em></td>
<td>\zeta Z</td>
<td>σ Σ</td>
<td>\sigma \Sigma</td>
</tr>
<tr>
<td>η <em><strong>H</strong></em></td>
<td>\eta H</td>
<td>τ <em><strong>T</strong></em></td>
<td>\tau T</td>
</tr>
<tr>
<td>θ ϑ Θ</td>
<td>\theta \vartheta \Theta</td>
<td>υ Υ</td>
<td>\upsilon \Upsilon</td>
</tr>
<tr>
<td>ι <em><strong>I</strong></em></td>
<td>\iota I</td>
<td>ϕ φ Φ</td>
<td>\phi \varphi \Phi</td>
</tr>
<tr>
<td>κ <em><strong>K</strong></em></td>
<td>\kappa K</td>
<td>χ <em><strong>X</strong></em></td>
<td>\chi X</td>
</tr>
<tr>
<td>λ Λ</td>
<td>\lambda \Lambda</td>
<td>ψ Ψ</td>
<td>\psi \Psi</td>
</tr>
<tr>
<td>μ <em><strong>M</strong></em></td>
<td>\mu M</td>
<td>ω Ω</td>
<td>\omega \Omega</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>差分与复原</title>
    <url>/2021/12/26/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%A4%8D%E5%8E%9F/</url>
    <content><![CDATA[<h1 id="时间序列的差分与复原"><a href="#时间序列的差分与复原" class="headerlink" title="时间序列的差分与复原"></a>时间序列的差分与复原</h1><p><strong>在时序分析时，我们经常需要将原始序列进行差分，然后做出拟合或者预测，最后还需要将拟合的或者预测的值恢复成原始序列。这里，使用Pandas的Series中的diff和cumsum函数可以方便的实现。</strong></p>
<h2 id="一阶差分与复原"><a href="#一阶差分与复原" class="headerlink" title="一阶差分与复原"></a>一阶差分与复原</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">time_series = pd.Series([2, 4, 3, 5, 6, 7, 4, 5, 6, 3, 2, 4])</span><br><span class="line">time_series_diff = time_series.diff(1).dropna()</span><br><span class="line">time_series_restored = pd.Series([time_series[0]], index=[time_series.index[0]]).append(time_series_diff).cumsum()</span><br><span class="line">print(time_series)</span><br><span class="line">print(time_series_diff)</span><br><span class="line">print(time_series_restored)</span><br><span class="line">plt.plot(time_series, color=&#x27;red&#x27;, label=&#x27;time_series&#x27;)</span><br><span class="line">plt.plot(time_series_diff, color=&#x27;green&#x27;, label=&#x27;time_series_diff&#x27;)</span><br><span class="line">plt.plot(time_series_restored, color=&#x27;blue&#x27;,linestyle=&#x27;--&#x27;, label=&#x27;time_series_restored&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="多阶差分复原"><a href="#多阶差分复原" class="headerlink" title="多阶差分复原"></a>多阶差分复原</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">time_series = pd.Series([2,4,3,5,6,7,4,5,6,3,2,4], index=pd.date_range(start=&#x27;2000&#x27;, periods=12, freq=&#x27;a&#x27;))</span><br><span class="line">time_series_diff = time_series</span><br><span class="line">diff_times = 3</span><br><span class="line">first_values = []</span><br><span class="line">for i in range(diff_times):</span><br><span class="line">    first_values.append(pd.Series([time_series_diff[0]],index=[time_series_diff.index[0]]))</span><br><span class="line">    time_series_diff = time_series_diff.diff(1).dropna()</span><br><span class="line"></span><br><span class="line">time_series_restored = time_series_diff</span><br><span class="line">for first in reversed(first_values):</span><br><span class="line">    time_series_restored = first.append(time_series_restored).cumsum()</span><br><span class="line">print(time_series)</span><br><span class="line">print(time_series_diff)</span><br><span class="line">print(time_series_restored)</span><br><span class="line">plt.plot(time_series, color=&#x27;red&#x27;, label=&#x27;time_series&#x27;)</span><br><span class="line">plt.plot(time_series_diff, color=&#x27;green&#x27;, label=&#x27;time_series_diff&#x27;)</span><br><span class="line">plt.plot(time_series_restored, color=&#x27;blue&#x27;,linestyle=&#x27;--&#x27;, label=&#x27;time_series_restored&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.jianshu.com/p/88d663ecdf25">Pandas 连续差分diff后恢复原始的序列</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>经验模态分解</title>
    <url>/2021/12/24/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E7%BB%8F%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E8%A7%A3%EF%BC%88EMD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="经验模态分解"><a href="#经验模态分解" class="headerlink" title="经验模态分解"></a>经验模态分解</h3><p>经验模态分解(Empirical Mode Decomposition, EMD)是依据数据自身的时间尺度特征来进行信号分解，无需预先设定任何基函数，是一种时频域信号处理方式。<code>EMD</code>在处理非平稳及非线性数据上具有明显的优势，<strong>适合分析非线性非平稳的信号序列</strong>，具有较高的信噪比。<br><strong>平稳信号</strong>：分布参数（均值，方差，协方差等）或者分布规律随着时间不发生变化<br><strong>非平稳信号</strong>：分布参数（均值，方差，协方差等）或者分布规律随着时间发生变化</p>
<p>该方法的关键是经验模式分解，使负载信号分解为有限个本征信号（Intrinsic Mode Function, IMF），分解出来的各个<code>IMF</code>分量包含了原信号的不同时间尺度的局部特征信息。通俗理解就是，<code>EMD</code>是一台机器，将一对混杂的硬币投进去，其会自动按照1元、5毛、1毛、5分、1分分好。</p>
<h4 id="EMD原理"><a href="#EMD原理" class="headerlink" title="EMD原理"></a>EMD原理</h4><p>在物理上，如果瞬时频率有意义，那么函数必须是对称的，局部均值为零，并且具有相同的过零点和极值点数目。任何信号都是由若干本征模函数组成，一个<strong>本征模函数必须满足以下两个条件：</strong></p>
<ul>
<li>函数在整个时间范围内，局部极值点和过零点的数目必须相等或最多相差一个</li>
<li>在任意时刻点，局部最大值的包络（上包络线）和局部最小值的包络（下包络线）平均必须为零，即上下包络线相对于时间轴局部对称</li>
</ul>
<p>画图解释：</p>
<ol>
<li><p>图线要反复跨越x轴</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/v2-0e5b832aee81e8a9068c9665e6eb2a3a_720w.jpg" alt="img"></p>
<center>在整个数据段内，极值点的个数和过零点的个数必须相等或相差最多不能超过一个</center>

<p>而不能像这样某次穿过零点后出现多个极点：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/v2-921bc09334db7a4e443578091117788f_720w.jpg" alt="img"></p>
</li>
</ol>
<center>极点数目偏多</center>

<ol start="2">
<li><p>包络线要对称：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/v2-8826ddaefd1cebee1841bf5ff083c494_720w.jpg" alt="img"></p>
<center>包络线对称</center>

<p>而不能像这样：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/v2-deb9cd0d0dcb8a154f8621276cce9972_720w.jpg" alt="img"></p>
<center>包络线不对称</center></li>
</ol>
<p>对于上述第二条说明：他把经典的全局性要求修改为局部性要求，使瞬时频率不再受不对称波形所形成的不必要的波动所影响，实际上，这个条件应为“数据的局部均值是零”。但是对于非平稳数据来说，计算局部均值涉及到“局部时间尺度”的概念，而这是很难定义的，因此，在第二个条件中使用了局部极大值和局部极小值包络的平均为零来代替，是信号的波形局部对称。</p>
<p><code>EMD</code>将输入信号分解为几个本征模函数和一个残差组成，即由下列公式组成：</p>
<p>$$<br>I ( n ) = \sum _ { m = 1 } ^ { M } \operatorname { I M F _ { m } ( n ) + \operatorname { Res } _{m} ( n ) }<br>$$<br>其中<em>I</em>(n)表示输入信号，IMF<sub>m</sub>表示M<sup>th</sup>的本征模函数，Res<sub>M</sub>(n)表示残差</p>
<h4 id="EMD分解过程"><a href="#EMD分解过程" class="headerlink" title="EMD分解过程"></a>EMD分解过程</h4><p>提取<code>IMF</code>的过程称为筛选，筛选的过程如下：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/emd_0.png" alt="emd分解"></p>
<ol>
<li>标出局部极值点</li>
<li>通过<strong>三次样条插值</strong>（cubic spline line）连接极大值点构成上包络线（upper envelope）,连接极小值点构成下包络线（lower envelope）</li>
<li>求上下包络线的均值m<sub>1</sub></li>
<li>用输入信号减去上下包络线均值</li>
</ol>
<p>$$<br>X ( t ) - m _ { 1 } = h _ { 1 }<br>$$</p>
<p>​        上述过程的一次迭代不能保证h1是本征模函数（<code>IMF</code>），需要重复上述过程，直到h<sub>1</sub>是本征模函数（<code>IMF</code>）</p>
<h4 id="停机准则"><a href="#停机准则" class="headerlink" title="停机准则"></a>停机准则</h4><p>停机准则决定了一个本征模函数（<code>IMF</code>）筛选过程执行的数目，有如下停机准则</p>
<ul>
<li><p>标准偏差（Standard Deviation, SD）<br>$$<br>S D _ { k } = \sum _ { t = 0 } ^ { T } \frac { | h _ { k - 1 } ( t ) - h _ { k } ( t ) |  ^ { 2 } } { h _ { k - 1 } ^ { 2 } (t)}<br>$$<br>当SD的值小于给定的阈值时，筛选过程停止</p>
</li>
<li><p>S Number准则</p>
<p>定义为过零点和极值点相等或者至多差为1的连续筛选数目。一个S-Number被提前设置，只有当S次连续筛选后，每一次过零点和极值点保持相同（相等或者至多差1），筛选过程才停止</p>
</li>
<li><p>阈值方法</p>
<p>阈值方法设置两个阈值，确保全局小的扰动同时考虑局部大的偏移</p>
</li>
</ul>
<p>选择停机准则后，第一个<code>IMF</code>（c<sub>1</sub>）可以获得，c<sub>1</sub>为包含输入信号最大频率的成分（component）,之后分离c<sub>1</sub><br>$$<br>X ( t ) - c _ { 1 } = r _ { 1 }<br>$$<br>利用r<sub>1</sub>作为输入，获得其他的本征模函数</p>
<h4 id="EMD限制（Limitations）"><a href="#EMD限制（Limitations）" class="headerlink" title="EMD限制（Limitations）"></a>EMD限制（Limitations）</h4><p><code>EMD</code>的主要<strong>优点</strong>有如下：</p>
<ul>
<li><strong>EMD具有数据驱动的自适应性，能分析非线性非平稳信号，不受Heisenberg测不准原理制约等优点。</strong></li>
<li>EMD在非线性非平稳信号分析中具有显著优势。与传统分析技术相比，<strong>EMD无需选择基函数，其分解基于信号本身极值点的分布。</strong></li>
</ul>
<p><code>EMD</code>的主要<strong>缺点</strong>有如下：</p>
<ul>
<li><p>末端效应</p>
<p>末端效应发生在信号的开始和结尾，因为在信号开始之前和结尾之后没有样本点被考虑。大多数情况下，末端点并不是信号的极值，但是在执行<code>EMD</code>的过程中，极值包络线会在末端点发散（diverge），导致错误，进而扭曲了<code>IMF</code>在末端点的波形，而且这种错误在<code>EMD</code>分解过程中会累积</p>
</li>
<li><p>模态混叠问题</p>
<p>模态混叠问题发上在<code>EMD</code>的执行过程中。出现下列情况之一就称为模态混合</p>
<ul>
<li>在同一个<code>IMF</code>分量中，存在尺度分布范围很宽却又各不相同的信号</li>
<li>在不同的<code>IMF</code>分量中，存在着尺度相近的信号</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211227120152132.png" alt="image-20211227120152132"></p>
<p>模态混叠问题使得特征提取、模型训练、模式识别变得困难，<code>IMF</code>失去了单一特征尺度的特征。<strong>集成经验模态分解(Ensemble empirical mode decomposition, EEMD)被提出用来解决模态混叠问题</strong></p>
</li>
</ul>
<h4 id="EMD和其他方法对比"><a href="#EMD和其他方法对比" class="headerlink" title="EMD和其他方法对比"></a>EMD和其他方法对比</h4><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/emd_1.png" alt="结果对比"></p>
<h3 id="集成经验模态分解（EEMD）"><a href="#集成经验模态分解（EEMD）" class="headerlink" title="集成经验模态分解（EEMD）"></a>集成经验模态分解（EEMD）</h3><p>为了改善测量的准确性，集成平均是有效的方法（也就是多次测量取平均值）。信号极值点影响<code>IMF</code>,若分布不均匀时会出现<strong>模态混叠</strong>，白噪声的频谱均匀分布，白噪声是的信号会自动分布到合适的参考尺度上。由于零均值噪声的特性，噪音经过多次的平均计算后会相互抵消，这样集成均值的计算结果与原始信号的差值随着集成平均的次数增加而减少</p>
<h4 id="EEMD的分解"><a href="#EEMD的分解" class="headerlink" title="EEMD的分解"></a>EEMD的分解</h4><ol>
<li>给原始信号添加白噪声序列</li>
<li>分解带有白噪声序列的输入信号，得到<code>IMFs</code>（第一次测量得到一系列的<code>IMFs</code>）</li>
<li>重复第一和第二步，每次添加不同的白噪声序列（执行多次测量）</li>
<li>获取相关<code>IMFs</code>集成的均值作为最后的结果（理解为多次测量取平均）</li>
</ol>
<p>添加的白噪声的两个属性</p>
<ul>
<li>添加的白噪声导致所有时间尺度上机制分布的相对均匀分布（The added white noise leads to relatively even distribution of extrema distribution on all timescales）</li>
<li>通过集成平均，添加的噪声会被移除（噪声的均值为0）</li>
</ul>
<h4 id="集成经验模态分解（EEMD）优缺点"><a href="#集成经验模态分解（EEMD）优缺点" class="headerlink" title="集成经验模态分解（EEMD）优缺点"></a>集成经验模态分解（EEMD）优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>该算法利用<strong>EMD滤波器组行</strong>为及<strong>白噪声频谱均匀分布</strong>的统计特性，使Sifting过程信号极值点分布更趋匀称，<strong>有效抑制</strong>由间歇性高频分量等因素造成的<strong>模态混叠</strong>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在EEMD中，每个加噪信号hi(t)独立地被分解，使得每个hi(t)分解后可能产生<strong>不同数量的IMF</strong>，导致<strong>集合平均时IMF分量对齐困难。</strong></li>
<li>此外，添加的<strong>白噪声幅值和迭代次数依靠人为经验设置</strong>，当数值设置不当时，无法克服模态混叠。</li>
<li>集总平均次数一般在<strong>几百次</strong>以上，<strong>非常耗时</strong>。虽然增加集合平均次数可降低重构误差，但这是以<strong>增加计算成本</strong>为代价，且<strong>有限次数的集合平均并不能完全消除白噪声，</strong>导致算法重构误差大，分解完备性差。</li>
</ul>
<h3 id="代码实现EMD"><a href="#代码实现EMD" class="headerlink" title="代码实现EMD"></a>代码实现EMD</h3><ul>
<li><p>安装EMD包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install EMD-signal</span><br></pre></td></tr></table></figure></li>
<li><p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = dataset[<span class="string">&#x27;request&#x27;</span>].tolist()</span><br><span class="line">S = np.array(values)</span><br><span class="line">emd = EMD()</span><br><span class="line"><span class="comment"># emd.emd(S,max_imf=3)</span></span><br><span class="line">emd.emd(S)</span><br><span class="line">imfs, res = emd.get_imfs_and_residue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 IMF</span></span><br><span class="line">vis = Visualisation()</span><br><span class="line">vis.plot_imfs(imfs=imfs, residue=res, include_residue=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 绘制并显示所有提供的IMF的瞬时频率</span></span><br><span class="line"><span class="comment"># vis.plot_instant_freq(imfs=imfs)</span></span><br><span class="line">vis.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码实现EEMD"><a href="#代码实现EEMD" class="headerlink" title="代码实现EEMD"></a>代码实现EEMD</h3><ul>
<li><p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prepare and run EEMD</span></span><br><span class="line">eemd = EEMD(trials=<span class="number">50</span>)</span><br><span class="line">eemd.noise_seed(<span class="number">12345</span>)</span><br><span class="line">E_IMFs = eemd.eemd(S)</span><br><span class="line">imfNo = E_IMFs.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># Plot results in a grid</span></span><br><span class="line">c = np.floor(np.sqrt(imfNo + <span class="number">1</span>))</span><br><span class="line">r = np.ceil((imfNo + <span class="number">1</span>) / c)</span><br><span class="line">plt.ioff()</span><br><span class="line">plt.subplot(r, c, <span class="number">1</span>)</span><br><span class="line">plt.plot(S, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Original signal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(imfNo):</span><br><span class="line">    plt.subplot(r, c, num + <span class="number">2</span>)</span><br><span class="line">    plt.plot(E_IMFs[num], <span class="string">&quot;g&quot;</span>)</span><br><span class="line">    <span class="comment"># plt.xlim((tMin, tMax))</span></span><br><span class="line">    plt.title(<span class="string">&quot;Imf &quot;</span> + <span class="built_in">str</span>(num + <span class="number">1</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211227132458310.png" alt="image-20211227132458310"></p>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://muyi110.github.io/2019/%E6%B5%85%E8%B0%88%E7%BB%8F%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E8%A7%A3-EMD/">浅谈经验模态分解-EMD</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/40005057">这篇文章能让你明白经验模态分解（EMD）——基础理论篇</a></li>
<li><a href="https://blog.csdn.net/qinghuanduji/article/details/113801965">EMD的多种方法的介绍与优缺点总结</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>可乐鸡翅</title>
    <url>/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/</url>
    <content><![CDATA[<h3 id="可乐鸡翅"><a href="#可乐鸡翅" class="headerlink" title="可乐鸡翅"></a><a href="https://www.bilibili.com/video/BV1pJ411v7S9?from=search&seid=2151627749794461067">可乐鸡翅</a></h3><ul>
<li><p>原料</p>
<ul>
<li>鸡翅250g（11个左右）</li>
</ul>
</li>
<li><p>做法</p>
<ul>
<li><p>鸡翅泡水解冻</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155937382.png" alt="image-20210126155937382"></p>
</li>
<li><p>捞出，加姜片料酒腌制20分钟（用手抓一抓，搅拌均匀）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155946527.png" alt="image-20210126155946527"></p>
</li>
<li><p>放入锅中焯水捞出</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160034775.png" alt="image-20210126160034775"></p>
</li>
<li><p>锅内热油加入姜片</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160120839.png" alt="image-20210126160120839"></p>
</li>
<li><p>鸡翅正面朝下煎至金黄</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160210270.png" alt="image-20210126160210270"></p>
</li>
<li><p>加入调味</p>
<ul>
<li>一勺料酒</li>
<li>一勺生抽</li>
<li>半勺老抽</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160624263.png" alt="image-20210126160624263"></p>
</li>
<li><p>翻炒均匀上色</p>
</li>
<li><p>可乐一听倒入2/3罐子</p>
</li>
<li><p>放入半勺盐调味，盖上锅盖煮沸</p>
</li>
<li><p>放入香料：香叶八角都可以</p>
</li>
<li><p>大火煮至汤汁收干</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160844786.png" alt="image-20210126160844786"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>食物</category>
      </categories>
  </entry>
  <entry>
    <title>手撕包菜</title>
    <url>/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/</url>
    <content><![CDATA[<hr>
<p>typora-copy-images-to: images</p>
<hr>
<h3 id="手撕包菜"><a href="#手撕包菜" class="headerlink" title="手撕包菜"></a><a href="https://www.bilibili.com/video/BV1hh41197hh?from=search&seid=4921812292540006215">手撕包菜</a></h3><ul>
<li><p>包菜去根，用手撕成小块 <strong>根部用刀拍一下</strong></p>
</li>
<li><p>清水+少许食用盐，在水中清洗浸泡彻底洗净</p>
</li>
<li><p>洗好以后控水备用</p>
</li>
<li><p>几粒大蒜拍碎+干辣椒+花椒</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126162351153.png" alt="image-20210126162351153"></p>
</li>
<li><p>五花肉切成薄片</p>
</li>
<li><p><strong>猪油+五花肉来炒</strong>这样的才香</p>
</li>
<li><p>猪油熬化以后加入五花肉片</p>
</li>
<li><p>先将五花肉煸炒出油，肉片变色，微微发黄时，加入准备好的小料，煸炒出香味，（火要大，锅要热，油要多）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102537195.png" alt="image-20210127102537195"></p>
</li>
<li><p>彻底炒出香味以后放入准备好的包菜</p>
</li>
<li><p>少许米酒或者料酒沿锅边淋入去腥增香</p>
</li>
<li><p>放入少许米醋或者香醋（先放醋，炒出来的包菜更脆）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102716126.png" alt="image-20210127102716126"></p>
</li>
<li><p>大火将包菜炒至塌陷</p>
</li>
<li><p>塌陷以后开始调味（适量盐+少许白糖+蒸鱼豉油）</p>
</li>
<li><p>大火翻炒均匀</p>
</li>
<li><p>香醋沿锅边淋入将整道菜的香味彻底激发出来</p>
</li>
<li><p>这道菜要的是干香脆爽，翻炒时间不要太长</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127103410622.png" alt="image-20210127103410622"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>食物</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2021/05/24/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><h3 id="一、如何使用终端操作数据库"><a href="#一、如何使用终端操作数据库" class="headerlink" title="一、如何使用终端操作数据库"></a>一、如何使用终端操作数据库</h3></li>
<li><p>如何登陆数据库服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d324d8322e6675c0c2074.png" alt="image-20210419101047635"></p>
</li>
<li><p>如何查询数据库服务器中所有的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32998322e6675c0cc068.png" alt="image-20210419100514663"></p>
</li>
<li><p>如何选中某一个数据库进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use sushe；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32c78322e6675c0d1a07.png" alt="image-20210419100606162"></p>
<ul>
<li>SQL语句中的查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from admin；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32d58322e6675c0d3364.png" alt="image-20210419100728472"></p>
<ul>
<li><p>只查询Admin_ID中的一条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from admin where Admin_ID=1；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32e48322e6675c0d4e65.png" alt="image-20210419102716439"></p>
</li>
<li><p>如何退出数据库服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit；</span><br></pre></td></tr></table></figure></li>
<li><p>如何在数据库服务器中创建我们的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32f18322e6675c0d6763.png" alt="image-20210419103011881"></p>
</li>
<li><p>使用test数据库进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use test；</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据库中的数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d32ff8322e6675c0d82bc.png" alt="image-20210419103151476"></p>
</li>
<li><p>创建一个数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	owner <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	species <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	sex <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	birth <span class="type">DATE</span>,</span><br><span class="line">	death <span class="type">DATE</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33118322e6675c0da562.png" alt="image-20210419103553869"></p>
</li>
<li><p>查看数据表是否创建成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables；</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d331d8322e6675c0dbd0b.png" alt="image-20210419103659284"></p>
</li>
<li><p>查看创建好的数据表的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe pet;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d332e8322e6675c0dde96.png" alt="image-20210419103818698"></p>
</li>
<li><p>查看数据表中的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pet;</span><br></pre></td></tr></table></figure>

<p> <img src="https://img.imgdb.cn/item/607d33498322e6675c0e1431.png" alt="image-20210419104228606"></p>
</li>
<li><p>如何往数据表中添加数据记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</span><br><span class="line"><span class="keyword">VALUES</span> （<span class="string">&#x27;Puffball&#x27;</span>,<span class="string">&#x27;Diane&#x27;</span>,<span class="string">&#x27;hamster&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;1999-03-30&#x27;</span>,<span class="keyword">NULL</span>）;</span><br></pre></td></tr></table></figure></li>
<li><p>再次查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pet;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33568322e6675c0e2c64.png" alt="image-20210419104507492"></p>
</li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> pet <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;Fluffy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33658322e6675c0e4753.png" alt="image-20210419110249261"></p>
<p><img src="https://img.imgdb.cn/item/607d33738322e6675c0e6013.png" alt="image-20210419110317720"></p>
</li>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update pet <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;旺旺才&#x27;</span> <span class="keyword">where</span> owner<span class="operator">=</span><span class="string">&#x27;周星驰&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>mysql常用数据类型</p>
<ul>
<li><p>日期选择按照格式；数值字符串按照大小！</p>
</li>
<li><p>MySQL支持多种类型，大致可以分为三类：</p>
</li>
<li><p>数值</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 byte</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 bytes</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 bytes</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 bytes</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 bytes</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 bytes</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度 浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 bytes</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
</li>
<li><p>日期/时间</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 ( bytes)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
</li>
<li><p>字符串（字符）</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255 bytes</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 bytes</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255 bytes</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255 bytes</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535 bytes</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535 bytes</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<h3 id="mysql建表约束"><a href="#mysql建表约束" class="headerlink" title="mysql建表约束"></a>mysql建表约束</h3></li>
<li><p>主键约束</p>
<ul>
<li><p>它能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束，就可以使得该字段不重复且不为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d34858322e6675c10a412.png" alt="image-20210419111116893"></p>
<ul>
<li>– 联合主键<br>– 联合主键中的每个字段都<strong>不能为空</strong>，并且<strong>加起来</strong>不能和已设置的联合主键重复。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id, name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自增约束</p>
<ul>
<li>管控id的值让他可以增长</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name) <span class="keyword">values</span>(<span class="string">&#x27;zhangsan&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>忘记创建主键约束怎么办，可以通过SQL语句设置（两种方式）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>```<br>desc user<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210419135347642](https://img.imgdb.cn/item/607d33918322e6675c0e993b.png)</span><br><span class="line"></span><br><span class="line">* 修改表结构，添加主键</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">ALTER TABLE user ADD PRIMARY KEY(id);</span><br><span class="line">ALTER TABLE user MODIFY id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://img.imgdb.cn/item/607d339c8322e6675c0eb30b.png" alt="image-20210419140048250"></p>
<ul>
<li><p>如何删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33aa8322e6675c0ed7de.png" alt="image-20210419140205166"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>唯一约束</p>
<ul>
<li>约束修饰的字段的值不能重复</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加唯一约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">unique</span>(name);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33b68322e6675c0eed4b.png" alt="image-20210419140558495"></p>
</li>
<li><p>创建表的时候添加唯一约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)，</span><br><span class="line">    <span class="keyword">unique</span>(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">unique</span>(id,name)表示两个键在一起不重复就行</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">unique</span>(id,name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33c58322e6675c0f0b88.png" alt="image-20210419140816729"></p>
</li>
<li><p>删除唯一约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> index name;</span><br></pre></td></tr></table></figure></li>
<li><p>modify添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> modify <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、建表的时候添加约束</span><br><span class="line">2、可以使用alter... add ...</span><br><span class="line">3、alter... modify ...</span><br><span class="line">4、删除alter ... drop ...</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>非空约束</p>
<ul>
<li><p>修饰的字段不能为空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33d38322e6675c0f2817.png" alt="image-20210419141716219"></p>
</li>
<li><p>不传入name值会报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>正确用法</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> uservalues(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>默认约束</p>
<ul>
<li><p>当我们插入字段值时，如果没有传值，就会使用默认值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">default</span> <span class="number">10</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33e08322e6675c0f4744.png" alt="image-20210419142616113"></p>
</li>
</ul>
</li>
<li><p>外键约束</p>
<ul>
<li><p>涉及到两个表：父表，子表</p>
</li>
<li><p>主表，副表</p>
</li>
<li><p>班级表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>学生表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    class_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key(class_id) <span class="keyword">references</span> classes(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d33f68322e6675c0f7d6a.png" alt="image-20210419143103219"></p>
</li>
<li><p>插入四个班</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;一班&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;二班&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;三班&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;四班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d34068322e6675c0fa28e.png" alt="image-20210419143606566"></p>
</li>
<li><p>往对应的班级添加学生信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">1001</span>,<span class="string">&#x27;一班&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">1002</span>,<span class="string">&#x27;二班&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">1003</span>,<span class="string">&#x27;三班&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> calsses <span class="keyword">values</span>(<span class="number">1004</span>,<span class="string">&#x27;四班&#x27;</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>结论</p>
<ul>
<li>主表classes中没有的数据值，在副表中，是不可以使用的。</li>
<li>主表中的记录被副表引用，是不可以被删除的。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h3><ul>
<li><p>第一范式（1NF)</p>
<ul>
<li><p>数据表中的所有字段都是不可分割的原子值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    address <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;中国四川省成都市武侯区武侯大道100号&#x27;</span>);</span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;中国四川省成都市武侯区武侯大道200号&#x27;</span>);</span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;中国四川省成都市武侯区武侯大道300号&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d34198322e6675c0fca93.png" alt="image-20210419150252138"></p>
</li>
<li><p>字段还可以继续拆分，就不满足第一范式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    privence <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    city <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    details <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;四川省&#x27;</span>,<span class="string">&#x27;成都市&#x27;</span>,<span class="string">&#x27;武侯区武侯大道100号&#x27;</span>);</span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;四川省&#x27;</span>,<span class="string">&#x27;成都市&#x27;</span>,<span class="string">&#x27;武侯区武侯大道100号&#x27;</span>);</span><br><span class="line">inser <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;四川省&#x27;</span>,<span class="string">&#x27;成都市&#x27;</span>,<span class="string">&#x27;武侯区武侯大道100号&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img.imgdb.cn/item/607d34268322e6675c0fe63e.png" alt="image-20210419150357502"></p>
</li>
<li><p>范式，设计的越详细，对于某些实际操作可能更好，单不一定都是好处。</p>
</li>
</ul>
</li>
<li><p>第二范式（2NF）</p>
<ul>
<li><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。</p>
</li>
<li><p>如果出现不完全依赖，只可能发生在联合主键的情况下。</p>
</li>
<li><p>订单表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>除了主键以外的列，只依赖于主键的部分字段。</p>
</li>
<li><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
</li>
<li><p>拆表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    customer_id <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
</li>
</ul>
</li>
<li><p>第三范式（3NF）</p>
<ul>
<li><p>必须先满足第二范式，除开主键的其他列之间不能传递依赖</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    customer_phone <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    customer_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,<span class="keyword">sql</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
</li>
<li><p>参考文献：<a href="https://www.bilibili.com/video/BV1Vt411z7wy?p=18&spm_id_from=pageDriver">一天学会 MySQL 数据库</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker概念</title>
    <url>/2021/05/28/docker%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h3 id="操作概念图"><a href="#操作概念图" class="headerlink" title="操作概念图"></a>操作概念图</h3><p><img src="https://pic.imgdb.cn/item/60b03e3a08f74bc159e36b7c.png" alt="操作概念图"></p>
<h3 id="对应概念"><a href="#对应概念" class="headerlink" title="对应概念"></a>对应概念</h3><ul>
<li><p>镜像：就类似于我们用虚拟机，创建虚拟机前要下载的系统镜像文件，比如iso文件、img文件等等这样一些镜像文件。通俗来说就是为容器用来创建容器的</p>
</li>
<li><p>容器：它可以类比成正在运行中的一个虚拟机。</p>
</li>
<li><p>tar文件：tar文件就类似于vm使用时的vmdk文件，它可以将镜像直接保存成一个tar文件，然后怎样给别人然后别人通过load指令，重新加载成一个镜像，然后通过run指令就可以起来一个正在运行中的容器了。</p>
</li>
<li><p>Dockerfile：Dockerfile相当于一个配置文件，通过写“如何构建”的步骤，来指定一个镜像是如何构建的。通过docker build指令可以将dockerfile构建成一个镜像。</p>
</li>
<li><p>仓库(Repository)：仓库中保存了很多的镜像，包括一些共有的第三方已经做好的镜像比如ubuntu镜像nginx镜像mysql镜像tomcat镜像等等。我们可以通过docker poll指令下载这些镜像到本地。当然也可以把这些镜像通过push上传上去。</p>
</li>
</ul>
<h4 id="docker总述"><a href="#docker总述" class="headerlink" title="docker总述"></a>docker总述</h4><p>通过以上这些技术的组合，最后的结果就是，绝大部分应用，开发者都可以通过docker build创建镜像，通过docker push上传镜像，用户通过docker pull下载镜像，用docker run运行应用。用户不需要再去关心如何搭建环境，如何安装，如何解决不同发行版的库冲突——而且通常不会需要消耗更多的硬件资源，不会明显降低性能。这就是其他答主所说的标准化、集装箱的原因所在。</p>
<hr>
<h3 id="Docker基础命令操作"><a href="#Docker基础命令操作" class="headerlink" title="Docker基础命令操作"></a><strong>Docker基础命令操作</strong></h3><p>查看docker相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]#  docker version  </span><br><span class="line">Client:</span><br><span class="line"> Version:    17.12.0-ce</span><br><span class="line"> API version:    1.35</span><br><span class="line"> Go version:    go1.9.2</span><br><span class="line"> Git commit:    c97c6d6</span><br><span class="line"> Built:    Wed Dec 27 20:10:14 2017</span><br><span class="line"> OS/Arch:    linux/amd64</span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:    17.12.0-ce</span><br><span class="line">  API version:    1.35 (minimum version 1.12)</span><br><span class="line">  Go version:    go1.9.2</span><br><span class="line">  Git commit:    c97c6d6</span><br><span class="line">  Built:    Wed Dec 27 20:12:46 2017</span><br><span class="line">  OS/Arch:    linux/amd64</span><br><span class="line">  Experimental:    false</span><br></pre></td></tr></table></figure>



<p>配置docker镜像加速</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="启动第一个容器"><a href="#启动第一个容器" class="headerlink" title="启动第一个容器"></a><strong>启动第一个容器</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 80:80 nginx</span><br><span class="line">Unable to find image &#x27;nginx:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">e7bb522d92ff: Pull complete </span><br><span class="line">6edc05228666: Pull complete </span><br><span class="line">cd866a17e81f: Pull complete </span><br><span class="line">Digest: sha256:285b49d42c703fdf257d1e2422765c4ba9d3e37768d6ea83d7fe2043dad6e63d</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">8d8f81da12b5c10af6ba1a5d07f4abc041cb95b01f3d632c3d638922800b0b4d</span><br><span class="line"># 容器启动后，在浏览器进行访问测试 </span><br></pre></td></tr></table></figure>



<p>参数说明</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynaIkgI7JtOveSAbjXfG6uaPNuVVrIkoJE1K77bACvftojnM02VwUibOqg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="Docker镜像生命周期"><a href="#Docker镜像生命周期" class="headerlink" title="Docker镜像生命周期"></a><strong>Docker镜像生命周期</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynaUibxBaiaWD7IRzrUichEnq4G3fHV5AFNmib1f3Jvl3ANMdyPcicQSH4ZbQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="Docker镜像相关操作"><a href="#Docker镜像相关操作" class="headerlink" title="Docker镜像相关操作"></a><strong>Docker镜像相关操作</strong></h2><h3 id="搜索官方仓库镜像"><a href="#搜索官方仓库镜像" class="headerlink" title="搜索官方仓库镜像"></a><strong>搜索官方仓库镜像</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]#  docker search centos</span><br><span class="line">NAME                      DESCRIPTION                    STARS    OFFICIAL               AUTOMATED</span><br><span class="line">centos                    The official build of CentOS.  3992     [OK]      </span><br><span class="line">ansible/centos7-ansible   Ansible on Centos7             105                              [OK]</span><br></pre></td></tr></table></figure>



<p>列表说明</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynaFo53zx47VEJGZOgBezDeibvyRtneDiclLtbPhWlqn9E7hXhYrX4P7rBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a><strong>获取镜像</strong></h3><p>根据镜像名称拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">af4b0a2388c6: Downloading  34.65MB/73.67MB</span><br></pre></td></tr></table></figure>



<p>查看当前主机镜像列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<p>拉第三方镜像方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull index.tenxcloud.com/tenxcloud/httpd</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a><strong>导出镜像</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br><span class="line"># 导出</span><br><span class="line">[root@docker01 ~]# docker image save centos &gt; docker-centos.tar.gz</span><br></pre></td></tr></table></figure>



<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a><strong>删除镜像</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker image rm centos:latest</span><br><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a><strong>导入镜像</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker image load -i docker-centos.tar.gz  </span><br><span class="line">e15afa4858b6: Loading layer  215.8MB/215.8MB</span><br><span class="line">Loaded image: centos:latest</span><br><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<h3 id="查看镜像的详细信息"><a href="#查看镜像的详细信息" class="headerlink" title="查看镜像的详细信息"></a><strong>查看镜像的详细信息</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker image inspect centos</span><br></pre></td></tr></table></figure>

<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="容器的日常管理"><a href="#容器的日常管理" class="headerlink" title="容器的日常管理"></a><strong>容器的日常管理</strong></h2><h3 id="容器的起-停"><a href="#容器的起-停" class="headerlink" title="容器的起/停"></a><strong>容器的起/停</strong></h3><p>最简单的运行一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run nginx</span><br></pre></td></tr></table></figure>



<p>创建容器，两步走（不常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker create centos:latest  /bin/bash</span><br><span class="line">bb7f32368ecf0492adb59e20032ab2e6cf6a563a0e6751e58930ee5f7aaef204</span><br><span class="line">[root@docker01 ~]# docker start stupefied_nobel</span><br><span class="line">stupefied_nobel</span><br></pre></td></tr></table></figure>



<p>快速启动容器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  centos:latest  /usr/bin/sleep 20;</span><br></pre></td></tr></table></figure>



<p><strong>容器内的第一个进程必须一直处于运行的状态，否则这个容器，就会处于退出状态！</strong></p>
<p>查看正在运行的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker container ls</span><br><span class="line">    或</span><br><span class="line">[root@docker01 ~]# docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8708e93fd767        nginx               &quot;nginx -g &#x27;daemon of…&quot;   6 seconds ago       Up 4 seconds        80/tcp              keen_lewin</span><br></pre></td></tr></table></figure>





<p>查看你容器详细信息/ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker container  inspect  容器名称/id</span><br></pre></td></tr></table></figure>





<p>查看你所有容器（包括未运行的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">8708e93fd767        nginx               &quot;nginx -g &#x27;daemon of…&quot;   4 minutes ago       Exited (0) 59 seconds ago                       keen_lewin</span><br><span class="line">f9f3e6af7508        nginx               &quot;nginx -g &#x27;daemon of…&quot;   5 minutes ago       Exited (0) 5 minutes ago                        optimistic_haibt</span><br><span class="line">8d8f81da12b5        nginx               &quot;nginx -g &#x27;daemon of…&quot;   3 hours ago         Exited (0) 3 hours ago                          lucid_bohr</span><br></pre></td></tr></table></figure>



<p>停止容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker stop 容器名称/id </span><br><span class="line">或</span><br><span class="line">[root@docker01 ~]# docker container  kill  容器名称/id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进入容器方法"><a href="#进入容器方法" class="headerlink" title="进入容器方法"></a><strong>进入容器方法</strong></h3><p><strong>启动时进去方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it #参数：-it 可交互终端</span><br><span class="line">[root@docker01 ~]# docker run -it nginx:latest  /bin/bash</span><br><span class="line">root@79241093859e:/#</span><br></pre></td></tr></table></figure>



<p>退出/离开容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl+p &amp; ctrl+q</span><br></pre></td></tr></table></figure>



<p><strong>启动后进入容器的方法</strong></p>
<p>启动一个docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it centos:latest </span><br><span class="line">[root@1bf0f43c4d2f /]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         13      1  0 15:47 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>attach进入容器，使用pts/0 ，会让所用通过此方法进如放入用户看到同样的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker attach 1bf0f43c4d2f</span><br><span class="line">[root@1bf0f43c4d2f /]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         14      1  0 15:49 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>自命名启动一个容器 –name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker attach 1bf0f43c4d2f</span><br><span class="line">[root@1bf0f43c4d2f /]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         14      1  0 15:49 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>exec 进入容器方法（推荐使用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker exec -it clsn1  /bin/bash </span><br><span class="line">[root@b20fa75b4b40 /]# 重新分配一个终端</span><br><span class="line">[root@b20fa75b4b40 /]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 16:11 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         13      0  0 16:14 pts/1    00:00:00 /bin/bash</span><br><span class="line">root         26     13  0 16:14 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a><strong>删除所有容器</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker rm -f  `docker ps -a -q`</span><br><span class="line"># -f 强制删除</span><br></pre></td></tr></table></figure>



<h3 id="启动时进行端口映射"><a href="#启动时进行端口映射" class="headerlink" title="启动时进行端口映射"></a><strong>启动时进行端口映射</strong></h3><p>-p参数端口映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 8888:80  nginx:latest </span><br><span class="line">287bec5c60263166c03e1fc5b0b8262fe76507be3dfae4ce5cd2ee2d1e8a89a9</span><br></pre></td></tr></table></figure>



<p>不同指定映射方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynakNeESgzibS7rmBBE8gmib9ibXYSaL2eBmL6Kew6nhxvHexx9DKNeqM8DQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>随机映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -P （大P）# 需要镜像支持</span><br></pre></td></tr></table></figure>

<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="Docker-数据卷的管理"><a href="#Docker-数据卷的管理" class="headerlink" title="Docker 数据卷的管理"></a><strong>Docker 数据卷的管理</strong></h2><h3 id="挂载时创建卷"><a href="#挂载时创建卷" class="headerlink" title="挂载时创建卷"></a><strong>挂载时创建卷</strong></h3><p>挂载卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest</span><br><span class="line">079786c1e297b5c5031e7a841160c74e91d4ad06516505043c60dbb78a259d09</span><br></pre></td></tr></table></figure>



<p>容器内站点目录: /usr/share/nginx/html</p>
<p>在宿主机写入数据，查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# echo &quot;http://www.nmtui.com&quot; &gt;/data/index.html</span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100</span><br><span class="line">http://www.nmtui.com</span><br></pre></td></tr></table></figure>



<p>设置共享卷，使用同一个卷启动一个新的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:latest </span><br><span class="line">351f0bd78d273604bd0971b186979aa0f3cbf45247274493d2490527babb4e42</span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:8080</span><br><span class="line">http://www.nmtui.com</span><br></pre></td></tr></table></figure>



<p>查看卷列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br></pre></td></tr></table></figure>

<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="创建卷后挂载"><a href="#创建卷后挂载" class="headerlink" title="创建卷后挂载"></a><strong>创建卷后挂载</strong></h3><p>创建一个卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume create </span><br><span class="line">f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br><span class="line">[root@docker01 ~]# docker volume ls </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br></pre></td></tr></table></figure>



<p>指定卷名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume ls </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               clsn</span><br><span class="line">local               f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br></pre></td></tr></table></figure>



<p>查看卷路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume inspect clsn </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-02-01T00:39:25+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/clsn/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;clsn&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>使用卷创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest </span><br><span class="line">1434559cff996162da7ce71820ed8f5937fb7c02113bbc84e965845c219d3503</span><br><span class="line"># 宿主机测试</span><br><span class="line">[root@docker01 ~]# echo &#x27;blog.nmtui.com&#x27; &gt;/var/lib/docker/volumes/clsn/_data/index.html </span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:9000</span><br><span class="line">blog.nmtui.com</span><br></pre></td></tr></table></figure>



<p>设置卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -d  -P  --volumes-from 079786c1e297 nginx:latest </span><br><span class="line">b54b9c9930b417ab3257c6e4a8280b54fae57043c0b76b9dc60b4788e92369fb</span><br></pre></td></tr></table></figure>



<p>查看使用的端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# netstat -lntup </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1400/sshd           </span><br><span class="line">tcp        0      0 10.0.0.100:2375         0.0.0.0:*               LISTEN      26218/dockerd       </span><br><span class="line">tcp6       0      0 :::9000                 :::*                    LISTEN      32015/docker-proxy  </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      31853/docker-proxy  </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      31752/docker-proxy  </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1400/sshd           </span><br><span class="line">tcp6       0      0 :::32769                :::*                    LISTEN      32300/docker-proxy  </span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:32769</span><br><span class="line">http://www.nmtui.com</span><br></pre></td></tr></table></figure>



<h3 id="手动将容器保存为镜像"><a href="#手动将容器保存为镜像" class="headerlink" title="手动将容器保存为镜像"></a><strong>手动将容器保存为镜像</strong></h3><p>本次是基于docker官方centos 6.8 镜像创建</p>
<p>官方镜像列表：</p>
<p><a href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a></p>
<p>启动一个centos6.8的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker pull  centos:6.8</span><br><span class="line">[root@docker01 ~]# docker run -it -p 1022:22 centos:6.8  /bin/bash</span><br><span class="line"># 在容器种安装sshd服务，并修改系统密码</span><br><span class="line">[root@582051b2b92b ~]# yum install  openssh-server -y </span><br><span class="line">[root@582051b2b92b ~]# echo &quot;root:123456&quot; |chpasswd</span><br><span class="line">[root@582051b2b92b ~]#  /etc/init.d/sshd start</span><br></pre></td></tr></table></figure>



<p>启动完成后镜像ssh连接测试</p>
<p>将容器提交为镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker commit brave_mcclintock  centos6-ssh</span><br></pre></td></tr></table></figure>





<p>使用新的镜像启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d  -p 1122:22  centos6-ssh:latest  /usr/sbin/sshd -D </span><br><span class="line">5b8161fda2a9f2c39c196c67e2eb9274977e7723fe51c4f08a0190217ae93094</span><br></pre></td></tr></table></figure>





<p>在容器安装httpd服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@5b8161fda2a9 /]#  yum install httpd -y</span><br></pre></td></tr></table></figure>



<p>编写启动脚本脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@5b8161fda2a9 /]# cat  init.sh </span><br><span class="line">#!/bin/bash </span><br><span class="line">/etc/init.d/httpd start </span><br><span class="line">/usr/sbin/sshd -D</span><br><span class="line">[root@5b8161fda2a9 /]# chmod +x init.sh </span><br><span class="line"># 注意执行权限</span><br></pre></td></tr></table></figure>





<p>再次提交为新的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker commit  5b8161fda2a9 centos6-httpd </span><br><span class="line">sha256:705d67a786cac040800b8485cf046fd57b1828b805c515377fc3e9cea3a481c1</span><br></pre></td></tr></table></figure>





<p>启动镜像，做好端口映射。并在浏览器中测试访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 1222:22 -p 80:80  centos6-httpd /init.sh </span><br><span class="line">46fa6a06644e31701dc019fb3a8c3b6ef008d4c2c10d46662a97664f838d8c2c</span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile自动构建docker镜像"><a href="#Dockerfile自动构建docker镜像" class="headerlink" title="Dockerfile自动构建docker镜像"></a><strong>Dockerfile自动构建docker镜像</strong></h2><p>官方构建dockerffile文件参考</p>
<p><a href="https://github.com/CentOS/CentOS-Dockerfiles">https://github.com/CentOS/CentOS-Dockerfiles</a></p>
<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="Dockerfile指令集"><a href="#Dockerfile指令集" class="headerlink" title="Dockerfile指令集"></a><strong>Dockerfile指令集</strong></h3><p>dockerfile主要组成部分：</p>
<ul>
<li>基础镜像信息 FROM centos:6.8</li>
<li>制作镜像操作指令RUN yum insatll openssh-server -y</li>
<li>容器启动时执行指令 CMD [“/bin/bash”]</li>
</ul>
<p>dockerfile常用指令：</p>
<ul>
<li>FROM 这个镜像的妈妈是谁？（指定基础镜像）</li>
<li>MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可以没有）</li>
<li>RUN 你想让它干啥（在命令前面加上RUN即可）</li>
<li>ADD 给它点创业资金（COPY文件，会自动解压）</li>
<li>WORKDIR 我是cd,今天刚化了妆（设置当前工作目录）</li>
<li>VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录）</li>
<li>EXPOSE 它要打开的门是啥（指定对外的端口）</li>
<li>CMD 奔跑吧，兄弟！（指定容器启动后的要干的事情）</li>
</ul>
<p>dockerfile其他指令： </p>
<ul>
<li>COPY 复制文件</li>
<li>ENV 环境变量</li>
<li>ENTRYPOINT 容器启动后执行的命令</li>
</ul>
<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="创建一个Dockerfile"><a href="#创建一个Dockerfile" class="headerlink" title="创建一个Dockerfile"></a><strong>创建一个Dockerfile</strong></h3><p>创建第一个Dockerfile文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">[root@docker01 base]# cd /opt/base</span><br><span class="line"># 创建Dcokerfile文件，注意大小写</span><br><span class="line">[root@docker01 base]# vim Dockerfile</span><br><span class="line">FROM centos:6.8</span><br><span class="line">RUN yum install openssh-server -y </span><br><span class="line">RUN echo &quot;root:123456&quot; |chpasswd</span><br><span class="line">RUN /etc/init.d/sshd start </span><br><span class="line">CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure>



<p>构建docker镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 base]# docker image build  -t centos6.8-ssh . </span><br><span class="line">-t 为镜像标签打标签  . 表示当前路径</span><br></pre></td></tr></table></figure>



<p>使用自构建的镜像启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 base]# docker run  -d -p 2022:22 centos6.8-ssh-b </span><br><span class="line">dc3027d3c15dac881e8e2aeff80724216f3ac725f142daa66484f7cb5d074e7a</span><br></pre></td></tr></table></figure>



<h3 id="使用Dcokerfile安装kodexplorer"><a href="#使用Dcokerfile安装kodexplorer" class="headerlink" title="使用Dcokerfile安装kodexplorer"></a><strong>使用Dcokerfile安装kodexplorer</strong></h3><p>Dockerfile文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos:6.8</span><br><span class="line">RUN yum install wget unzip php php-gd php-mbstring -y &amp;&amp; yum clean all</span><br><span class="line"># 设置工作目录，之后的操作都在这个目录中</span><br><span class="line">WORKDIR /var/www/html/</span><br><span class="line">RUN wget -c http://static.kodcloud.com/update/download/kodexplorer4.25.zip</span><br><span class="line">RUN unzip kodexplorer4.25.zip &amp;&amp; rm -f kodexplorer4.25.zip</span><br><span class="line">RUN chown -R apache.apache .</span><br><span class="line">CMD [&quot;/usr/sbin/apachectl&quot;,&quot;-D&quot;,&quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure>



<p>更多的Dockerfile可以参考官方方法。</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h2 id="Docker中的镜像分层"><a href="#Docker中的镜像分层" class="headerlink" title="Docker中的镜像分层"></a><strong>Docker中的镜像分层</strong></h2><p>参考文档：</p>
<p><a href="http://www.maiziedu.com/wiki/cloud/dockerimage/">http://www.maiziedu.com/wiki/cloud/dockerimage/</a></p>
<p>Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynas9e1SPE00p4KlGDcMGb7Xp8ibKhJUuftYu9sp2icZh0J0lnmueXSY6VA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<h3 id="Docker-镜像为什么分层"><a href="#Docker-镜像为什么分层" class="headerlink" title="Docker 镜像为什么分层"></a><strong>Docker 镜像为什么分层</strong></h3><p>镜像分层最大的一个好处就是共享资源。</p>
<p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。</p>
<h3 id="可写的容器层"><a href="#可写的容器层" class="headerlink" title="可写的容器层"></a><strong>可写的容器层</strong></h3><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynaJyT5S3WcJFzicwdZ4lcnmFZoZThzVoVC0XTEffppGF94jmtPYibSp5Aw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有<strong>容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p>
<h3 id="容器层的细节说明"><a href="#容器层的细节说明" class="headerlink" title="容器层的细节说明"></a><strong>容器层的细节说明</strong></h3><p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。</p>
<p>文件操作的</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJkhkuE70FRxhYFYlJEibIynab8GVumOeOPd2oKh3EiaEAl3gtUbYwwDdvl59kC8Iu1FKBib9VtssunCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p>
<p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/YlcvlUQ-xkz25PuYkeEQqw">Docker从入门到干活，看这一篇足矣</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></h4><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>
<p><strong>说明:</strong></p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br><span class="line">     因为最后一行应为左对齐，而不是左右两端对齐。       </span><br><span class="line">     第二行同样为左对齐，这是因为这行只包含一个单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth = 20</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>解答：分三种情况一种是一个单词一行、普通情况、最后一行；每个写成一个 函数，返回String，主函数ArrayList.append();算出每行还剩多少空格在进行分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            count += words[i].length();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxWidth) &#123;</span><br><span class="line">                resultList.add(helper(words, start, i - <span class="number">1</span>, maxWidth));</span><br><span class="line">                start = i ;</span><br><span class="line">                count =  words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//单词结束后的空格</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后一截</span></span><br><span class="line">        resultList.add(helper(words,start,words.length-<span class="number">1</span>,maxWidth));</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">            <span class="comment">// 一行只有一个单词</span></span><br><span class="line">            oneWordOneRow(words,start,maxWidth,sb);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end == words.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//最后一行</span></span><br><span class="line">            lastRow(words,start,end,maxWidth,sb);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            normal(words,start,end,maxWidth,sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneWordOneRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb.append(words[start]);</span><br><span class="line">        <span class="keyword">int</span> num = maxWidth - words[start].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lastRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end; i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = maxWidth - sb.length();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">normal</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordsLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            wordsLength += words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> seperate =  (maxWidth -wordsLength) / (end - start);</span><br><span class="line">        <span class="keyword">int</span> remain = (maxWidth -wordsLength) % (end - start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=end;i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; seperate; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(remain-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>主要是用了一个滑动窗口法</li>
<li>设立一个当前最大值和当前left边界</li>
<li>遇见相同的元素就改变当前left边界位置</li>
<li>然后比较之前获得的最大值，当前得到的不重复字符串长度取最大</li>
<li>遍历结束则得到最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            <span class="comment">//求最大窗口</span></span><br><span class="line">            max = Math.max(max, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></h4><p>难度简单164</p>
<p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p>
<p><strong>美式键盘</strong> 中：</p>
<ul>
<li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li>
<li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li>
<li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/keyboard.png" alt="American keyboard"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;omk&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;adsdf&quot;,&quot;sfd&quot;]</span><br><span class="line">输出：[&quot;adsdf&quot;,&quot;sfd&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 20</code></li>
<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
<li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>大小写的处理：全部存入String遍历</li>
<li>返回字符串数组 的构造： List<String> ans = new ArrayList&lt;&gt;(); 返回String需要对其进行重新构造ans.toArray(new String[ans.size()]);</li>
<li>字符串的s.contains()使用：最后+“”，使其变成字符串</li>
<li></li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span>, <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span>, <span class="string">&quot;zxcvbnmZXCVBNM&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, n3 = <span class="number">0</span>, leng = word.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leng; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ss[<span class="number">0</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n2++;</span><br><span class="line">                <span class="keyword">else</span> n3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n1 == leng || n2 == leng || n3 == leng) ans.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NC17-最长回文子串"><a href="#NC17-最长回文子串" class="headerlink" title="NC17 最长回文子串"></a><a href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=188&&tqId=38608&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=188&page=1">NC17 最长回文子串</a></h4><p><strong>描述</strong></p>
<p>对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n^2)</p>
<p>进阶: 空间复杂度 O(n)，时间复杂度 O(n)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;ababc&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最长的回文子串为&quot;aba&quot;与&quot;bab&quot;，长度都为3</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;abbba&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;b&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>中心扩散法</li>
<li>两种类型回文“aba”，“abba”</li>
<li>判断两次下标（i, i）（i, i+1）</li>
</ul>
<p><strong>解答2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = centerSpread(A, i, i) &gt; centerSpread(A, i, i+<span class="number">1</span>) ? centerSpread(A,i,i):centerSpread(A,i,i+<span class="number">1</span>);</span><br><span class="line">            maxLen = Math.max(maxLen, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">break</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里left和right多操作了一次</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：中心扩散法，返回具体子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置最长回文子串的初始和截尾位置</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//两种类型回文“aba”，“abba” ,所以判断两次(i,i)(i,i+1)</span></span><br><span class="line">            <span class="keyword">int</span> len1 = centerSpread(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = centerSpread(s,i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="comment">// 发现更长的之后更新end，start</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                <span class="comment">//符合两种情况（3/2=1）</span></span><br><span class="line">                start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i + (len)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//[start, end+1)</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">break</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里left和right多操作了一次</span></span><br><span class="line">        <span class="keyword">return</span> right - left -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="NC1-大数加法"><a href="#NC1-大数加法" class="headerlink" title="NC1 大数加法"></a>NC1 大数加法</h4><p><strong>描述</strong></p>
<p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</p>
<p>数据范围：len(s),len(t) \le 100000<em>l<strong>e</strong>n</em>(<em>s</em>),<em>l<strong>e</strong>n</em>(<em>t</em>)≤100000，字符串仅由’0’~‘9’构成</p>
<p>要求：时间复杂度 O(n)<em>O</em>(<em>n</em>)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;1&quot;,&quot;99&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1+99=100      </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;114514&quot;,&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;114514&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>StringBuilder构建</li>
<li>从后往前加</li>
<li>字符的数=s.charAt(i) - ‘0’</li>
<li>StringBuilder反转再转为String</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">while</span>(sLen &gt; <span class="number">0</span> || tLen &gt; <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sVal = sLen &gt; <span class="number">0</span> ? s.charAt(sLen - <span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tVal = tLen &gt; <span class="number">0</span> ? t.charAt(tLen - <span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + sVal + tVal;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            ans.append(sum % <span class="number">10</span>);</span><br><span class="line">            sLen --;</span><br><span class="line">            tLen --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法2：</strong>大数乘法一样的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> lenS = s.length(), lenT = t.length();</span><br><span class="line">        <span class="keyword">int</span> [] arrS = <span class="keyword">new</span> <span class="keyword">int</span> [lenS];</span><br><span class="line">        <span class="keyword">int</span> [] arrT = <span class="keyword">new</span> <span class="keyword">int</span> [lenT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">            arrS[i] = s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenT; i++) &#123;</span><br><span class="line">            arrT[i] = t.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = lenS &gt; lenT ? lenS : lenT;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span> [maxLen + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">            res[maxLen-i] = (i &lt; lenS ? arrS[lenS-<span class="number">1</span>-i] : <span class="number">0</span>) + (i &lt;lenT? arrT[lenT-<span class="number">1</span>-i] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxLen; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = res[i]+carry;</span><br><span class="line">            carry = res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i] = res[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; maxLen + <span class="number">1</span> &amp;&amp; res[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur; i &lt; maxLen+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC10-大数乘法"><a href="#NC10-大数乘法" class="headerlink" title="NC10 大数乘法"></a>NC10 大数乘法</h4><p><strong>描述</strong></p>
<p>以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。</p>
<p>数据范围： 读入的数字大小满足 0 \le n \le 10^{1000}0≤<em>n</em>≤101000<br>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n^2)<em>O</em>(<em>n</em>2)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;11&quot;,&quot;99&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;1089&quot;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11*99=1089 </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;1&quot;,&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>字符串转整数数组</li>
<li>拆分每个数字相乘</li>
<li>每个位置的数字进位和留下来的数字取出</li>
<li>整数数组转字符串（注意0*0）</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 字符串转数组</span></span><br><span class="line">        <span class="keyword">int</span> lenS = s.length();</span><br><span class="line">        <span class="keyword">int</span> lenT = t.length();</span><br><span class="line">        <span class="keyword">int</span>[] arrS = <span class="keyword">new</span> <span class="keyword">int</span>[lenS];</span><br><span class="line">        <span class="keyword">int</span>[] arrT = <span class="keyword">new</span> <span class="keyword">int</span>[lenT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; lenS; i++) &#123;</span><br><span class="line">            arrS[i] = s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; lenT; i++) &#123;</span><br><span class="line">            arrT[i] = t.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[lenS + lenT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenT; j++) &#123;</span><br><span class="line">                <span class="comment">// 留了一位进位</span></span><br><span class="line">                res[i + j + <span class="number">1</span>] += arrS[i] * arrT[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 进位的处理</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lenT + lenS - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] += carry;</span><br><span class="line">            carry = res[i] / <span class="number">10</span>;</span><br><span class="line">            res[i] = res[i] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到有数字的那一位</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; lenT + lenS &amp;&amp; res[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 整数转字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur; i &lt; res.length; i++) &#123;</span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NC111-最大数"><a href="#NC111-最大数" class="headerlink" title="NC111 最大数"></a>NC111 最大数</h4><p><strong>描述</strong></p>
<p>给定一个长度为n的数组nums，数组由一些非负整数组成，现需要将他们进行排列并拼接，每个数不可拆分，使得最后的结果最大，返回值需要是string类型，否则可能会溢出。</p>
<p>数据范围：1 \le n \le 1001≤<em>n</em>≤100，0 \le nums[i] \le 100000≤<em>n<strong>u</strong>m**s</em>[<em>i</em>]≤10000</p>
<p>进阶：时间复杂度O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>) ，空间复杂度：O(n)<em>O</em>(<em>n</em>)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[30,1]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;301&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,20,23,4,8]</span><br></pre></td></tr></table></figure>



<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;8423220&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例4</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[10]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>整数转字符串</li>
<li>字符串比较（a.compareto.b），比较字符串可以比较它首个的ASCIIC码</li>
<li>注意[0,0]情况返回00不规范</li>
<li>StringBuilder构建字符串返回值</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//整形转字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较字符串可以比较它首个的ASCIIC码，而不是整体的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(((list.get(i)+list.get(j)).compareTo(list.get(j)+list.get(i))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(list, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.get(<span class="number">0</span>).equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="comment">//字符串拼接</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            res.append(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ArrayList&lt;String&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        String tmp = list.get(i);</span><br><span class="line">        list.set(i, list.get(j));</span><br><span class="line">        list.set(j, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>手机拍照技巧</title>
    <url>/2022/01/03/%E6%91%84%E5%BD%B1/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="自拍"><a href="#自拍" class="headerlink" title="自拍"></a>自拍</h4><ul>
<li>灯光在头顶，正午拍照，光源在头顶，脸上会有非常明显的三角形投影，不适合自拍。<ul>
<li>脸部朝向灯光的方向，避免顶光在脸部形成强烈的投影</li>
<li>带个帽子</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208205624811.png" alt="image-20201208205624811"></p>
<ul>
<li><p>室内怎么让自拍照更美？靠近窗户的时候，逆光，脸部光线不好。</p>
</li>
<li><p>换个方向，面向光源，逆光自拍会看到脸部的瑕疵（颗粒，皱纹等等），顺光自拍可以减少脸部的瑕疵。</p>
</li>
<li><p>自拍角度决定你的胖瘦。</p>
<ul>
<li><p>低于30°的仰拍角，容易拍出圆乎乎的大脸</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210135055.png" alt="image-20201208210135055"></p>
</li>
<li><p>手机保持30-45°的仰拍角度，更容易拍出巴掌脸与尖下巴</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210352336.png" alt="image-20201208210352336"></p>
</li>
<li><p>脸大脸圆？学会遮挡术</p>
<ul>
<li><p>利用树叶花朵等作为前景，虚化并遮住部分脸，即显得脸小又增加画面趣味。(借助道具，手、围巾、帽子、花花草草。)</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210639392.png" alt="image-20201208210639392"></p>
</li>
<li><p>还可以用双手或者单手托脸既可以遮住部分脸又显得可爱</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210742655.png" alt="image-20201208210742655"></p>
</li>
<li><p>借助道具，比如饮料杯遮住部分脸</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210830160.png" alt="image-20201208210830160"></p>
</li>
</ul>
</li>
<li><p>怎么让自拍照看起来不像自拍照</p>
<ul>
<li>借助手机自拍杆+定时遥控器</li>
<li>放在桌子或者窗台+定时自拍</li>
</ul>
</li>
<li><p>全身照瞬间拥有大长腿</p>
<ul>
<li>错误角度：俯拍容易拍的比本人显矮</li>
<li>蹲下来采用仰拍角度<ul>
<li>脚与地面的留白一定要少留地面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211431040.png" alt="image-20201208211431040"></p>
<h4 id="拍照的构图"><a href="#拍照的构图" class="headerlink" title="拍照的构图"></a>拍照的构图</h4><ul>
<li><p><strong>黄金分割</strong>，拍摄人像不知道把任务放置于画面哪个位置的时候，置于黄金分割点是最稳妥的构图方法。</p>
<ul>
<li><p>设置九宫格四个交叉点的位置就是黄金分割点</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211908865.png" alt="image-20201208211908865"></p>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211942688.png" alt="image-20201208211942688"></p>
</li>
<li><p><strong>点构图</strong>：点构图是拍摄环境人像时，最喜欢使用的一种构图方法，这样的构图，<strong>人物在画面里的比例很小</strong>，强调环境与人物和谐统一的关系。</p>
<ul>
<li>点构图的适用场景通常为视野开阔画面干净纯粹没有过多杂物的环境</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212412080.png" alt="image-20201208212412080"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212426560.png" alt="image-20201208212426560"></p>
<ul>
<li><p><strong>对角线构图</strong>：拍摄静物或者风光照片时，对角线构图特别适用</p>
<ul>
<li><p>对角线构图适合用于拍摄静物、花草植物或大面积的草坪、画面中有道路的自然风景</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212932256.png" alt="image-20201208212932256"></p>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212723202.png" alt="image-20201208212723202"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212746080.png" alt="image-20201208212746080"></p>
</li>
</ul>
<ul>
<li><p><strong>中心对称构图</strong> </p>
<ul>
<li><p>有倒影的时候，为了追求画面平衡对称，把人物放置于画面正中间，倒影与人物聚焦中心对称点</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213049793.png" alt="image-20201208213049793"></p>
</li>
<li><p>横构图中如果有弧形的线条横穿画面拍摄主体为一颗树时，可以将树放置于画面正中心</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213322513.png" alt="image-20201208213322513"></p>
</li>
<li><p>用竖构图拍摄人物特写，为了画面饱满，突出人物神态，也适用中心对称构图。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213428017.png" alt="image-20201208213428017"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213437744.png" alt="image-20201208213437744"></p>
</li>
</ul>
</li>
<li><p><strong>三角形构图</strong>，利用三角形构图，达到画面的平衡、稳定、饱满同时又不失灵活与动感</p>
<ul>
<li><p>拍摄静物或者人像时都可以尝试三角形构图</p>
<p><img src="images/image-20201208213524368.png?lastModify=1607434632" alt="image-20201208213524368"></p>
</li>
<li><p>拍摄前摆设物品时，有意识的选择三角形构图，把几个物品分别放在三个角，这样构图比较饱满不会显得呆板。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213739834.png" alt="image-20201208213739834"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213755697.png" alt="image-20201208213755697"></p>
</li>
<li><p>拍摄人像如何使用三角形构图</p>
<ul>
<li><p>利用模特的手或腿摆出不同的pose，让人物呈现三角形的构图画面</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213944752.png" alt="image-20201208213944752"></p>
</li>
<li><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214024680.png" alt="image-20201208214024680"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214041217.png" alt="image-20201208214041217"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>引导线构图</strong>，利用画面中的线条，引导观者的目光，让视线可以汇聚到画面的焦点</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214225858.png" alt="image-20201208214225858"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214244817.png" alt="image-20201208214244817"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214254865.png" alt="image-20201208214254865"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214707089.png" alt="image-20201208214707089"></p>
</li>
<li><p><strong>重复线条构图</strong>：利用画面中规律排列的物体进行构图，让照片充满工整与秩序感</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214916083.png" alt="image-20201208214916083"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214926913.png" alt="image-20201208214926913"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214937969.png" alt="image-20201208214937969"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214946433.png" alt="image-20201208214946433"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214955154.png" alt="image-20201208214955154"></p>
</li>
<li><p><strong>开放式构图</strong>：主体不一定放在画中心，有意在画面周围留下被切割的不完整形象，引导观众产生画外空间联想</p>
<ul>
<li><p>什么是封闭式构图：讲究画面完整，主体在画面之中，构图较工整，框架内部布局均衡、严禁、完整</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215546274.png" alt="image-20201208215546274"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215809810.png" alt="image-20201208215809810"></p>
</li>
<li><p>什么是开放式构图：主体不一定放在画中心，注重主体与画外的联系有意在画面周围留下切割的不完整形象，引导观众突破画框限制，产生画外空间联系</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215557329.png" alt="image-20201208215557329"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215825762.png" alt="image-20201208215825762"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215840816.png" alt="image-20201208215840816"></p>
</li>
<li><p>开放式构图拍摄静物或美食：拍摄画面里，桌面露出一小部分边角，这样的开放构图也会让人产生能长久注视画面思考遐想的效果</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215955632.png" alt="image-20201208215955632"></p>
</li>
</ul>
</li>
<li><p><strong>前景虚化构图</strong>：利用花草树木等物品作为前景，用大光圈拍摄虚化前景，制造梦幻、神秘的画面</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220521634.png" alt="image-20201208220521634"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220549714.png" alt="image-20201208220549714"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220601698.png" alt="image-20201208220601698"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220615777.png" alt="image-20201208220615777"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220625584.png" alt="image-20201208220625584"></p>
</li>
</ul>
<h4 id="小道具"><a href="#小道具" class="headerlink" title="小道具"></a>小道具</h4><ul>
<li><p>拍照的时候不知道手往哪里放，眼睛该往哪儿看</p>
</li>
<li><p>道具一：书、报纸、杂志</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113723831.png" alt="image-20201210113723831"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113740913.png" alt="image-20201210113740913"></p>
</li>
<li><p>道具二：食物（假装吃，假装喝）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113840257.png" alt="image-20201210113840257"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114107202.png" alt="image-20201210114107202"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114038513.png" alt="image-20201210114038513"></p>
</li>
<li><p>道具三：围巾、披肩、帽子</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114229969.png" alt="image-20201210114229969"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114249425.png" alt="image-20201210114249425"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114304577.png" alt="image-20201210114304577"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114315969.png" alt="image-20201210114315969"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114348323.png" alt="image-20201210114348323"></p>
</li>
<li><p>相机</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114427329.png" alt="image-20201210114427329"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114455826.png" alt="image-20201210114455826"></p>
</li>
<li><p>镜子</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114556977.png" alt="image-20201210114556977"></p>
</li>
<li><p>花草树叶等植物</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114640865.png" alt="image-20201210114640865"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114711890.png" alt="image-20201210114711890"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114746689.png" alt="image-20201210114746689"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114928673.png" alt="image-20201210114928673"></p>
</li>
<li><p>自行车</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114958755.png" alt="image-20201210114958755"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115016593.png" alt="image-20201210115016593"></p>
</li>
<li><p>雨、雪、风、阳光</p>
<ul>
<li>雨，躲在屋檐下把手放在头顶装作要遮雨一样</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115258513.png" alt="image-20201210115258513"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115315522.png" alt="image-20201210115315522"></p>
<ul>
<li>雪</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115421905.png" alt="image-20201210115421905"></p>
<ul>
<li>雪+逆光<ul>
<li>最好是很细颗粒的雪花，逆光拍摄，把雪花朝着镜头洒过来</li>
<li>模特洒雪花的同时要保持微笑，表情不能太奔放与放松</li>
<li>伞，伞柄不能把脸遮住</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115832982.png" alt="image-20201210115832982"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115851699.png" alt="image-20201210115851699"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115924946.png" alt="image-20201210115924946"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120224994.png" alt="image-20201210120224994"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120244786.png" alt="image-20201210120244786"></p>
</li>
<li><p>风</p>
<ul>
<li>当有风的时候，利用风将头发和衣服吹起来</li>
<li>最好是顺风，迎着风摆pose，眼神表情一定要到位</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120424421.png" alt="image-20201210120424421"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120529268.png" alt="image-20201210120529268"></p>
</li>
<li><p>阳光</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120614675.png" alt="image-20201210120614675"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120829954.png" alt="image-20201210120829954"></p>
</li>
<li><p>逆光拍摄</p>
<ul>
<li>日出、日落是逆光拍摄的最佳时间段</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120959832.png" alt="image-20201210120959832"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121240403.png" alt="image-20201210121240403"></p>
<ul>
<li>当屋外太阳比较高时可以选择路面有积雪的或者四周有白色墙面的环境进行拍摄逆光</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121734771.png" alt="image-20201210121734771"></p>
<ul>
<li>或者躲进屋内拍摄逆光</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121820695.png" alt="image-20201210121820695"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121830145.png" alt="image-20201210121830145"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121839586.png" alt="image-20201210121839586"></p>
<ul>
<li>逆光帮手：三棱镜</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211222932427.png" alt="image-20201211222932427"></p>
<ul>
<li>逆光剪影怎么拍<ul>
<li>人物背后要有大面积空景，不能有山等阻挡（山顶、楼顶、海边、或者站高一点与其他人物脱离）</li>
</ul>
</li>
<li>光背景过亮 人脸过黑怎么办<ul>
<li>对焦锁焦以后加曝光</li>
</ul>
</li>
<li>逆光条件不理想，比如天空惨白怎么办<ul>
<li>只利用光线，天空部分少拍入画面</li>
</ul>
</li>
<li>太阳角度比较高的逆光拍摄<ul>
<li>可以选择室内拍摄，让光线透过玻璃窗打进屋内</li>
<li>寻找有积雪、四周白色墙壁环境的地方拍摄逆光，让白色物体的反光对人物进行补光</li>
</ul>
</li>
<li>巧妙的利用小道具制造不一样的逆光（三棱镜）</li>
<li>逆光拍摄剪影有哪些诀窍<ul>
<li>任务的背后要有大面积的空景，不能有建筑物或山等阻挡</li>
<li>天空中最好有美丽的火烧云，这样逆光照片色彩好看</li>
<li>最好挑选在山顶、楼顶、海边等空旷环境拍摄逆光剪影</li>
</ul>
</li>
</ul>
</li>
<li><p>哪些小技巧，可以让你的照片更有感觉</p>
<ul>
<li><p>虚化背景，突出主题（相机人像模式）。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224712762.png" alt="image-20201211224712762"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224731048.png" alt="image-20201211224731048"></p>
</li>
<li><p>三棱镜：遮挡杂物，营造梦幻效果。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224823643.png" alt="image-20201211224823643"></p>
</li>
<li><p>分身效果：全景模式下模特由起始点移动到结束点，中间不能有路人闯入。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224920330.png" alt="image-20201211224920330"></p>
</li>
<li><p>镜面效果：积水，湖泊</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224938235.png" alt="image-20201211224938235"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224957947.png" alt="image-20201211224957947"></p>
</li>
<li><p>悬浮效果：站板凳上一张，空景一张，app合成去掉板凳（设置一个蒙版，把它擦出来）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225121692.png" alt="image-20201211225121692"></p>
</li>
<li><p>制造画框，将拍摄主体置于任何框内</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225222522.png" alt="image-20201211225222522"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225238832.png" alt="image-20201211225238832"></p>
</li>
<li><p>用手机如何拍出车辆运动轨迹的照片</p>
<ul>
<li>快门速度设置到1/20,1/30秒的速度</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225456114.png" alt="image-20201211225456114"></p>
</li>
<li><p>一组人像：景大人小，互相衬托，人景合一</p>
<ul>
<li>尝试拍摄景大人小的环境人像，这样的照片更耐看</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225614266.png" alt="image-20201211225614266"></p>
<ul>
<li>环境人像要斟酌人物着装是否与环境相呼应</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225706777.png" alt="image-20201211225706777"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225718601.png" alt="image-20201211225718601"></p>
</li>
</ul>
</li>
<li><p>男友拍照指南？？？</p>
<ul>
<li><p>餐厅</p>
<ul>
<li><p>挑选靠窗户的光源位置，让女朋友面朝窗户</p>
</li>
<li><p>跟实物合影，可以近距离高角度把她和食物一起拍进画面</p>
</li>
<li><p>注意看看脸上细节，进行补妆</p>
</li>
<li><p>端着水杯，或者利用桌上的植物作为虚化的前景增添照片的意境</p>
</li>
<li><p>不一定要看镜头，不看镜头的照片可能更加自然</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225858985.png" alt="image-20201211225858985"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230014394.png" alt="image-20201211230014394"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230232644.png" alt="image-20201211230232644"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230320730.png" alt="image-20201211230320730"></p>
</li>
</ul>
</li>
<li><p>街景拍照</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230434330.png" alt="image-20201211230434330"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230456826.png" alt="image-20201211230456826"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230537417.png" alt="image-20201211230537417"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230832809.png" alt="image-20201211230832809"></p>
</li>
<li><p>旅行拍摄赢芳心</p>
<ul>
<li><p>大头照与景大人小的照片都要拍</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231020307.png" alt="image-20201211231020307"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231032234.png" alt="image-20201211231032234"></p>
</li>
<li><p>寻找好的光源或者利用小道具，让她的皮肤在镜头里显得水汪汪</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231125843.png" alt="image-20201211231125843"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231135144.png" alt="image-20201211231135144"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231148765.png" alt="image-20201211231148765"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231159066.png" alt="image-20201211231159066"></p>
</li>
<li><p>想避开人群或拍出大长腿只需要蹲下拍摄</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231255965.png" alt="image-20201211231255965"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231304281.png" alt="image-20201211231304281"></p>
</li>
<li><p>手机采用竖构图拍摄更容易拉长腿</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231335864.png" alt="image-20201211231335864"></p>
</li>
<li><p>与可爱的小动物合影，抓拍自然生动的照片</p>
<p>​    <img src="images/image-20201211231418986.png" alt="image-20201211231418986"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拍美食</strong> </p>
<ul>
<li><p>尽量在光线充足明亮的地方拍照，最好是靠近窗户的光源</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133702979.png" alt="image-20201213133702979"></p>
</li>
<li><p>当地特色美食纪念照</p>
<ul>
<li><p>寻找漂亮的背景，如店铺的招牌</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133824287.png" alt="image-20201213133824287"></p>
</li>
<li><p>尽量让拍摄角度与背景面板保持垂直平行</p>
</li>
<li><p>用当地的特色建筑或街道作为背景</p>
</li>
</ul>
</li>
<li><p>只拍一款美食时诀窍</p>
<ul>
<li><p>构图采用中心点构图，将一盘美食放置于画面最中间（尽量让整盘食物充满画面，但也不能太拥挤，画面至少保留餐盘边缘）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134024640.png" alt="image-20201213134024640"></p>
</li>
</ul>
</li>
<li><p>采用俯拍，保持30-45°的角度拍摄</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134215182.png" alt="image-20201213134215182"></p>
</li>
<li><p>部分实物，采用特殊角度拍摄</p>
<ul>
<li><p>饮料蛋糕冰淇淋等有立体感的食物，有时候采用平视角度更加合适</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134343823.png" alt="image-20201213134343823"></p>
</li>
<li><p>整桌的食物更适合俯视平拍角度</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135433744.png" alt="image-20201213135433744"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135454240.png" alt="image-20201213135454240"></p>
</li>
<li><p>加入手的元素，让照片有互动感</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135532991.png" alt="image-20201213135532991"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135552575.png" alt="image-20201213135552575"></p>
</li>
<li><p>拍摄前整理盘内食物形状与盘边食物残渣</p>
</li>
<li><p>利用小道具让画面摆脱单调，更丰富</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135846143.png" alt="image-20201213135846143"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135857777.png" alt="image-20201213135857777"></p>
</li>
<li><p>foodie APP</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135944030.png" alt="image-20201213135944030"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拯救镜头恐惧症</strong></p>
<ul>
<li><p>低头微笑</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140114237.png" alt="image-20201213140114237"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140144768.png" alt="image-20201213140144768"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140201519.png" alt="image-20201213140201519"></p>
</li>
<li><p>撩头发</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140221731.png" alt="image-20201213140221731"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140236419.png" alt="image-20201213140236419"></p>
</li>
<li><p>回眸一笑</p>
<ul>
<li>回眸时，压低头。否则容易拍出大脸</li>
<li>回眸瞬间记得用头发遮下脸，别用力太猛把头发甩开了</li>
<li>回头时可以保持微笑，头与身体朝镜头方向倾斜一些，这样可以显瘦</li>
<li>若想要自然状态，可以不看镜头，看自己的斜后方</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140306240.png" alt="image-20201213140306240"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140322080.png" alt="image-20201213140322080"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140331437.png" alt="image-20201213140331437"></p>
</li>
<li><p>托住脸颊</p>
<ul>
<li><p>轻轻放在脸颊旁边，真正托住脸颊的话，脸会被压变形</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140703775.png" alt="image-20201213140703775"></p>
</li>
<li><p>不看镜头，等待观看，凝视</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140738606.png" alt="image-20201213140738606"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140753038.png" alt="image-20201213140753038"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140806898.png" alt="image-20201213140806898"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140822623.png" alt="image-20201213140822623"></p>
</li>
<li><p>借助食物饮料等作为道具拿在手里</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140909615.png" alt="image-20201213140909615"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140958000.png" alt="image-20201213140958000"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141013536.png" alt="image-20201213141013536"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141025585.png" alt="image-20201213141025585"></p>
</li>
<li><p>抬头闭眼微笑</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141052558.png" alt="image-20201213141052558"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141103600.png" alt="image-20201213141103600"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141128318.png" alt="image-20201213141128318"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141139502.png" alt="image-20201213141139502"></p>
</li>
<li><p>坐下来</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141242494.png" alt="image-20201213141242494"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141255040.png" alt="image-20201213141255040"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141310287.png" alt="image-20201213141310287"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141327583.png" alt="image-20201213141327583"></p>
</li>
<li><p>奔跑（奔跑的速度比平时慢一点，动作比平时夸张，拍摄角度最好从侧面拍摄）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141426483.png" alt="image-20201213141426483"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141505295.png" alt="image-20201213141505295"></p>
</li>
<li><p>走路（连拍，步子迈的明显一些）</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141536080.png" alt="image-20201213141536080"></p>
</li>
<li><p>跳跃</p>
<ul>
<li>机位蹲低，可以显高</li>
<li>跳跃时人脸容易变形、表情不受控制，采用侧面拍摄可以避免尴尬</li>
</ul>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141749071.png" alt="image-20201213141749071"></p>
</li>
<li><p>旋转，转圈</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141822223.png" alt="image-20201213141822223"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141832320.png" alt="image-20201213141832320"></p>
</li>
<li><p>凝望镜头，眼睛里要有戏</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141917825.png" alt="image-20201213141917825"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://www.bilibili.com/video/BV1Gb411S7wC?from=search&seid=5668966452379294491">手机摄影之生活拍照技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2022/01/03/%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 循环判断左右指针是否走到一起，判断中间值大于还是小于目标值，等于则返回否则，重新复制左右指针，继续循环。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></h4><p>难度简单184</p>
<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>
<p>当提莫攻击艾希，艾希的中毒状态正好持续 <code>duration</code> 秒。</p>
<p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>
<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>
<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：timeSeries = [1,4], duration = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。</span><br><span class="line">艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：timeSeries = [1,2], duration = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。</span><br><span class="line">艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= timeSeries.length &lt;= 104</code></li>
<li><code>0 &lt;= timeSeries[i], duration &lt;= 107</code></li>
<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>
</ul>
<p><strong>思路：</strong>抛开惯性思维，不要本能 想着 从前往后 看，可以从后往前看，最后一个单独处理。</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastTime = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timeSeries.length; i++) &#123;</span><br><span class="line">            ans += Math.min(timeSeries[i]-timeSeries[i-<span class="number">1</span>], duration);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += duration;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p>难度中等1653</p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p><strong>思路：</strong>每次for没 执行完就继续dfs了，return回来之后，后面的就是没有执行的数放进去，接着遍历，然后不断重复回到根节点之时，就是遍历完成之时。</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">                used[i]=<span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><p>难度中等870</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<p><strong>思路：</strong>对数组进行排序，当前与前一个的根节点相同时，跳过这一次遍历</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i-1] == false保证前一个根节点，刚撤销选择</span></span><br><span class="line">            <span class="comment">// i&gt;0保证第二位开始</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">            used[i]=<span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></h4><p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，我都会从 <strong>1</strong> 到 <em><strong>n</strong></em> 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p>
<ul>
<li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li>
<li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li>
<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li>
</ul>
<p>返回我选出的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10, pick = 6</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, pick = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, pick = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, pick = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 231 - 1</code></li>
<li><code>1 &lt;= pick &lt;= n</code></li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>设置左右两个端点</p>
</li>
<li><p>每次循环区间内折半</p>
</li>
<li><p>左右相等时退出得到正确答案</p>
</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right -left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid) &lt;=<span class="number">0</span>) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="NC41-最长无重复子数组"><a href="#NC41-最长无重复子数组" class="headerlink" title="NC41 最长无重复子数组"></a><a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=188&&tqId=38553&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC41 最长无重复子数组</a></h4><p>知识点<a href="https://www.nowcoder.com/ta/job-code-high-week?tag=585">哈希</a><a href="https://www.nowcoder.com/ta/job-code-high-week?tag=5054">双指针</a><a href="https://www.nowcoder.com/ta/job-code-high-week?tag=578">数组</a></p>
<p> 描述</p>
<p>给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。</p>
<p>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p>
<p>数据范围：0≤arre.length*≤10<sup>6</sup>，0&lt;*a**r**r*[*i*]≤10<sup>5</sup></p>
<p>要求：空间复杂度 O*(*n)，时间复杂度 O(nlogn)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,3,4,5]</span><br></pre></td></tr></table></figure>


<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,3,4,5]是最长子数组      </span><br></pre></td></tr></table></figure>



<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,2,3,4,3]</span><br></pre></td></tr></table></figure>


<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,3,4]是最长子数组      </span><br></pre></td></tr></table></figure>



<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[9]</span><br></pre></td></tr></table></figure>


<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>示例4</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,1,2,3,2,2]</span><br></pre></td></tr></table></figure>


<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最长子数组为[1,2,3]     </span><br></pre></td></tr></table></figure>



<p><strong>示例5</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,2,3,4,8,99,3]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最长子数组为[2,3,4,8,99]  </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>两个指针，一个i一个j，最开始的时候i和j指向第一个元素</li>
<li>然后i往后移，把扫描过的元素都放到map中</li>
<li>如果i扫描过的元素没有重复的就一直往后移，顺便记录一下最大值<code>max</code></li>
<li>移动j的时候应该为 Math.max(j, map.get(arr[i]) + 1)</li>
<li>重复的数字可能在之前<strong>移动j的时候跳过了</strong>，所以j的位置不动。</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i])) j = Math.max(j, map.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">            max = Math.max(max, i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NC65-斐波那契数列"><a href="#NC65-斐波那契数列" class="headerlink" title="NC65 斐波那契数列"></a>NC65 斐波那契数列</h4><p>知识点<a href="https://www.nowcoder.com/ta/job-code-high-week?tag=578">数组</a></p>
<p><strong>描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。</p>
<p>斐波那契数列是一个满足$$f i b ( x ) = { \begin{array}  { l l  }  { 1 }   &amp; { x = 1 , 2 } \ { fib ( x - 1 ) + fib ( x - 2 ) } &amp; { x \gt 2 } \end{array}$$的数列</p>
<p>数据范围：1≤<em>n</em>≤39</p>
<p>要求：空间复杂度 O*(1)，时间复杂度 <em>O</em>(<em>n</em>) ，本题也有时间复杂度 O(logn)的解法</p>
<p><strong>输入描述：</strong></p>
<p>一个正整数n</p>
<p><strong>返回值描述：</strong></p>
<p>输出一个正整数。</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据斐波那契数列的定义可知，fib(1)=1,fib(2)=1,fib(3)=fib(3-1)+fib(3-2)=2,fib(4)=fib(4-1)+fib(4-2)=3，所以答案为4。      </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>递归<ul>
<li>往前推，遇到1或2才返回</li>
</ul>
</li>
<li>循环<ul>
<li>循环n-2次，直接交换数据a,b,c</li>
</ul>
</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         if (n == 1 || n == 2) return 1;</span></span><br><span class="line"><span class="comment">//         int a = 1, b = 1, c = 0;</span></span><br><span class="line"><span class="comment">//         for (int i = 2; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             c = a+b;</span></span><br><span class="line"><span class="comment">//             a = b;</span></span><br><span class="line"><span class="comment">//             b = c; </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return c;</span></span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC22-合并两个有序的数组"><a href="#NC22-合并两个有序的数组" class="headerlink" title="NC22 合并两个有序的数组"></a><a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC22 合并两个有序的数组</a></h4><p><strong>描述</strong></p>
<p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组</p>
<p>数据范围：0≤<em>n</em>,<em>m</em>≤100，|A_i| &lt;=100， |B_i| &lt;= 100</p>
<p>注意：<br>1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n</p>
<p>2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了</p>
<p>\3. A 数组在[0,m-1]的范围也是有序的</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[4,5,6],[1,2,3]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A数组为[4,5,6]，B数组为[1,2,3]，后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，将B的数据合并A里面，最后后台程序输出A数组           </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3],[2,5,6]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>有序，A的数组长度足够</li>
<li>双指针，比大小，大的存入一个移动一个，从后往前（后面是空的）</li>
<li>最后剩下的数组元素，全部存入A。</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[m-<span class="number">1</span>] &lt;= B[n-<span class="number">1</span>]) &#123;</span><br><span class="line">                A[m+n-<span class="number">1</span>] = B[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[m+n-<span class="number">1</span>] = A[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                A[i] = B[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC128-接雨水问题"><a href="#NC128-接雨水问题" class="headerlink" title="NC128 接雨水问题"></a>NC128 接雨水问题</h4><p><strong>描述</strong></p>
<p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个柱子高度图，计算按此排列的柱子，下雨之后能接多少雨水。(数组以外的区域高度视为0)</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/26A2E295DEE51749C45B5E8DD671E879" alt="img"></p>
<p>数据范围：0≤<em>n</em>≤106，数组中每个值满足 0&lt;<em>v<strong>a</strong>l</em>≤109</p>
<p>要求：空间复杂度 O(1),时间复杂度 O(n)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,1,2,5,2,4]  </span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组 [3,1,2,5,2,4] 表示柱子高度图，在这种情况下，可以接 5个单位的雨水，蓝色的为雨水 ，如题面图。    </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[4,5,1,3,2]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 </span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>双指针，左右往里靠</li>
<li>左右最大值动态更新</li>
<li>水面高度由左右两边最小的值决定</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = arr[left], rightMax = arr[right];</span><br><span class="line">        <span class="keyword">long</span> water = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, arr[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, arr[right]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">                water = water + leftMax - arr[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                water = water + rightMax - arr[right];</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC38-螺旋矩阵"><a href="#NC38-螺旋矩阵" class="headerlink" title="NC38 螺旋矩阵"></a><a href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=117&&tqId=37738&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=117&page=1">NC38 螺旋矩阵</a></h4><p><strong>描述</strong></p>
<p>给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。</p>
<p>数据范围：0 \le n,m \le 100≤<em>n</em>,<em>m</em>≤10，矩阵中任意元素都满足 |val| \le 100∣<em>v<strong>a</strong>l</em>∣≤100</p>
<p>要求：空间复杂度 O(nm)<em>O</em>(<em>n**m</em>) ，时间复杂度 O(nm)<em>O</em>(<em>n**m</em>)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>





<h4 id="NC112-进制转换"><a href="#NC112-进制转换" class="headerlink" title="NC112 进制转换"></a><a href="https://www.nowcoder.com/practice/2cc32b88fff94d7e8fd458b8c7b25ec1?tpId=117&&tqId=37836&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=117&page=1">NC112 进制转换</a></h4><p><strong>描述</strong></p>
<p>给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。</p>
<p>当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。</p>
<p>若 M 为负数，应在结果中保留负号。</p>
<p>数据范围： M &lt;= 10^8 , 2 \le N \le 16<em>M</em>&lt;=108,2≤<em>N</em>≤16</p>
<p>要求：空间复杂度O(M)<em>O</em>(<em>M</em>)，时间复杂度 O(M)<em>O</em>(<em>M</em>)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7,2</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;111&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10,16</span><br></pre></td></tr></table></figure>



<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><p>明确进制转换的思路，取余在反过来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.append(s.charAt(M%N));</span><br><span class="line">            M = M/N;</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个s = “0123456789ABCDEF”，取余对应的进制在s里取</p>
</li>
<li><p>符号开始时进行判断，最后加进去</p>
</li>
<li><p>最终结果为翻转的，reverse翻转回来。</p>
</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进制转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> M int整型 给定整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N int整型 转换到的进制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        String s = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">        StringBuffer res= <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(M &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            M = -M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(M != <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(s.charAt(M%N));</span><br><span class="line">            M = M/N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NC88-寻找第K大"><a href="#NC88-寻找第K大" class="headerlink" title="NC88 寻找第K大"></a><a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&&tqId=38572&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=188&page=1">NC88 寻找第K大</a></h4><p>描述</p>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。</p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。</p>
<p>要求：时间复杂度 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)，空间复杂度 O(1)<em>O</em>(1)</p>
<p>数据范围：0\le n \le 10000≤<em>n</em>≤1000， 1 \le K \le n1≤<em>K</em>≤<em>n</em>，数组中每个元素满足 0 \le val \le 100000000≤<em>v<strong>a</strong>l</em>≤10000000</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,3,5,2,2],5,3</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[10,10,9,9,8,7,5,6,4,3,4,2],12,3</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">去重后的第3大是8，但本题要求包含重复的元素，不用去重，所以输出9 </span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>快排</li>
</ul>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        quickSort(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[a.length - K];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> point = partition(a, left, right);</span><br><span class="line">            quickSort(a, left, point-<span class="number">1</span>);</span><br><span class="line">            quickSort(a, point+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = a[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; a[right] &gt;= first) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; a[left] &lt;= first) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NC140-排序"><a href="#NC140-排序" class="headerlink" title="NC140 排序"></a><a href="https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=117&page=1&gioEnter=menu"><strong>NC140</strong> <strong>排序</strong></a></h4><p><strong>描述</strong></p>
<p>给定一个长度为 n 的数组，请你编写一个函数，返回该数组按升序排序后的结果。</p>
<p>数据范围： 0≤<em>n</em>≤10<sup>5</sup>，数组中每个元素都满足 0≤<em>v<strong>a</strong>l</em>≤10<sup>9</sup></p>
<p>要求：时间复杂度O*(*n<strong>l</strong>o<strong>g</strong>n)，空间复杂度 O(n)</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5,2,3,1,4]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5,1,6,2,5]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,5,5,6]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>**快速排序(Quick Sort)**：是对冒泡排序的一种改进方法，在冒泡排序中，进行元素的比较和交换是在相邻元素之间进行的，元素每次交换只能移动一个位置，所以比较次数和移动次数较多，效率相对较低。而在快速排序中，元素的比较和交换是从两端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，y速度较快，故称为“快速排序”。<br><strong>快速排序的基本思想是：</strong></p>
<ol>
<li>在待排序的元素任取一个元素作为基准(通常选第一个元素，但最的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；</li>
<li>将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边（在这个过程中，基准元素的位置是会变的）；</li>
<li>基准为最左边的数，则从右边开始比；</li>
<li>对左右两个分区重复以上步骤直到所有元素都是有序的；</li>
</ol>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 将给定数组排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] MySort (<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        quickSort(arr , <span class="number">0</span> , arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 分割数组，找到分割点</span></span><br><span class="line">            <span class="keyword">int</span> point = partition(list, left, right);</span><br><span class="line">            <span class="comment">// 递归调用，对左子数组进行快速排序</span></span><br><span class="line">            quickSort(list, left, point - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归调用，对右子数组进行快速排序</span></span><br><span class="line">            quickSort(list, point + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分割数组，找到分割点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用数组的第一个元素作为基准数</span></span><br><span class="line">        <span class="keyword">int</span> first = list[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; list[right] &gt;= first) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换，这个交换会将first值移动到最右边</span></span><br><span class="line">            swap(list, left, right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; list[left] &lt;= first) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 交换，这个交换会将first值移动到最左边</span></span><br><span class="line">            swap(list, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回分割点所在的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="NC105-二分查找-II"><a href="#NC105-二分查找-II" class="headerlink" title="NC105 二分查找-II"></a><a href="https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&&tqId=38588&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=188&page=1">NC105 二分查找-II</a></h4><p><strong>描述</strong></p>
<p>请实现有重复数字的升序数组的二分查找</p>
<p>给定一个 元素有序的（升序）长度为n的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的第一个出现的target，如果目标值存在返回下标，否则返回 -1</p>
<p>数据范围：0 \le n \le 100000\0≤<em>n</em>≤100000 </p>
<p>进阶：时间复杂度O(logn)*O*(<em>l<strong>o</strong>g**n</em>) ，空间复杂度O(n)*O*(<em>n</em>) </p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,4,4,5],4</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从左到右，查找到第1个为4的，下标为2，返回2    </span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,4,4,5],3</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<p><strong>示例3</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,1,1,1,1],1</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>二分法查找</li>
<li>index存储目标值的位置</li>
<li>设置low，high，每次变动low或者high的值</li>
<li>找到不着急退出，high-1继续分，看是否有序号更小的数值相同的</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="NC7-买卖股票的最好时机-一"><a href="#NC7-买卖股票的最好时机-一" class="headerlink" title="NC7 买卖股票的最好时机(一)"></a><a href="https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=188&tqId=38556&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=188&page=1&difficulty=undefined&judgeStatus=undefined&tags=&title=">NC7 买卖股票的最好时机(一)</a></h4><p><strong>描述</strong></p>
<p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p>
<p>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天</p>
<p>2.如果不能获取到任何利润，请返回0</p>
<p>3.假设买入卖出均无手续费</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[8,9,2,5,4,7,1]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。           </span><br></pre></td></tr></table></figure>





<p><strong>思路：</strong></p>
<ul>
<li>在找到最大价格之前找到最小价格</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pricesMin = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pricesMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++) &#123;</span><br><span class="line">            <span class="comment">//寻找当前股票最便宜的时候</span></span><br><span class="line">            pricesMin = Math.min(pricesMin, prices[i]);</span><br><span class="line">            <span class="comment">//寻找最贵和最便宜相差最大的价格</span></span><br><span class="line">            pricesMax = Math.max(pricesMax,prices[i]-pricesMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pricesMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>每次添加一个数据</li>
</ul>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子集[78]leetcode</span></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; t = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;solution()&quot;</span>);</span><br><span class="line">        solution();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 取输入</span></span><br><span class="line">        BufferedReader buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buffer.readLine();</span><br><span class="line">        <span class="comment">//输入格式大小</span></span><br><span class="line">        <span class="keyword">int</span> inputDataForm = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入数据</span></span><br><span class="line">        <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span> [inputDataForm];</span><br><span class="line">        String tmp = buffer.readLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputDataForm; i++) &#123;</span><br><span class="line">            datas[i] = Integer.parseInt(tmp.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(datas));</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, datas);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(t));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.add(nums[cur]);</span><br><span class="line">        System.out.println(nums[cur]);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.remove(t.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>DFS</li>
<li>加一个判断nums[cur-1] == nums[cur]</li>
</ul>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1 2 2 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; t = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;solution()&quot;</span>);</span><br><span class="line">        solution();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 取输入</span></span><br><span class="line">        BufferedReader buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buffer.readLine();</span><br><span class="line">        <span class="comment">//输入格式大小</span></span><br><span class="line">        <span class="keyword">int</span> inputDataForm = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入数据</span></span><br><span class="line">        <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span> [inputDataForm];</span><br><span class="line">        String tmp = buffer.readLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputDataForm; i++) &#123;</span><br><span class="line">            datas[i] = Integer.parseInt(tmp.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="keyword">false</span>,<span class="number">0</span>, datas);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span> choosePre,<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(t));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="keyword">false</span>, cur+<span class="number">1</span>, nums);</span><br><span class="line">        <span class="comment">// cur &gt; 0是为了防止nums[cur-1]数组溢出</span></span><br><span class="line">        <span class="keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="number">0</span> &amp;&amp; nums[cur-<span class="number">1</span>] == nums[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.add(nums[cur]);</span><br><span class="line">        dfs(<span class="keyword">true</span>,cur+<span class="number">1</span>, nums);</span><br><span class="line">        t.remove(t.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a><a href="https://blog.csdn.net/wthfeng/article/details/78037228">快排</a></h3><ul>
<li>时间复杂度O(logn)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.util.IntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">3 4 1 2 9 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quickSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader buff = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] datas =  <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        s = buff.readLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            datas[i] = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(datas));</span><br><span class="line"></span><br><span class="line">        quickSort(datas, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(datas));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] datas, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选出哨兵元素和基准元素。</span></span><br><span class="line">        <span class="keyword">int</span> i = left, j = right, base = datas[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//右边哨兵从后向前找</span></span><br><span class="line">            <span class="keyword">while</span> ( i &lt; j &amp;&amp; datas[j] &gt;= base) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边哨兵从前向后找</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; datas[i] &lt;= base) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(datas, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准元素与右哨兵交换</span></span><br><span class="line">        swap(datas, left, j);</span><br><span class="line">        <span class="comment">// 递归调用，排序左子集合和右子集合</span></span><br><span class="line">        quickSort(datas, left, j -<span class="number">1</span>);</span><br><span class="line">        quickSort(datas, j + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] datas, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = datas[left];</span><br><span class="line">        datas[left] = datas[right];</span><br><span class="line">        datas[right] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h4><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>难度中等1787</p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode17 电话号码的组合</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] map = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader buff = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buff.readLine();</span><br><span class="line">        len = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(nums, sb, <span class="number">0</span>,res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, StringBuilder sb, <span class="keyword">int</span> index, ArrayList&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//截止条件。长度达到则添加进去元素</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] tmps = map[nums[index]].toCharArray();</span><br><span class="line">        <span class="comment">// 候选节点。添加StringBuilder的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> tmp : tmps) &#123;</span><br><span class="line">            sb.append(tmp);</span><br><span class="line">            dfs(nums, sb, index+<span class="number">1</span>, res);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等1839</p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 <em>所有</em> <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode39 组合总和</span></span><br><span class="line"><span class="comment">4 7</span></span><br><span class="line"><span class="comment">2 3 6 7</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader buff = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> target = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; chain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, chain, target, res);</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; chain, <span class="keyword">int</span> target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = sum(chain);</span><br><span class="line">        <span class="keyword">if</span>( s &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">                <span class="comment">// 引用类型new一个否则后面的值可能改变。</span></span><br><span class="line">                <span class="comment">// 排序判断是否重复的</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(chain);</span><br><span class="line">                Collections.sort(tmp);</span><br><span class="line">                <span class="keyword">if</span> (!res.contains(tmp)) &#123;</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            chain.add(num);</span><br><span class="line">            dfs(nums, chain, target, res);</span><br><span class="line">            chain.remove(chain.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(ArrayList&lt;Integer&gt; chain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : chain) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="46-全排列-1"><a href="#46-全排列-1" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p>难度中等1860</p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">/*</span><br><span class="line">leetcode46 全排列</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">public class DFS3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader buff = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s = buff.readLine();</span><br><span class="line">        int len = Integer.parseInt(s.split(&quot; &quot;)[0]);</span><br><span class="line"></span><br><span class="line">        s = buff.readLine();</span><br><span class="line">        int[] nums = new int[len];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s.split(&quot; &quot;)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 标记哪个数字没使用</span><br><span class="line">        boolean[] used = new boolean[nums.length];</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; chain = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, used, chain, 0, res);</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int[] nums, boolean[] used, ArrayList&lt;Integer&gt; chain, int index, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">        // 截止条件</span><br><span class="line">        if (index == nums.length) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(chain));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 候选节点</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(!used[i]) &#123;</span><br><span class="line">                chain.add(nums[i]);</span><br><span class="line">                used[i] = true;</span><br><span class="line">                dfs(nums, used, chain, index + 1, res);</span><br><span class="line">                chain.remove(chain.size() - 1);</span><br><span class="line">                used[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II-1"><a href="#47-全排列-II-1" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><p>难度中等978</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>解题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode47 全排列II</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 2</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader buff = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        s = buff.readLine();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记哪个数字没使用</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; chain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, used, chain, <span class="number">0</span>, res);</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, ArrayList&lt;Integer&gt; chain, <span class="keyword">int</span> index, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(chain);</span><br><span class="line">            <span class="keyword">if</span> (!res.contains(tmp)) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(chain));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 候选节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">                chain.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(nums, used, chain, index + <span class="number">1</span>, res);</span><br><span class="line">                chain.remove(chain.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="二叉树前中后序遍历"><a href="#二叉树前中后序遍历" class="headerlink" title="二叉树前中后序遍历"></a>二叉树前中后序遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>HPA 使用自定义指标进行伸缩</title>
    <url>/2022/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Spring的IOC容器"><a href="#Spring的IOC容器" class="headerlink" title="Spring的IOC容器"></a>Spring的IOC容器</h1>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>书籍：Spring揭秘</tag>
      </tags>
  </entry>
</search>
