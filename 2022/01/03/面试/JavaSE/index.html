<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaSE | SuperBear's blog</title><meta name="description" content="Java语言有哪些特点 简单易学（Java语言的语法与C语言和C++语言很接近）  面向对象（封装，继承，多态）  平台无关性（Java虚拟机实现平台无关性）  支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）  支持多线程（多线程机制使应用程序在同一时间并行执行多项任）  健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）  安全性   什么是字节码？采用字节码"><meta name="author" content="SuperBear"><meta name="copyright" content="SuperBear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="JavaSE"><meta property="og:url" content="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/"><meta property="og:site_name" content="SuperBear's blog"><meta property="og:description" content="Java语言有哪些特点 简单易学（Java语言的语法与C语言和C++语言很接近）  面向对象（封装，继承，多态）  平台无关性（Java虚拟机实现平台无关性）  支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）  支持多线程（多线程机制使应用程序在同一时间并行执行多项任）  健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）  安全性   什么是字节码？采用字节码"><meta property="og:image" content="https://img2.huashi6.com/images/resource/2019/05/14/747234h06p0.jpg?imageMogr2/quality/75/interlace/1/thumbnail/700x%3E/format/webp"><meta property="article:published_time" content="2022-01-03T10:57:37.000Z"><meta property="article:modified_time" content="2022-02-21T05:19:47.244Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.4.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"bear,love,wind","fontSize":"15px"},
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-02-21 13:19:47'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><link rel="stylesheet" href="\css\bilibiliBanner.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="\css\cursor.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="\css\myDesign.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="\css\custom.css"  media="defer" onload="this.media='all'"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><script defer src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="SuperBear's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/videos/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">Java语言有哪些特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">什么是字节码？采用字节码的最大好处是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%EF%BC%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是Java程序的主类？应用程序和小程序的主类有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E9%82%A3%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Java应用程序与小程序之间有那些差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">Java和C++的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">6.3.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%B0%81%E8%A3%85%E6%A6%82%E8%BF%B0"><span class="toc-number">7.</span> <span class="toc-text">1）封装概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%B0%81%E8%A3%85%E5%8E%9F%E5%88%99"><span class="toc-number">8.</span> <span class="toc-text">2）封装原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%B0%81%E8%A3%85%E5%A5%BD%E5%A4%84"><span class="toc-number">9.</span> <span class="toc-text">3）封装好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">10.</span> <span class="toc-text">1）构造方法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.</span> <span class="toc-text">2）构造方法的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C"><span class="toc-number">12.</span> <span class="toc-text">3）标准类制作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">12.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">12.2.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%9F%BA%E7%A1%80"><span class="toc-number">13.</span> <span class="toc-text">JAVA基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.1.</span> <span class="toc-text">Java有哪些数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97-2-%E4%B9%98%E4%BB%A5-8"><span class="toc-number">13.2.</span> <span class="toc-text">用最有效率的方法计算 2 乘以 8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9FMath-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-number">13.3.</span> <span class="toc-text">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#float-f-3-4-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">13.4.</span> <span class="toc-text">float f&#x3D;3.4;是否正确</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E9%94%99%E5%90%97-short-s1-1-s1-1-%E6%9C%89%E9%94%99%E5%90%97"><span class="toc-number">13.5.</span> <span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">14.</span> <span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public-private-protected-%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.1.</span> <span class="toc-text">访问修饰符 public,private,protected,以及不写（默认）时的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">14.2.</span> <span class="toc-text">String，StringBuilder，StringBuffer的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E6%8B%BC%E6%8E%A5%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.</span> <span class="toc-text">String的拼接优化:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">14.4.</span> <span class="toc-text">Java支持的数据类型有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">14.5.</span> <span class="toc-text">什么是自动拆装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.6.</span> <span class="toc-text">int 和 Integer 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.7.</span> <span class="toc-text">&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">14.8.</span> <span class="toc-text">Java中如何跳出当前的多重嵌套循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8BJava%E5%92%8CJavaSciprt"><span class="toc-number">14.9.</span> <span class="toc-text">比较一下Java和JavaSciprt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.10.</span> <span class="toc-text">数组(Array)和列表(ArrayList)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">14.11.</span> <span class="toc-text">什么是值传递和引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B04-0-3-6-0-40000001%E8%BF%99%E7%A7%8D%E7%8E%B0%E8%B1%A1"><span class="toc-number">14.12.</span> <span class="toc-text">为什么会出现4.0-3.6&#x3D;0.40000001这种现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E7%9A%84"><span class="toc-number">14.13.</span> <span class="toc-text">十进制的数在内存中是怎么存的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">14.14.</span> <span class="toc-text">原码、反码和补码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E2%80%9C-%E2%80%9D%E6%AF%94%E8%BE%83%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">14.15.</span> <span class="toc-text">符号“&#x3D;&#x3D;”比较的是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">15.1.</span> <span class="toc-text">final关键字是怎么用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">this关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">15.3.</span> <span class="toc-text">super关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E4%B8%8Esuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.4.</span> <span class="toc-text">this与super的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E7%9A%84%E7%8B%AC%E7%89%B9%E4%B9%8B%E5%A4%84"><span class="toc-number">15.5.</span> <span class="toc-text">static的独特之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.6.</span> <span class="toc-text">static应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.7.</span> <span class="toc-text">static注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">16.</span> <span class="toc-text">流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#break-continue-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">break ,continue ,return 的区别及作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.1.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HashMap%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text">说说HashMap的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9"><span class="toc-number">18.1.</span> <span class="toc-text">如何扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4TreeNode%E6%98%AF%E6%80%8E%E4%B9%88put%E7%9A%84"><span class="toc-number">18.2.</span> <span class="toc-text">说TreeNode是怎么put的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95get"><span class="toc-number">18.3.</span> <span class="toc-text">如何get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">18.4.</span> <span class="toc-text">HashMap是线程安全的吗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81HashTable"><span class="toc-number">18.4.1.</span> <span class="toc-text">一、HashTable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SynchronizedMap"><span class="toc-number">18.4.2.</span> <span class="toc-text">二、SynchronizedMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81ConcurrentHashMap"><span class="toc-number">18.4.3.</span> <span class="toc-text">三、ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">18.5.</span> <span class="toc-text">红黑树</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/(%E8%AE%BE%E7%BD%AE%E9%A1%B6%E9%83%A8%E5%9B%BE))"><div id="winterBanner"><div class="view"><img class="morning" src="/bilibiliBanner/winter/bilibili-winter-view-1.png" alt=""><img class="afternoon" src="/bilibiliBanner/winter/bilibili-winter-view-2.png" alt=""><video class="evening" autoplay="" loop="" muted=""><source src="/bilibiliBanner/winter/bilibili-winter-view-3.webm" type="video/webm"></video><img class="window-cover" src="/bilibiliBanner/winter/bilibili-winter-view-3-snow.png" alt=""></div><div class="tree"><img class="morning" src="/bilibiliBanner/winter/bilibili-winter-tree-1.png" alt=""><img class="afternoon" src="/bilibiliBanner/winter/bilibili-winter-tree-2.png" alt=""><img class="evening" src="/bilibiliBanner/winter/bilibili-winter-tree-3.png" alt=""></div></div><script async data-pjax src="/js/bilibili-banner.js"></script><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SuperBear's blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/videos/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">JavaSE</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-03T10:57:37.000Z" title="发表于 2022-01-03 18:57:37">2022-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-21T05:19:47.244Z" title="更新于 2022-02-21 13:19:47">2022-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ul>
<li><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
</li>
<li><p>面向对象（封装，继承，多态）</p>
</li>
<li><p>平台无关性（Java虚拟机实现平台无关性）</p>
</li>
<li><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
</li>
<li><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
</li>
<li><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
</li>
<li><p>安全性</p>
</li>
</ul>
<h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p><strong>采用字节码的好处</strong>：</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p><strong>先看下java中的编译器和解释器</strong>：</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45676761/article/details/119683628?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_aa&spm=1001.2101.3001.4242.1&utm_relevant_index=3">Java面向对象思想以及三大特征之封装</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45676761/article/details/119852043?spm=1001.2014.3001.5502">Java面向对象三大特征之继承和多态</a></li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>对象概述</p>
<p>万物皆对象，<strong>客观存在</strong>的事物皆为对象。这里的客观存在指的是看得见摸得着的某个具体事物。比如，具体的某个人是一个对象；加菲猫是一个对象；哈士奇也是一个对象</p>
</li>
<li><p>对象的属性和行为</p>
<ul>
<li><p><strong>属性：</strong>对象具有的各种特征，每个对象的每个属性都拥有特定的值。比如某个人的姓名是张三，年龄是25，身高是170，体重是60……，姓名、年龄、身高、体重这些特征就是属性，张三、25、170、60这些就是属性的值。</p>
</li>
<li><p><strong>行为：</strong>对象能够执行的操作。比如加菲猫吃鱼，加菲猫是一个对象，吃鱼就是它的行为。</p>
</li>
</ul>
</li>
<li><p>面向对象</p>
<p>​       了解并关注对象的动作称为面向对象。意思就是我做一件事，我的关注重点不是放在做这件事的过程上，而是放在参与这件事的所有对象上。</p>
<p>​        比如，要把一只大象装进冰箱应该怎么做？相信很多读者应该都想到了：第一步打开冰箱，第二步把大象放进冰箱，第三步关上冰箱。这是<strong>面向过程</strong>的思想。我们现在换一个角度：把大象装进冰箱首先需要一只大象、一个冰箱、一个人，我们只需要指挥这个人把大象装进冰箱就可以了，这就是<strong>面向对象</strong>的思想。</p>
<p>​        大家注意到区别了吗，面向过程我们是执行者，而面向对象我们是指挥者。面向对象是我只要考虑做这件事需要哪些对象，而具体过程让这些对象去做。</p>
</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p>类的概述</p>
<p>类是对现实生活中一类具有共同属性和行为的事物的抽象。比如人类，人就是一个类；动物类，动物就是一个类。由此可见，类和对象的关系：类是具有共同属性和行为的对象的抽象。类是一个抽象概括，并不是实体。</p>
</li>
<li><p>类的特点</p>
<ol>
<li>类是对象的<strong>数据类型</strong>。我们之前在学习基础语法时提到过，类是引用数据类型。</li>
<li>类是具有相同属性和行为的一组对象的<strong>集合</strong>。类可以包含无数个对象，所以说类是对象的集合。</li>
</ol>
</li>
<li><p>类的定义</p>
<p>  类的重要性：是Java程序的基本组成单位。</p>
<p>  类的组成：<strong>属性</strong>和<strong>行为</strong></p>
<ul>
<li>属性：在类中通过成员变量来体现（类中方法外的变量）</li>
<li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li>
</ul>
</li>
</ul>
<p><strong>类的定义步骤：</strong></p>
<ol>
<li>定义类</li>
<li>编写类的成员变量</li>
<li>编写类的成员方法</li>
</ol>
   <img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210814183950436.png"/>

<ul>
<li><p>对象的使用</p>
<p> <img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210814185027838.png" alt="img"></p>
</li>
</ul>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol>
<li><p>private关键字</p>
<ul>
<li><p>是一个权限修饰符</p>
</li>
<li><p>可以修饰成员（成员变量和成员方法）</p>
</li>
<li><p>作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问</p>
<pre><code> 针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作：
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</p>
</li>
<li><p>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</p>
</li>
</ul>
<ol start="2">
<li><p>this关键字</p>
<ol>
<li><p>this 修饰的变量用于指代成员变量</p>
<ul>
<li><p>方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，而不是成员变量</p>
</li>
<li><p>方法的形参没有与成员变量同名，不带 this 修饰的变量指的是成员变量</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>什么时候使用 this 呢？解决局部变量隐藏成员变量</p>
</li>
<li><p>this：代表所在类的对象引用</p>
<ul>
<li>记住：<strong>方法被哪个对象调用，this 就代表哪个对象</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>封装</p>
<blockquote>
<h3 id="1）封装概述"><a href="#1）封装概述" class="headerlink" title="1）封装概述"></a>1）封装概述</h3><p>  是面向对象三大特征之一（封装，继承，多态）。</p>
<p>  是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的。</p>
<h3 id="2）封装原则"><a href="#2）封装原则" class="headerlink" title="2）封装原则"></a>2）封装原则</h3><p>  将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxx()/setXxx()方法</p>
<h3 id="3）封装好处"><a href="#3）封装好处" class="headerlink" title="3）封装好处"></a>3）封装好处</h3><p>  通过方法来控制成员变量的操作，提高了代码的安全性；把代码用方法进行封装，提高了代码的复用性。</p>
</blockquote>
</li>
<li><p>构造方法</p>
<blockquote>
<h3 id="1）构造方法概述"><a href="#1）构造方法概述" class="headerlink" title="1）构造方法概述"></a>1）构造方法概述</h3><p>  构造方法是一种特殊的方法</p>
<p>  作用：创建对象 </p>
<p>  <img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210814212251434.png" alt="img"></p>
<p>  功能：主要是完成对象数据的初始化</p>
<h3 id="2）构造方法的注意事项"><a href="#2）构造方法的注意事项" class="headerlink" title="2）构造方法的注意事项"></a>2）构造方法的注意事项</h3><p>  1.构造方法的创建</p>
<ul>
<li><p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</p>
</li>
<li><p>如果定义了构造方法，系统将不再提供默认的构造方法</p>
<p>2.构造方法的重载</p>
</li>
<li><p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p>
<p>3.推荐的使用方式</p>
</li>
<li><p>无论是否使用，都手工书写无参数构造方法</p>
</li>
</ul>
<h3 id="3）标准类制作"><a href="#3）标准类制作" class="headerlink" title="3）标准类制作"></a>3）标准类制作</h3><p>  <img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210814213418477.png" alt="img"></p>
</blockquote>
</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol>
<li><p>基本概述</p>
<ul>
<li><p>概念及格式</p>
<p>  <strong>概念</strong>：继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。（就像父亲和儿子，儿子继承父亲的一些特征，也拥有自己的一些独有的特征。）</p>
<p>  <strong>格式</strong>：public class 子类 extends 父类 { }<br>  <strong>范例</strong>：public class Zi extends Fu { }<br>  父类也被称为基类、超类。子类也被称为派生类。</p>
<p>  <strong>子类的特点：</strong>子类可以有父类的内容，子类还可以有自己特有的内容。</p>
</li>
<li><p>继承的好处和弊端</p>
<ul>
<li> 好处：</li>
</ul>
<ul>
<li><p>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</p>
</li>
<li><p>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)</p>
</li>
</ul>
<ul>
<li>弊端：继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。</li>
</ul>
</li>
<li><p>继承的应用场景</p>
<p> 使用继承，需要考虑类与类之间是否存在 is..a 的关系，不能盲目使用继承。<br>  is..a 的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类。</p>
</li>
</ul>
</li>
<li><p>继承中的成员访问特点</p>
<ul>
<li><p>继承中变量的访问特点</p>
<p>在子类方法中访问一个变量，采用的是就近原则。</p>
<ol>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
</li>
<li><p>继承中构造方法的访问特点</p>
<p> 子类中所有的构造方法默认都会访问父类中无参的构造方法。<br>  原因：</p>
<ol>
<li>子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化</li>
<li>每一个子类构造方法的第一条语句默认都是：super()</li>
</ol>
<p>  如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</p>
<ul>
<li><p>通过使用 super 关键字去显示的调用父类的带参构造方法</p>
</li>
<li><p>在父类中自己提供一个无参构造方法</p>
<p>推荐：自己给出无参构造方法</p>
</li>
</ul>
</li>
<li><p>继承中成员方法的访问特点</p>
<p>通过子类对象访问一个方法</p>
<ol>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
</li>
<li><p>super关键字</p>
<p> <strong>this</strong>：代表本类对象的引用</p>
<p>  <strong>super</strong>：代表父类存储空间的标识(可以理解为父类对象引用)</p>
<p>  this 和 super 的使用区别:</p>
<p><img src="https://img-blog.csdnimg.cn/20210822154309273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3Njc2MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>  super内存图：</p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210822154602987.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>方法重写</p>
<ul>
<li><p>方法重写概述</p>
<p>  概念：子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）。</p>
<p>  应用场景：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</p>
<p>  Override 注解：@Override用来检测当前的方法，是否是重写的方法，起到【校验】的作用。</p>
</li>
<li><p>方法重写注意事项</p>
<ol>
<li>私有方法不能被重写(父类私有成员子类是不能继承的)</li>
<li>子类方法访问权限不能更低(public &gt; 默认 &gt; 私有)</li>
</ol>
</li>
</ul>
</li>
<li><p>Java 中继承的注意事项</p>
<ol>
<li>Java 中类<strong>只支持单继承</strong>，不支持多继承</li>
</ol>
<p>  错误范例：class A extends B, C { }</p>
<ol start="2">
<li>Java 中类支持<strong>多层</strong>继承</li>
</ol>
<p>  正确范例：</p>
<pre><code>class A &#123;&#125;  
class B extends A&#123; &#125;  
class C extends B&#123; &#125;
</code></pre>
</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ol>
<li>多态概述<ul>
<li>什么是多态？<pre><code> 同一个对象，在不同时刻表现出来的不同形态。
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">猫 cat = new 猫();</span><br><span class="line">动物 animal = new 猫();</span><br></pre></td></tr></table></figure>

<ul>
<li>多态的前提条件有哪些？<ul>
<li>要有继承/实现关系</li>
<li>要有方法重写</li>
<li>要有父类/接口引用指向子类/实现类对象</li>
</ul>
</li>
</ul>
<ol start="2">
<li>多态中成员访问特点</li>
</ol>
<blockquote>
<p> <strong>1）多态中成员变量的访问特点是什么?</strong><br>     编译看左边、运行看左边</p>
<p>​    比如，动物 animal = new 猫(); “编译看左边”的意思是编译时看语句左边的动物类（父类）里有没有这个变量，“运行看左边”的意思是运行时也是获取动物类（父类）里的这个变量。<br> <strong>2）多态中成员方法的访问特点是什么?</strong><br>​    编译看左边、运行看右边</p>
<p>​    比如，动物 animal = new 猫(); “编译看左边”的意思是编译时看语句左边的动物类（父类）里有没有这个方法，“运行看右边”的意思是运行时实际执行的是猫类（子类）里的重写的方法。</p>
</blockquote>
<ol start="3">
<li><p>多态的好处和弊端</p>
<p>   多态的<strong>好处</strong>：提高了程序的扩展性。</p>
<pre><code>   具体体现：定义方法时，如果将父类型作为参数，在使用方法时，可以传递任        意子类对象。
</code></pre>
<p>   多态的<strong>弊端</strong>：不能使用子类特有的成员。</p>
</li>
<li><p>多态中的转型</p>
</li>
</ol>
<blockquote>
<p><strong>1）多态中的向上转型</strong><br>     父类引用指向子类对象其实就是向上转型。例如：<br>     Animal a = new Dog();</p>
<p> <strong>2）多态中的向下转型</strong><br>     将父类型的引用转换成具体的子类对象。转换格式：<br>     子类 对象名 = (子类)父类引用;</p>
<p> 向下转型解决了多态的弊端。</p>
<p> <strong>3）多态转型内存图解</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210822173515729.png" alt="img"></p>
<p> 狗强制转换成猫会出现 ClassCastException（类型转换异常）。</p>
</blockquote>
<h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类</strong></p>
<ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220221102641236.png" alt="image-20220221102641236"></p>
<h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。(在java里面，没小数点的默认是int,有小数点的默认是 double;)</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
<p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<p><strong>分类</strong></p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p><strong>访问修饰符图</strong></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220221104721423.png" alt="image-20220221104721423"></p>
<h4 id="String，StringBuilder，StringBuffer的区别："><a href="#String，StringBuilder，StringBuffer的区别：" class="headerlink" title="String，StringBuilder，StringBuffer的区别："></a>String，StringBuilder，StringBuffer的区别：</h4><ol>
<li><p>操作数量较少的字符串用<strong>String，不可修改</strong>的字符串；</p>
<p>String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象。在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢。如下String的拼接优化。</p>
</li>
<li><p>在单线程且操作大量字符串用<strong>StringBuilder</strong>,<strong>速度快</strong>，但<strong>线程不安全，可修改</strong>；</p>
</li>
<li><p>在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改</strong>。</p>
<p>使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况</p>
</li>
</ol>
<h4 id="String的拼接优化"><a href="#String的拼接优化" class="headerlink" title="String的拼接优化:"></a>String的拼接优化:</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = s1 + s2;</span><br><span class="line">java实际运行时优化为</span><br><span class="line">String s = new StringBuilder(s1).append(s2).toString();</span><br></pre></td></tr></table></figure>

<h4 id="Java支持的数据类型有哪些"><a href="#Java支持的数据类型有哪些" class="headerlink" title="Java支持的数据类型有哪些"></a>Java支持的数据类型有哪些</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br></pre></td></tr></table></figure>

<h4 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱</span><br></pre></td></tr></table></figure>

<h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Int是java的原始数据类型，Integer是java为int提供的封装类。</span><br><span class="line">Java为每个原始类型提供了封装类。</span><br><span class="line">原始类型封装类</span><br><span class="line">booleanBoolean</span><br><span class="line">charCharacter</span><br><span class="line">byteByte</span><br><span class="line">shortShort</span><br><span class="line">intInteger</span><br><span class="line">longLong</span><br><span class="line">floatFloat</span><br><span class="line">doubleDouble</span><br></pre></td></tr></table></figure>

<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</span><br></pre></td></tr></table></figure>

<h4 id="Java中如何跳出当前的多重嵌套循环"><a href="#Java中如何跳出当前的多重嵌套循环" class="headerlink" title="Java中如何跳出当前的多重嵌套循环"></a>Java中如何跳出当前的多重嵌套循环</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</span><br></pre></td></tr></table></figure>

<h4 id="比较一下Java和JavaSciprt"><a href="#比较一下Java和JavaSciprt" class="headerlink" title="比较一下Java和JavaSciprt"></a>比较一下Java和JavaSciprt</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。</span><br><span class="line">下面对两种语言间的异同作如下比较：</span><br><span class="line">- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</span><br><span class="line">- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）</span><br><span class="line">- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</span><br><span class="line">- 代码格式不一样</span><br></pre></td></tr></table></figure>

<h4 id="数组-Array-和列表-ArrayList-的区别"><a href="#数组-Array-和列表-ArrayList-的区别" class="headerlink" title="数组(Array)和列表(ArrayList)的区别"></a>数组(Array)和列表(ArrayList)的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array和ArrayList的不同点：</span><br><span class="line">Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</span><br><span class="line">Array大小是固定的，ArrayList的大小是动态变化的。</span><br><span class="line">ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</span><br><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></table></figure>

<h4 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</span><br><span class="line">引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递</span><br></pre></td></tr></table></figure>

<h4 id="为什么会出现4-0-3-6-0-40000001这种现象"><a href="#为什么会出现4-0-3-6-0-40000001这种现象" class="headerlink" title="为什么会出现4.0-3.6=0.40000001这种现象"></a>为什么会出现4.0-3.6=0.40000001这种现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</span><br><span class="line">出现0.40000001的情况可以使用BigDecimal类解决，其实浮点数基本上都不精确，BigDecimal使用String来解决的</span><br></pre></td></tr></table></figure>

<h4 id="十进制的数在内存中是怎么存的"><a href="#十进制的数在内存中是怎么存的" class="headerlink" title="十进制的数在内存中是怎么存的"></a>十进制的数在内存中是怎么存的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码的形式。把一个十进制转换为二进制的方法是：把被转换的十进制数反复地除以 2，直到商为 0 为止，所得余数（从末位读起）就是这个数的二进制表示，简单地说，就是 &quot;除 2 取余法&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151652729.png" alt="image-20211125151652729"></p>
<p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151705033.png" alt="image-20211125151705033"></p>
<h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原码：是一种计算机中对数字的二进制定点表示法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为 0，负数该位为 1</span><br><span class="line"></span><br><span class="line">反码：一个数字用原码表示是容易理解的，但是需要单独一个位来表示符号位，并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是让符号位参与运算。要实现这个功能，我们就要用到反码。</span><br><span class="line">对于单个数值（二进制的 0 和 1）而言，对其进行取反操作就是将 0 变为 1，1 变为 0。正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。</span><br><span class="line"></span><br><span class="line">补码：补码是一种用二进制表示有符号数的方法。正数和 0 的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加 1。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式</span><br><span class="line">只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路和补码电路即可以完成各种有符号数加法和减法，在电路设计上相当方便。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">原码</th>
<th align="center">反码</th>
<th align="center">补码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">6</td>
<td align="center">0000 0110</td>
<td align="center">0000 0110</td>
<td align="center">0000 0110</td>
</tr>
<tr>
<td align="center">-3</td>
<td align="center">1000 0011</td>
<td align="center">1111 1100</td>
<td align="center">1111 1101</td>
</tr>
</tbody></table>
<h4 id="符号“-”比较的是什么"><a href="#符号“-”比较的是什么" class="headerlink" title="符号“==”比较的是什么"></a>符号“==”比较的是什么</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。</span><br></pre></td></tr></table></figure>



<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final关键字是怎么用的"><a href="#final关键字是怎么用的" class="headerlink" title="final关键字是怎么用的"></a>final关键字是怎么用的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</span><br><span class="line"></span><br><span class="line">对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</span><br></pre></td></tr></table></figure>

<h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>this的用法在java中大体可以分为3种：</p>
<p>1.普通的直接引用，this相当于是指向当前对象本身。</p>
<p>2.形参与成员名字重名，用this来区分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>3.引用本类的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
<p>3.引用父类构造函数</p>
<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
<h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul>
<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
<h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</p>
<blockquote>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p>
</blockquote>
<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p>
<p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</p>
<p>因此比较常见的static应用场景有：</p>
<blockquote>
<p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p>
</blockquote>
<h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p><strong>面向过程</strong>：</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p><strong>面向对象</strong>：</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p><strong>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</strong></p>
<p><strong>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</strong></p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了</p>
<h3 id="说说HashMap的原理"><a href="#说说HashMap的原理" class="headerlink" title="说说HashMap的原理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/woshimrf/p/hashmap.html">说说HashMap的原理</a></h3><blockquote>
<p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
</blockquote>
<p>答：HashMap是通过哈希表的数组链表实现的。内部维护一个Node数组，当put时，计算key hash后的值当做索引。如果数组中该位置为null，则放入value。然后判断是否需要扩容，返回null。如果数组上已经有元素，判断hash和key是否相等，相等就表示找到node节点了，不相等则判断该元素是TreeNode还是普通Node。如果是TreeNode，则按照TreeNode的put方法插入。如果不是TreeNode, 遍历链表，对比hash和key，若都不相等，则插入队尾，如果链表长度大于等于8，将链表转换为TreeNode。找到node之后，node不为null则赋值value。最后返回原来的value。</p>
<h4 id="如何扩容"><a href="#如何扩容" class="headerlink" title="如何扩容"></a>如何扩容</h4><p>答：(直接说1.8的内容，想要装逼体验深度就对比1.7. 比如1.7扩容会导致链表重排倒置，1.8不会，1.8不用再次计算hash等。当然，这样回答要准备好继续入坑，为什么，如何做到)</p>
<p>要说扩容，首先要知道原来的容量以及什么时候扩容。HashMap初始化的时候可以指定<code>initialCapacity</code>和<code>loadfactor</code>。<code>capacity</code>是2的指数倍，表示数组的长度。</p>
<p><code>loadfactor</code>表示达到容量的百分比后扩容。<code>threshold=capacity*loadfactor</code>就是HashMap对象中可以容纳的最大K-V键值对数量。</p>
<p>所以，当size(当前K-V键值对数量)超过<code>threshold</code>，则进行扩容。当然，如果capacity已经大于2^30，则直接将<code>threshold=Integer.MAX_VALUE</code>, 就不扩容了，碰撞吧。</p>
<p>扩容的时候先计算容量，扩大为原来的2倍，对应<code>threshold</code>也扩大为原来的2倍。</p>
<p>然后将原来数组上的元素复制到新的数组。对于冲突碰撞的结点，是TreeNode则按TreeNode插入，不是TreeNode则将链表的一半平分到其他新增的索引位置。</p>
<p>关于几个数字。<code>loadfactor=0.75; DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; MAXIMUM_CAPACITY = 1 &lt;&lt; 30; TREEIFY_THRESHOLD = 8</code>。也就是说，对于我们平时直接new 的HashMap对象，默认数组长度为16，最大容纳12个，超过12个则扩容；当发生碰撞的数量小于8个则维护链表，当数量大于8个则改造成TreeNode.</p>
<h4 id="说TreeNode是怎么put的"><a href="#说TreeNode是怎么put的" class="headerlink" title="说TreeNode是怎么put的"></a>说TreeNode是怎么put的</h4><p>红黑树</p>
<h4 id="如何get"><a href="#如何get" class="headerlink" title="如何get"></a>如何get</h4><p>答： 既然知道HashMap的存储原理，那个get也就呼之欲出了。 首先，计算hash索引，如果头结点不为null，如果头结点hash以及key都相等，则取出。</p>
<p>如果头结点不相等，并且next不为nul，判断next是否是TreeNode, 如果是TreeNode则TreeNode get.</p>
<p>如果不是TreeNode, 遍历链表，找到hash和key相等的取出value。</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>答：不是，高并发中不仅会不安全，还有可能造成死循环(扩容的时候)。想要在并发中使用<strong>，请使用ConcurrentHashMap.</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bc2d81a3f7f"><strong>实现线程安全的方式有三种</strong>，分别是使用<strong>HashTable</strong>、<strong>Collections.SynchronizeMap</strong>、<strong>ConcurrentHashMap</strong>。</a></p>
<h5 id="一、HashTable"><a href="#一、HashTable" class="headerlink" title="一、HashTable"></a>一、HashTable</h5><p>Hashtable 源码中是使用 synchronized 来保证线程安全的，比如下面的 get 方法和 put 等方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123; ... &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以当一个线程访问 HashTable 的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。因此Hashtable效率很低，基本被废弃。。</p>
<h5 id="二、SynchronizedMap"><a href="#二、SynchronizedMap" class="headerlink" title="二、SynchronizedMap"></a>二、SynchronizedMap</h5><p>SynchronizedMap是Collectionis的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>

<p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。效率还是硬伤。</p>
<h5 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a>三、ConcurrentHashMap</h5><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问,极大提升了效率。相关源码敬请期待！</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>参考： </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuyapeng/p/13750644.html">https://www.cnblogs.com/zhuyapeng/p/13750644.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gofighting/p/5437998.html">https://www.cnblogs.com/gofighting/p/5437998.html</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/12/02/redblack-tree.html">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></li>
</ul>
<p>红黑树:二叉树+高度限制<br>二叉树：确定了它的查找非常快。<br>高度限制：这个是取普通二叉树和平衡二叉树之间。<br>普通二叉树，只管插入不做调整，可能会出现单链很长。<br>平衡二叉树，所有的链高度相等，但存就需要调整，非常耗时。<br>红黑树，最长单链不会超过最短单链2倍，这样也确定它存的耗时也居中。</p>
<p>红黑树特点5条：<br>1.所有节点非红即黑。<br>2.根节点为黑节点。<br>3.所有叶子节（null）点为黑色。<br>4.所有节点到叶子节点中黑色节点数目相同。（确定最长单链不会超过最短单链2倍）<br>5.如果一个节点为红色，则它的子节点节点必须为黑色。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点</p>
<p>红黑树的操作：<br>查：二叉树的特性决定它高效。<br>增：加入红节点，根据旋转、着色来保持红黑树特性。<br>删：根据旋转、着色来保持红黑树特性。</p>
<p><strong>红黑树相关定理</strong></p>
<p><strong>1. 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></p>
<p>   根据上面的性质5我们知道上图的红黑树每条路径上都是3个黑结点。因此最短路径长度为2(没有红结点的路径)。再根据性质4(两个红结点不能相连)和性质1，2(叶子和根必须是黑结点)。那么我们可以得出：一条具有3个黑结点的路径上最多只能有2个红结点(红黑间隔存在)。也就是说黑深度为2（根结点也是黑色）的红黑树最长路径为4，最短路径为2。从这一点我们可以看出红黑树是 大致平衡的。 (当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p>
<p><strong>2. 红黑的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></p>
<p>   根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;=2bd。</p>
<p><strong>3. 一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></p>
<p>   下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;=2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h=0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;=2^0-1成立。假设树高h&lt;=t时，n&gt;=2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;=t，于是有nl&gt;=2^bd’-1以及nr&gt;=2^bd’-1，将这两个不等式相加有nl+nr&gt;=2^(bd’+1)-2，将该不等式左右加1，得到n&gt;=2^(bd’+1)-1，很显然bd’+1&gt;=bd，于是前面的不等式可以 变为n&gt;=2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;=2^bd-1。</p>
<p>​    在根据定理2，h&lt;=2bd。即n&gt;=2^(h/2)-1，那么h&lt;=2log(n+1)</p>
<p>​    从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p>
<p><strong>红黑树的操作</strong></p>
<p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，在红黑树上进行插入操作和删除操作会导致不 再符合红黑树的性质。恢复红黑树的属性需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。 虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次 。</p>
<p><strong>红黑树的优势</strong></p>
<p>红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。</p>
<p>而且实际应用中，很多语言都实现了红黑树的数据结构。比如 TreeMap, TreeSet(Java )、 STL(C++)等。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SuperBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/">https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sssuper-bear.github.io" target="_blank">SuperBear's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img2.huashi6.com/images/resource/2019/05/14/747234h06p0.jpg?imageMogr2/quality/75/interlace/1/thumbnail/700x%3E/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%86%85%E6%A0%B8/"><img class="prev-cover" src="https://img2.huashi6.com/images/resource/2019/10/13/772657h50p0.jpg?imageMogr2/quality/75/interlace/1/thumbnail/700x%3E/format/webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内核</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%80%9D%E7%BB%B4%E5%8F%91%E6%95%A3/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">思维发散</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By SuperBear</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/sSsuper-Bear"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a></p></div><div id="workboard"></div><script async="async" src="/js/runtime.js"></script></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'Fg783sRWVmsp38mbk5aoRuUa-gzGzoHsz',
      appKey: '6gcVwkjI0xDpUrjttJYRV8BH',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      master: 'E87E352DFDC19E444DAB2914B4952849'.split(','),
      friends: 'B923A10A9B7378EF516A1E15A6C77034'.split(','),
      tagMeta: '博主,小伙伴,访客'.split(',')
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><link rel="stylesheet" href="/"><script src="/"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

const pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
})

document.addEventListener('pjax:complete', function () {
  refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

})

document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

  //reset font-size
  $('body').css('font-size') !== originFontSize && $('body').css('font-size', parseFloat(originFontSize))
})</script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>