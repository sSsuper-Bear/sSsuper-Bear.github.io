<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuperBear&#39;s blog</title>
  
  
  <link href="https://sssuper-bear.github.io/atom.xml" rel="self"/>
  
  <link href="https://sssuper-bear.github.io/"/>
  <updated>2022-03-03T07:25:02.719Z</updated>
  <id>https://sssuper-bear.github.io/</id>
  
  <author>
    <name>SuperBear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://sssuper-bear.github.io/2022/03/03/%E9%9D%A2%E8%AF%95/Untitled/"/>
    <id>https://sssuper-bear.github.io/2022/03/03/%E9%9D%A2%E8%AF%95/Untitled/</id>
    <published>2022-03-03T07:25:02.719Z</published>
    <updated>2022-03-03T07:25:02.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Matplotlib绘图技巧</title>
    <link href="https://sssuper-bear.github.io/2022/02/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Matplotlib%E7%BB%98%E5%9B%BE%E6%8A%80%E5%B7%A7/"/>
    <id>https://sssuper-bear.github.io/2022/02/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Matplotlib%E7%BB%98%E5%9B%BE%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-12T12:13:16.000Z</published>
    <updated>2022-03-02T08:44:02.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Matplotlib绘图技巧"><a href="#Matplotlib绘图技巧" class="headerlink" title="Matplotlib绘图技巧"></a>Matplotlib绘图技巧</h1><h2 id="x轴y轴有小数"><a href="#x轴y轴有小数" class="headerlink" title="x轴y轴有小数"></a><a href="https://blog.csdn.net/qq_36170511/article/details/115525728">x轴y轴有小数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MaxNLocator</span><br><span class="line">plt.gca().xaxis.set_major_locator(MaxNLocator(integer=<span class="literal">True</span>))</span><br><span class="line">plt.gca().yaxis.set_major_locator(MaxNLocator(integer=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h2 id="Python中Matplotlib的点（绘制散点图）"><a href="#Python中Matplotlib的点（绘制散点图）" class="headerlink" title="Python中Matplotlib的点（绘制散点图）"></a><a href="https://blog.csdn.net/hesongzefairy/article/details/113527780">Python中Matplotlib的点（绘制散点图）</a></h2><ul><li>常用标记点形状：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">‘.’：点(point marker)</span><br><span class="line">‘,’：像素点(pixel marker)</span><br><span class="line">‘o’：圆形(circle marker)</span><br><span class="line">‘v’：朝下三角形(triangle_down marker)</span><br><span class="line">‘^’：朝上三角形(triangle_up marker)</span><br><span class="line">‘&lt;‘：朝左三角形(triangle_left marker)</span><br><span class="line">‘&gt;’：朝右三角形(triangle_right marker)</span><br><span class="line">‘1’：(tri_down marker)</span><br><span class="line">‘2’：(tri_up marker)</span><br><span class="line">‘3’：(tri_left marker)</span><br><span class="line">‘4’：(tri_right marker)</span><br><span class="line">‘s’：正方形(square marker)</span><br><span class="line">‘p’：五边星(pentagon marker)</span><br><span class="line">‘*’：星型(star marker)</span><br><span class="line">‘h’：1号六角形(hexagon1 marker)</span><br><span class="line">‘H’：2号六角形(hexagon2 marker)</span><br><span class="line">‘+’：+号标记(plus marker)</span><br><span class="line">‘x’：x号标记(x marker)</span><br><span class="line">‘D’：菱形(diamond marker)</span><br><span class="line">‘d’：小型菱形(thin_diamond marker)</span><br><span class="line">‘|’：垂直线形(vline marker)</span><br><span class="line">‘_’：水平线形(hline marker)</span><br></pre></td></tr></table></figure><ul><li>常用线形：linestyle</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">‘-‘：实线(solid line style)</span><br><span class="line"></span><br><span class="line">‘–-‘：虚线(dashed line style)</span><br><span class="line"></span><br><span class="line">‘-.’：点划线(dash-dot line style)</span><br><span class="line"></span><br><span class="line">‘:’：点线(dotted line style)</span><br></pre></td></tr></table></figure><ul><li>常用颜色：color</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;b&#x27;</span>          蓝色</span><br><span class="line"><span class="string">&#x27;g&#x27;</span>          绿色</span><br><span class="line"><span class="string">&#x27;r&#x27;</span>          红色</span><br><span class="line"><span class="string">&#x27;c&#x27;</span>          青色</span><br><span class="line"><span class="string">&#x27;m&#x27;</span>          品红</span><br><span class="line"><span class="string">&#x27;y&#x27;</span>          黄色</span><br><span class="line"><span class="string">&#x27;k&#x27;</span>          黑色</span><br><span class="line"><span class="string">&#x27;w&#x27;</span>          白色</span><br></pre></td></tr></table></figure><ul><li>更多颜色：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, marker=<span class="string">&#x27;+&#x27;</span>, color=<span class="string">&#x27;coral&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/20210201194636191.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一些简单题</title>
    <link href="https://sssuper-bear.github.io/2022/01/23/%E5%88%B7%E9%A2%98/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E9%A2%98/"/>
    <id>https://sssuper-bear.github.io/2022/01/23/%E5%88%B7%E9%A2%98/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E9%A2%98/</id>
    <published>2022-01-23T09:38:08.000Z</published>
    <updated>2022-01-24T11:25:04.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="NC120-二进制中1的个数"><a href="#NC120-二进制中1的个数" class="headerlink" title="NC120 二进制中1的个数"></a>NC120 二进制中1的个数</h3><p><strong>描述</strong></p><p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><p>数据范围：- 2^{31} &lt;= n &lt;= 2^{31}-1−231&lt;=<em>n</em>&lt;=231−1</p><p>即范围为:-2147483648&lt;= n &lt;= 2147483647−2147483648&lt;=<em>n</em>&lt;=2147483647</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">十进制中10的32位二进制表示为0000 0000 0000 0000 0000 0000 0000 1010，其中有两个1。       </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负数使用补码表示 ，-1的32位二进制表示为1111 1111 1111 1111 1111 1111 1111 1111，其中32个1    </span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>计算机中存储数据都是补码的形式</li><li>正数的反码和补码是它本身</li><li>负数的反码是除符号位外的相反数，补码是反码加一</li><li>补码为反码+1</li><li>负数在计算机中存储形式为补码</li><li>负数右移符号位补1</li><li>采用与位左移代替数字右移</li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) ans++;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NC107-寻找峰值"><a href="#NC107-寻找峰值" class="headerlink" title="NC107 寻找峰值"></a>NC107 寻找峰值</h3><p><strong>描述</strong></p><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p><p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p><p>2.假设 nums[-1] = nums[n] = -\infty−∞</p><p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1]</p><p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p><p>数据范围：</p><p>1 \le nums.length \le 2\times 10^5 \1≤<em>n<strong>u</strong>m**s</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>≤2×105 </p><p>-2^{31}&lt;= nums[i] &lt;= 2^{31} - 1−231&lt;=<em>n<strong>u</strong>m**s</em>[<em>i</em>]&lt;=231−1</p><p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,4,1,2,7,8,4]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4和8都是峰值元素，返回4的索引1或者8的索引5都可以     </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,1]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 是峰值元素，返回其索引 2    </span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>注意第一位和最后一位</li><li>当前位比前一位小就说明前一位为峰值</li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; tmp) <span class="keyword">return</span> (i-<span class="number">1</span>);</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>论文添加引用标签</title>
    <link href="https://sssuper-bear.github.io/2022/01/15/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%AE%BA%E6%96%87%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <id>https://sssuper-bear.github.io/2022/01/15/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%AE%BA%E6%96%87%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%E6%A0%87%E7%AD%BE/</id>
    <published>2022-01-15T12:57:30.000Z</published>
    <updated>2022-01-16T02:17:38.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文添加引用标签"><a href="#论文添加引用标签" class="headerlink" title="论文添加引用标签"></a>论文添加引用标签</h1><h2 id="设置引用序号"><a href="#设置引用序号" class="headerlink" title="设置引用序号"></a>设置引用序号</h2><ol><li>References中选中引用的文章</li></ol><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111622025.png" alt="image-20220114111622025"></p><ol start="2"><li><p>定义新编号格式</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111650945.png" alt="image-20220114111650945"></p></li><li><p>在编号格式中选择文献引用序号[1]</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114111757233.png" alt="image-20220114111757233"></p><h2 id="序号引用插入文章中"><a href="#序号引用插入文章中" class="headerlink" title="序号引用插入文章中"></a>序号引用插入文章中</h2><ol><li>鼠标插入要引用的位置</li><li>点击插入——交叉引用</li><li>选择你引用的文章编号</li></ol></li></ol><p>​            <img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114112057170.png" alt="image-20220114112057170"></p><h2 id="更新序号"><a href="#更新序号" class="headerlink" title="更新序号"></a>更新序号</h2><ul><li><p>右键需要更新的序号点击更新域</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220114112201454.png" alt="image-20220114112201454"></p></li><li><p>对所有引用更新</p><ul><li>ctrl+a全选文章</li><li>按F9快捷更新</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/fandroid/article/details/42060883?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&utm_relevant_index=2">word中自动生成参考文献引用及自动更新文献编号</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sssuper-bear.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://sssuper-bear.github.io/2022/01/08/%E5%88%B7%E9%A2%98/%E9%80%92%E5%BD%92/"/>
    <id>https://sssuper-bear.github.io/2022/01/08/%E5%88%B7%E9%A2%98/%E9%80%92%E5%BD%92/</id>
    <published>2022-01-08T02:37:23.000Z</published>
    <updated>2022-01-24T11:24:34.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NC68-跳台阶"><a href="#NC68-跳台阶" class="headerlink" title="NC68 跳台阶"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&&tqId=38622&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC68 跳台阶</a></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>数据范围：0≤<em>n</em>≤40</p><p>要求：时间复杂度：$O(n)$ ，空间复杂度： $O(1)$</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2     </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>你可以想如果青蛙当前在第n级台阶上，那它上一步是在哪里呢？</li><li>显然，由于它可以跳1级台阶或者2级台阶，所以<strong>它上一步必定在第n-1,或者第n-2级台阶</strong>，也就是说<strong>它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和</strong>。</li><li>设跳上 $i$级台阶有 $f(n)$ 种跳法，则它跳上n级的台阶有$f(n)=f(n-1)+f(n-2)$种跳法。</li></ul><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            c = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="https://sssuper-bear.github.io/2022/01/07/%E5%88%B7%E9%A2%98/%E5%A0%86%E6%A0%88/"/>
    <id>https://sssuper-bear.github.io/2022/01/07/%E5%88%B7%E9%A2%98/%E5%A0%86%E6%A0%88/</id>
    <published>2022-01-07T02:37:23.000Z</published>
    <updated>2022-01-30T12:51:23.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="NC76-用两个栈实现队列"><a href="#NC76-用两个栈实现队列" class="headerlink" title="NC76 用两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&&tqId=38552&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC76 用两个栈实现队列</a></h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p><p>数据范围： n\le1000<em>n</em>≤1000</p><p>要求：存储n个元素的空间复杂度为 O(n)<em>O</em>(<em>n</em>) ，插入与删除的时间复杂度都是 O(1)<em>O</em>(1)</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;PSH1&quot;:代表将1插入队列尾部</span><br><span class="line">&quot;PSH2&quot;:代表将2插入队列尾部</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回1</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回2   </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,1</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>push操作就直接往stack1中push</li><li>pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据<strong>全部</strong>转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</li></ul><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty() &amp;&amp; stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NC52-有效括号序列"><a href="#NC52-有效括号序列" class="headerlink" title="NC52 有效括号序列"></a>NC52 有效括号序列</h3><p><strong>描述</strong></p><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p><p>数据范围：字符串长度 0\le n \le 100000≤<em>n</em>≤10000</p><p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[&quot;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[]&quot;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>先进后出的话hashMap不好解决</li><li>利用栈的先后进先出</li><li>每次匹配左半边括号push右半边</li><li>匹配右半边括号pop</li><li>为空或者匹配不等于最近push进去的值则退出</li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2022-01-03T12:50:20.000Z</published>
    <updated>2022-01-07T02:00:25.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a><a href="https://www.cnblogs.com/lonely-wolf/p/15674526.html">时间复杂度与空间复杂度</a></h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="O-1-常数阶"><a href="#O-1-常数阶" class="headerlink" title="O(1) 常数阶"></a>O(1) 常数阶</h3><p>0(1) 复杂度算法也称之为常数阶算法。这里的 <code>1</code> 是用来代指常量，也就是说这个算法的效率是固定的，无论你的数据量如何变化，效率都一样，这种复杂度也是最优的一种算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中不论有多少行代码，时间复杂度都是属于常数阶。换言之：只要代码不存在<strong>循环</strong>，<strong>递归</strong>等循环类调用，不论代码有多少行，其复杂度都是常数阶</p><h3 id="O-n-线性阶"><a href="#O-n-线性阶" class="headerlink" title="O(n) 线性阶"></a>O(n) 线性阶</h3><p><code>O(n)</code> 复杂度算法也称之为线性阶。比如下面这个示例我们应该怎么分析复杂度呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面常量阶没分析是因为常量阶比较容易理解，接下来我们就以线性阶这个为例子来分析下具体是怎么得到的。</p><p>我们假设每一行代码的执行时间是 <code>T</code>，那么上面这段代码的执行复杂度是多少呢？</p><p>答案很明显，那就是 <code>T+n*T</code>，也就是 <code>(n+1)T</code>，而在算法中有一个原则，那就是常量可以被忽略，所以就得到了 <code>nT</code>，换成大 <code>O</code> 表示法就是 <code>O(n)</code>。</p><p>这只是一个简略的计算过程，大家也不用较真说每行代码执行时间可能不一样之类的，也不要较真说 <code>for</code> 循环占用了一行，下面的大括号也占用了一行，如果要较真这个，那我建议可以去想一下 <code>1=1</code> 为什么等于 <code>2</code>。</p><p>算法中的复杂度反应的只是一个趋势，这里 <code>O(n)</code> 反应的就是一个趋势，也就是随着 <code>n</code> 的变化，算法的执行时间是会降低的。</p><h3 id="O-n²-平方阶"><a href="#O-n²-平方阶" class="headerlink" title="O(n²) 平方阶"></a>O(n²) 平方阶</h3><p>知道了上面的线性阶，那么平方阶就很好理解了，双层循环就是平方阶，同理，三次循环就是立方阶，<code>k</code> 次循环就是 <code>k</code> 次方阶。</p><h3 id="O-logn-对数阶"><a href="#O-logn-对数阶" class="headerlink" title="O(logn) 对数阶"></a>O(logn) 对数阶</h3><p><code>O(logn)</code> 也称之为对数阶，对数阶也很常见，像二分查找，二叉树之类的问题中会见到比较多的对数阶复杂度，但是对数阶也是比较难理解的一种算法复杂度。</p><p>下面我们还是来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码又该如何分析复杂度呢？这段代码最关键就是要分析出 <code>while</code> 循环中到底循环了多少次，我们观察这个循环，发现 <code>i</code> 并不是逐一递增，而是不断的翻倍：<code>1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;32-&gt;64</code> 一直到等于 <code>n</code> 为止才会结束，所以我们得到了这样的一个公式：<code>2^x=n</code>。</p><p>也就是我们只要计算出 <code>x</code> 的值，就得到了循环次数，而根据高中的数学知识我们可以得到 <strong>x=log<sub>2</sub>n</strong>，所以根据上面线性阶的分析方法，我们省略常量，就得到了示例中的算法复杂度为 <code>O(log2n)</code>。</p><p>同样的分析方式，下面的例子，我们可以很快的分析出复杂度就为 <code>O(log3n)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面得到的 <code>log3n</code> 我们可以再做进一步的转换：<code>log3n=log32 * log2n</code>，而 <code>log32</code>（注意这几个地方的 <code>3</code> 是底数，在下面） 是一个常量，常量可以省略，所以也就得到了：<code>O(log3n)=O(log2n)</code>。同样的道理，不论底数是多少，其实最终都可以转化成和 <code>O(log2n)</code> 相等，正因为如此，为了方便，我们算法中通常就会省略底数，直接写作 <code>O(logn)</code>。</p><p>上面的数学公式大家如果忘了或者看不懂也没关系，只要记住不论对数的底数是多少，我们都算作 <code>O(logn)</code>，而对于一个算法的复杂度是否是对数阶，还有一个简易的判断方法：<strong>当循环中下标以指定倍数形式衰减，那么这就是一个对数阶</strong>。</p><h3 id="O-nlogn-线性对数阶"><a href="#O-nlogn-线性对数阶" class="headerlink" title="O(nlogn) 线性对数阶"></a>O(nlogn) 线性对数阶</h3><p>如果理解了上面的对数阶，那么这种线性对数阶就非常好理解了，只需要在对数阶的算法中再嵌一层循环就是线性对数阶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析了前面这些最常用的时间复杂度，其实我们可以得到以下规律：</p><ul><li>只要是常量级别，不论多大，效率都是一样的（如：常量阶复杂度例子）。</li><li>分析一段代码的时间复杂度，只需要分析执行次数最多的一段代码（如：所以例子中我们只分析了循环体中代码执行次数）。</li><li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积（如：分析线性对数阶复杂度例子）。</li></ul><h3 id="其他复杂度"><a href="#其他复杂度" class="headerlink" title="其他复杂度"></a>其他复杂度</h3><p>除了上面常用的复杂度之外，另外还有指数阶，阶层阶，根号阶等，这些接触的相对会较少，我们就不特意做分析了，如果大家感兴趣的话，可以自己去了解下。</p><h3 id="组合式复杂度分析"><a href="#组合式复杂度分析" class="headerlink" title="组合式复杂度分析"></a>组合式复杂度分析</h3><p>前面我们分析的都是只有一段代码比较复杂的情况下得到的复杂度结果，那么假如我一个算法中，有多段代码都比较复杂呢？这时候复杂度该如何分析？</p><h4 id="取最大复杂度作为整个算法复杂度"><a href="#取最大复杂度作为整个算法复杂度" class="headerlink" title="取最大复杂度作为整个算法复杂度"></a>取最大复杂度作为整个算法复杂度</h4><p>我们先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;n;p++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;n;q++)&#123;</span><br><span class="line">            System.out.println(p+q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中有三个循环，首先第一个，是一个常量，那么根据前面的结论，不论这个常量是多大，都属于常量级，所以第一个循环中的复杂度为 <code>O(1)</code>，第二个和第三个循环我们前面也分析过，复杂度分别为 <code>O(n)</code> 和 <code>O(n²)</code>。</p><p>也就是这一段代码中有三段代码产生了三种不同复杂度，而且这三个复杂度可以很明显得到的大小关系为：<code>O(1)&lt;O(n)&lt;O(n²)</code>，像这种在同一个算法中有明确大小关系的，我们就可以直接取最大值作为这个算法的复杂度，所以这个例子中算法的复杂度就是 <code>O(n²)</code>。</p><h4 id="取多个复杂度之和作为整个算法复杂度"><a href="#取多个复杂度之和作为整个算法复杂度" class="headerlink" title="取多个复杂度之和作为整个算法复杂度"></a>取多个复杂度之和作为整个算法复杂度</h4><p>接下来我们再来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子我们同样对三段循环分别分析可以分别得到如下复杂度：<code>O(1)</code>，<code>O(m)</code>，<code>O(n)</code>。这时候我们只能知道 <code>O(1)</code> 最小可以忽略，但是后面两个无法却无法确定大小，所以这时候我们需要取两段循环复杂度之和来作为算法的复杂度，所以可以得到这个例子的算法复杂度为：<code>O(m+n)</code>。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度全称就是渐进空间复杂度，用来表示算法的存储空间与数据规模之间的增长关系。和时间复杂度一样，空间复杂度也是用大 <code>O</code> 进行表示。</p><p>其实学会了分析时间复杂度，那么空间复杂度的分析就简单了，主要就看我们在一个算法当中到底有没有使用到了额外的空间来进行存储数据，然后判断这个额外空间的大小会不会随着 <code>n</code> 的变化而变化，从而得到空间复杂度。</p><p>我们来看一个给数组赋值例子，假设这就是一个算法，我们可以来分析下这个算法的空间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        arr[i]=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始定义了一个变量，这里需要空间，但是这是一个常量级的（不随 <code>n</code> 的变化而变化），然后再定义了一个数组，数组的长度为 <code>n</code>，这里数组也需要占用空间，而且数组的空间是随着 <code>n</code> 的变化而变化的，其余代码没有占用额外空间，所以我们就可以认为上面示例中的空间复杂度为 <code>O(n)</code>。</p><p>对于算法的空间复杂度也可以简单的进行总结一下：</p><ul><li>如果申请的是有限个数（常量）的变量，空间复杂度为 <code>O(1)</code>。</li><li>如果申请的是一维数组，队列或者链表等，那么空间复杂度为 <code>O(n)</code>。</li><li>如果申请的是二维数组，那么空间复杂度为 <code>O(n²)</code>。</li><li>如果是在循环体中申请的数组等，可能就需要取嵌套的乘积来作为空间复杂度，这种就需要具体的进一步分析</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>手机拍照技巧</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E6%8A%80%E5%B7%A7/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E6%8A%80%E5%B7%A7/</id>
    <published>2022-01-03T12:36:34.000Z</published>
    <updated>2022-01-07T02:07:07.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="自拍"><a href="#自拍" class="headerlink" title="自拍"></a>自拍</h4><ul><li>灯光在头顶，正午拍照，光源在头顶，脸上会有非常明显的三角形投影，不适合自拍。<ul><li>脸部朝向灯光的方向，避免顶光在脸部形成强烈的投影</li><li>带个帽子</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208205624811.png" alt="image-20201208205624811"></p><ul><li><p>室内怎么让自拍照更美？靠近窗户的时候，逆光，脸部光线不好。</p></li><li><p>换个方向，面向光源，逆光自拍会看到脸部的瑕疵（颗粒，皱纹等等），顺光自拍可以减少脸部的瑕疵。</p></li><li><p>自拍角度决定你的胖瘦。</p><ul><li><p>低于30°的仰拍角，容易拍出圆乎乎的大脸</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210135055.png" alt="image-20201208210135055"></p></li><li><p>手机保持30-45°的仰拍角度，更容易拍出巴掌脸与尖下巴</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210352336.png" alt="image-20201208210352336"></p></li><li><p>脸大脸圆？学会遮挡术</p><ul><li><p>利用树叶花朵等作为前景，虚化并遮住部分脸，即显得脸小又增加画面趣味。(借助道具，手、围巾、帽子、花花草草。)</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210639392.png" alt="image-20201208210639392"></p></li><li><p>还可以用双手或者单手托脸既可以遮住部分脸又显得可爱</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210742655.png" alt="image-20201208210742655"></p></li><li><p>借助道具，比如饮料杯遮住部分脸</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210830160.png" alt="image-20201208210830160"></p></li></ul></li><li><p>怎么让自拍照看起来不像自拍照</p><ul><li>借助手机自拍杆+定时遥控器</li><li>放在桌子或者窗台+定时自拍</li></ul></li><li><p>全身照瞬间拥有大长腿</p><ul><li>错误角度：俯拍容易拍的比本人显矮</li><li>蹲下来采用仰拍角度<ul><li>脚与地面的留白一定要少留地面</li></ul></li></ul></li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211431040.png" alt="image-20201208211431040"></p><h4 id="拍照的构图"><a href="#拍照的构图" class="headerlink" title="拍照的构图"></a>拍照的构图</h4><ul><li><p><strong>黄金分割</strong>，拍摄人像不知道把任务放置于画面哪个位置的时候，置于黄金分割点是最稳妥的构图方法。</p><ul><li><p>设置九宫格四个交叉点的位置就是黄金分割点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211908865.png" alt="image-20201208211908865"></p></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211942688.png" alt="image-20201208211942688"></p></li><li><p><strong>点构图</strong>：点构图是拍摄环境人像时，最喜欢使用的一种构图方法，这样的构图，<strong>人物在画面里的比例很小</strong>，强调环境与人物和谐统一的关系。</p><ul><li>点构图的适用场景通常为视野开阔画面干净纯粹没有过多杂物的环境</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212412080.png" alt="image-20201208212412080"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212426560.png" alt="image-20201208212426560"></p><ul><li><p><strong>对角线构图</strong>：拍摄静物或者风光照片时，对角线构图特别适用</p><ul><li><p>对角线构图适合用于拍摄静物、花草植物或大面积的草坪、画面中有道路的自然风景</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212932256.png" alt="image-20201208212932256"></p></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212723202.png" alt="image-20201208212723202"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212746080.png" alt="image-20201208212746080"></p></li></ul><ul><li><p><strong>中心对称构图</strong> </p><ul><li><p>有倒影的时候，为了追求画面平衡对称，把人物放置于画面正中间，倒影与人物聚焦中心对称点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213049793.png" alt="image-20201208213049793"></p></li><li><p>横构图中如果有弧形的线条横穿画面拍摄主体为一颗树时，可以将树放置于画面正中心</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213322513.png" alt="image-20201208213322513"></p></li><li><p>用竖构图拍摄人物特写，为了画面饱满，突出人物神态，也适用中心对称构图。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213428017.png" alt="image-20201208213428017"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213437744.png" alt="image-20201208213437744"></p></li></ul></li><li><p><strong>三角形构图</strong>，利用三角形构图，达到画面的平衡、稳定、饱满同时又不失灵活与动感</p><ul><li><p>拍摄静物或者人像时都可以尝试三角形构图</p><p><img src="images/image-20201208213524368.png?lastModify=1607434632" alt="image-20201208213524368"></p></li><li><p>拍摄前摆设物品时，有意识的选择三角形构图，把几个物品分别放在三个角，这样构图比较饱满不会显得呆板。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213739834.png" alt="image-20201208213739834"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213755697.png" alt="image-20201208213755697"></p></li><li><p>拍摄人像如何使用三角形构图</p><ul><li><p>利用模特的手或腿摆出不同的pose，让人物呈现三角形的构图画面</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213944752.png" alt="image-20201208213944752"></p></li><li><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214024680.png" alt="image-20201208214024680"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214041217.png" alt="image-20201208214041217"></p></li></ul></li></ul></li><li><p><strong>引导线构图</strong>，利用画面中的线条，引导观者的目光，让视线可以汇聚到画面的焦点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214225858.png" alt="image-20201208214225858"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214244817.png" alt="image-20201208214244817"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214254865.png" alt="image-20201208214254865"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214707089.png" alt="image-20201208214707089"></p></li><li><p><strong>重复线条构图</strong>：利用画面中规律排列的物体进行构图，让照片充满工整与秩序感</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214916083.png" alt="image-20201208214916083"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214926913.png" alt="image-20201208214926913"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214937969.png" alt="image-20201208214937969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214946433.png" alt="image-20201208214946433"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214955154.png" alt="image-20201208214955154"></p></li><li><p><strong>开放式构图</strong>：主体不一定放在画中心，有意在画面周围留下被切割的不完整形象，引导观众产生画外空间联想</p><ul><li><p>什么是封闭式构图：讲究画面完整，主体在画面之中，构图较工整，框架内部布局均衡、严禁、完整</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215546274.png" alt="image-20201208215546274"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215809810.png" alt="image-20201208215809810"></p></li><li><p>什么是开放式构图：主体不一定放在画中心，注重主体与画外的联系有意在画面周围留下切割的不完整形象，引导观众突破画框限制，产生画外空间联系</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215557329.png" alt="image-20201208215557329"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215825762.png" alt="image-20201208215825762"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215840816.png" alt="image-20201208215840816"></p></li><li><p>开放式构图拍摄静物或美食：拍摄画面里，桌面露出一小部分边角，这样的开放构图也会让人产生能长久注视画面思考遐想的效果</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215955632.png" alt="image-20201208215955632"></p></li></ul></li><li><p><strong>前景虚化构图</strong>：利用花草树木等物品作为前景，用大光圈拍摄虚化前景，制造梦幻、神秘的画面</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220521634.png" alt="image-20201208220521634"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220549714.png" alt="image-20201208220549714"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220601698.png" alt="image-20201208220601698"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220615777.png" alt="image-20201208220615777"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220625584.png" alt="image-20201208220625584"></p></li></ul><h4 id="小道具"><a href="#小道具" class="headerlink" title="小道具"></a>小道具</h4><ul><li><p>拍照的时候不知道手往哪里放，眼睛该往哪儿看</p></li><li><p>道具一：书、报纸、杂志</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113723831.png" alt="image-20201210113723831"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113740913.png" alt="image-20201210113740913"></p></li><li><p>道具二：食物（假装吃，假装喝）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113840257.png" alt="image-20201210113840257"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114107202.png" alt="image-20201210114107202"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114038513.png" alt="image-20201210114038513"></p></li><li><p>道具三：围巾、披肩、帽子</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114229969.png" alt="image-20201210114229969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114249425.png" alt="image-20201210114249425"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114304577.png" alt="image-20201210114304577"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114315969.png" alt="image-20201210114315969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114348323.png" alt="image-20201210114348323"></p></li><li><p>相机</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114427329.png" alt="image-20201210114427329"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114455826.png" alt="image-20201210114455826"></p></li><li><p>镜子</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114556977.png" alt="image-20201210114556977"></p></li><li><p>花草树叶等植物</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114640865.png" alt="image-20201210114640865"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114711890.png" alt="image-20201210114711890"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114746689.png" alt="image-20201210114746689"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114928673.png" alt="image-20201210114928673"></p></li><li><p>自行车</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114958755.png" alt="image-20201210114958755"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115016593.png" alt="image-20201210115016593"></p></li><li><p>雨、雪、风、阳光</p><ul><li>雨，躲在屋檐下把手放在头顶装作要遮雨一样</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115258513.png" alt="image-20201210115258513"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115315522.png" alt="image-20201210115315522"></p><ul><li>雪</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115421905.png" alt="image-20201210115421905"></p><ul><li>雪+逆光<ul><li>最好是很细颗粒的雪花，逆光拍摄，把雪花朝着镜头洒过来</li><li>模特洒雪花的同时要保持微笑，表情不能太奔放与放松</li><li>伞，伞柄不能把脸遮住</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115832982.png" alt="image-20201210115832982"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115851699.png" alt="image-20201210115851699"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115924946.png" alt="image-20201210115924946"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120224994.png" alt="image-20201210120224994"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120244786.png" alt="image-20201210120244786"></p></li><li><p>风</p><ul><li>当有风的时候，利用风将头发和衣服吹起来</li><li>最好是顺风，迎着风摆pose，眼神表情一定要到位</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120424421.png" alt="image-20201210120424421"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120529268.png" alt="image-20201210120529268"></p></li><li><p>阳光</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120614675.png" alt="image-20201210120614675"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120829954.png" alt="image-20201210120829954"></p></li><li><p>逆光拍摄</p><ul><li>日出、日落是逆光拍摄的最佳时间段</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120959832.png" alt="image-20201210120959832"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121240403.png" alt="image-20201210121240403"></p><ul><li>当屋外太阳比较高时可以选择路面有积雪的或者四周有白色墙面的环境进行拍摄逆光</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121734771.png" alt="image-20201210121734771"></p><ul><li>或者躲进屋内拍摄逆光</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121820695.png" alt="image-20201210121820695"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121830145.png" alt="image-20201210121830145"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121839586.png" alt="image-20201210121839586"></p><ul><li>逆光帮手：三棱镜</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211222932427.png" alt="image-20201211222932427"></p><ul><li>逆光剪影怎么拍<ul><li>人物背后要有大面积空景，不能有山等阻挡（山顶、楼顶、海边、或者站高一点与其他人物脱离）</li></ul></li><li>光背景过亮 人脸过黑怎么办<ul><li>对焦锁焦以后加曝光</li></ul></li><li>逆光条件不理想，比如天空惨白怎么办<ul><li>只利用光线，天空部分少拍入画面</li></ul></li><li>太阳角度比较高的逆光拍摄<ul><li>可以选择室内拍摄，让光线透过玻璃窗打进屋内</li><li>寻找有积雪、四周白色墙壁环境的地方拍摄逆光，让白色物体的反光对人物进行补光</li></ul></li><li>巧妙的利用小道具制造不一样的逆光（三棱镜）</li><li>逆光拍摄剪影有哪些诀窍<ul><li>任务的背后要有大面积的空景，不能有建筑物或山等阻挡</li><li>天空中最好有美丽的火烧云，这样逆光照片色彩好看</li><li>最好挑选在山顶、楼顶、海边等空旷环境拍摄逆光剪影</li></ul></li></ul></li><li><p>哪些小技巧，可以让你的照片更有感觉</p><ul><li><p>虚化背景，突出主题（相机人像模式）。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224712762.png" alt="image-20201211224712762"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224731048.png" alt="image-20201211224731048"></p></li><li><p>三棱镜：遮挡杂物，营造梦幻效果。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224823643.png" alt="image-20201211224823643"></p></li><li><p>分身效果：全景模式下模特由起始点移动到结束点，中间不能有路人闯入。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224920330.png" alt="image-20201211224920330"></p></li><li><p>镜面效果：积水，湖泊</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224938235.png" alt="image-20201211224938235"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224957947.png" alt="image-20201211224957947"></p></li><li><p>悬浮效果：站板凳上一张，空景一张，app合成去掉板凳（设置一个蒙版，把它擦出来）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225121692.png" alt="image-20201211225121692"></p></li><li><p>制造画框，将拍摄主体置于任何框内</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225222522.png" alt="image-20201211225222522"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225238832.png" alt="image-20201211225238832"></p></li><li><p>用手机如何拍出车辆运动轨迹的照片</p><ul><li>快门速度设置到1/20,1/30秒的速度</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225456114.png" alt="image-20201211225456114"></p></li><li><p>一组人像：景大人小，互相衬托，人景合一</p><ul><li>尝试拍摄景大人小的环境人像，这样的照片更耐看</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225614266.png" alt="image-20201211225614266"></p><ul><li>环境人像要斟酌人物着装是否与环境相呼应</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225706777.png" alt="image-20201211225706777"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225718601.png" alt="image-20201211225718601"></p></li></ul></li><li><p>男友拍照指南？？？</p><ul><li><p>餐厅</p><ul><li><p>挑选靠窗户的光源位置，让女朋友面朝窗户</p></li><li><p>跟实物合影，可以近距离高角度把她和食物一起拍进画面</p></li><li><p>注意看看脸上细节，进行补妆</p></li><li><p>端着水杯，或者利用桌上的植物作为虚化的前景增添照片的意境</p></li><li><p>不一定要看镜头，不看镜头的照片可能更加自然</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225858985.png" alt="image-20201211225858985"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230014394.png" alt="image-20201211230014394"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230232644.png" alt="image-20201211230232644"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230320730.png" alt="image-20201211230320730"></p></li></ul></li><li><p>街景拍照</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230434330.png" alt="image-20201211230434330"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230456826.png" alt="image-20201211230456826"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230537417.png" alt="image-20201211230537417"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230832809.png" alt="image-20201211230832809"></p></li><li><p>旅行拍摄赢芳心</p><ul><li><p>大头照与景大人小的照片都要拍</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231020307.png" alt="image-20201211231020307"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231032234.png" alt="image-20201211231032234"></p></li><li><p>寻找好的光源或者利用小道具，让她的皮肤在镜头里显得水汪汪</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231125843.png" alt="image-20201211231125843"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231135144.png" alt="image-20201211231135144"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231148765.png" alt="image-20201211231148765"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231159066.png" alt="image-20201211231159066"></p></li><li><p>想避开人群或拍出大长腿只需要蹲下拍摄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231255965.png" alt="image-20201211231255965"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231304281.png" alt="image-20201211231304281"></p></li><li><p>手机采用竖构图拍摄更容易拉长腿</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231335864.png" alt="image-20201211231335864"></p></li><li><p>与可爱的小动物合影，抓拍自然生动的照片</p><p>​    <img src="images/image-20201211231418986.png" alt="image-20201211231418986"></p></li></ul></li></ul></li><li><p><strong>拍美食</strong> </p><ul><li><p>尽量在光线充足明亮的地方拍照，最好是靠近窗户的光源</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133702979.png" alt="image-20201213133702979"></p></li><li><p>当地特色美食纪念照</p><ul><li><p>寻找漂亮的背景，如店铺的招牌</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133824287.png" alt="image-20201213133824287"></p></li><li><p>尽量让拍摄角度与背景面板保持垂直平行</p></li><li><p>用当地的特色建筑或街道作为背景</p></li></ul></li><li><p>只拍一款美食时诀窍</p><ul><li><p>构图采用中心点构图，将一盘美食放置于画面最中间（尽量让整盘食物充满画面，但也不能太拥挤，画面至少保留餐盘边缘）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134024640.png" alt="image-20201213134024640"></p></li></ul></li><li><p>采用俯拍，保持30-45°的角度拍摄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134215182.png" alt="image-20201213134215182"></p></li><li><p>部分实物，采用特殊角度拍摄</p><ul><li><p>饮料蛋糕冰淇淋等有立体感的食物，有时候采用平视角度更加合适</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134343823.png" alt="image-20201213134343823"></p></li><li><p>整桌的食物更适合俯视平拍角度</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135433744.png" alt="image-20201213135433744"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135454240.png" alt="image-20201213135454240"></p></li><li><p>加入手的元素，让照片有互动感</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135532991.png" alt="image-20201213135532991"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135552575.png" alt="image-20201213135552575"></p></li><li><p>拍摄前整理盘内食物形状与盘边食物残渣</p></li><li><p>利用小道具让画面摆脱单调，更丰富</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135846143.png" alt="image-20201213135846143"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135857777.png" alt="image-20201213135857777"></p></li><li><p>foodie APP</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135944030.png" alt="image-20201213135944030"></p></li></ul></li></ul></li><li><p><strong>拯救镜头恐惧症</strong></p><ul><li><p>低头微笑</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140114237.png" alt="image-20201213140114237"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140144768.png" alt="image-20201213140144768"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140201519.png" alt="image-20201213140201519"></p></li><li><p>撩头发</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140221731.png" alt="image-20201213140221731"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140236419.png" alt="image-20201213140236419"></p></li><li><p>回眸一笑</p><ul><li>回眸时，压低头。否则容易拍出大脸</li><li>回眸瞬间记得用头发遮下脸，别用力太猛把头发甩开了</li><li>回头时可以保持微笑，头与身体朝镜头方向倾斜一些，这样可以显瘦</li><li>若想要自然状态，可以不看镜头，看自己的斜后方</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140306240.png" alt="image-20201213140306240"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140322080.png" alt="image-20201213140322080"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140331437.png" alt="image-20201213140331437"></p></li><li><p>托住脸颊</p><ul><li><p>轻轻放在脸颊旁边，真正托住脸颊的话，脸会被压变形</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140703775.png" alt="image-20201213140703775"></p></li><li><p>不看镜头，等待观看，凝视</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140738606.png" alt="image-20201213140738606"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140753038.png" alt="image-20201213140753038"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140806898.png" alt="image-20201213140806898"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140822623.png" alt="image-20201213140822623"></p></li><li><p>借助食物饮料等作为道具拿在手里</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140909615.png" alt="image-20201213140909615"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140958000.png" alt="image-20201213140958000"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141013536.png" alt="image-20201213141013536"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141025585.png" alt="image-20201213141025585"></p></li><li><p>抬头闭眼微笑</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141052558.png" alt="image-20201213141052558"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141103600.png" alt="image-20201213141103600"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141128318.png" alt="image-20201213141128318"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141139502.png" alt="image-20201213141139502"></p></li><li><p>坐下来</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141242494.png" alt="image-20201213141242494"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141255040.png" alt="image-20201213141255040"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141310287.png" alt="image-20201213141310287"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141327583.png" alt="image-20201213141327583"></p></li><li><p>奔跑（奔跑的速度比平时慢一点，动作比平时夸张，拍摄角度最好从侧面拍摄）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141426483.png" alt="image-20201213141426483"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141505295.png" alt="image-20201213141505295"></p></li><li><p>走路（连拍，步子迈的明显一些）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141536080.png" alt="image-20201213141536080"></p></li><li><p>跳跃</p><ul><li>机位蹲低，可以显高</li><li>跳跃时人脸容易变形、表情不受控制，采用侧面拍摄可以避免尴尬</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141749071.png" alt="image-20201213141749071"></p></li><li><p>旋转，转圈</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141822223.png" alt="image-20201213141822223"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141832320.png" alt="image-20201213141832320"></p></li><li><p>凝望镜头，眼睛里要有戏</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141917825.png" alt="image-20201213141917825"></p></li></ul></li></ul></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bilibili.com/video/BV1Gb411S7wC?from=search&seid=5668966452379294491">手机摄影之生活拍照技巧</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="摄影" scheme="https://sssuper-bear.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>PsTips</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/PsTips/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/PsTips/</id>
    <published>2022-01-03T12:29:51.000Z</published>
    <updated>2022-01-07T02:05:57.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>[ 画笔增大</li><li>] 画笔减小</li><li>ctrl+i 反向</li><li>ctrl+t 自由变换工具</li><li>调出红色非选区遮罩：快捷键shift+alt + 点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="PS" scheme="https://sssuper-bear.github.io/categories/PS/"/>
    
    
  </entry>
  
  <entry>
    <title>手撕包菜</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/</id>
    <published>2022-01-03T12:16:18.000Z</published>
    <updated>2022-01-07T01:57:21.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>typora-copy-images-to: images</p><hr><h3 id="手撕包菜"><a href="#手撕包菜" class="headerlink" title="手撕包菜"></a><a href="https://www.bilibili.com/video/BV1hh41197hh?from=search&seid=4921812292540006215">手撕包菜</a></h3><ul><li><p>包菜去根，用手撕成小块 <strong>根部用刀拍一下</strong></p></li><li><p>清水+少许食用盐，在水中清洗浸泡彻底洗净</p></li><li><p>洗好以后控水备用</p></li><li><p>几粒大蒜拍碎+干辣椒+花椒</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126162351153.png" alt="image-20210126162351153"></p></li><li><p>五花肉切成薄片</p></li><li><p><strong>猪油+五花肉来炒</strong>这样的才香</p></li><li><p>猪油熬化以后加入五花肉片</p></li><li><p>先将五花肉煸炒出油，肉片变色，微微发黄时，加入准备好的小料，煸炒出香味，（火要大，锅要热，油要多）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102537195.png" alt="image-20210127102537195"></p></li><li><p>彻底炒出香味以后放入准备好的包菜</p></li><li><p>少许米酒或者料酒沿锅边淋入去腥增香</p></li><li><p>放入少许米醋或者香醋（先放醋，炒出来的包菜更脆）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102716126.png" alt="image-20210127102716126"></p></li><li><p>大火将包菜炒至塌陷</p></li><li><p>塌陷以后开始调味（适量盐+少许白糖+蒸鱼豉油）</p></li><li><p>大火翻炒均匀</p></li><li><p>香醋沿锅边淋入将整道菜的香味彻底激发出来</p></li><li><p>这道菜要的是干香脆爽，翻炒时间不要太长</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127103410622.png" alt="image-20210127103410622"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>可乐鸡翅</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/</id>
    <published>2022-01-03T12:16:12.000Z</published>
    <updated>2022-01-07T01:57:09.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="可乐鸡翅"><a href="#可乐鸡翅" class="headerlink" title="可乐鸡翅"></a><a href="https://www.bilibili.com/video/BV1pJ411v7S9?from=search&seid=2151627749794461067">可乐鸡翅</a></h3><ul><li><p>原料</p><ul><li>鸡翅250g（11个左右）</li></ul></li><li><p>做法</p><ul><li><p>鸡翅泡水解冻</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155937382.png" alt="image-20210126155937382"></p></li><li><p>捞出，加姜片料酒腌制20分钟（用手抓一抓，搅拌均匀）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155946527.png" alt="image-20210126155946527"></p></li><li><p>放入锅中焯水捞出</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160034775.png" alt="image-20210126160034775"></p></li><li><p>锅内热油加入姜片</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160120839.png" alt="image-20210126160120839"></p></li><li><p>鸡翅正面朝下煎至金黄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160210270.png" alt="image-20210126160210270"></p></li><li><p>加入调味</p><ul><li>一勺料酒</li><li>一勺生抽</li><li>半勺老抽</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160624263.png" alt="image-20210126160624263"></p></li><li><p>翻炒均匀上色</p></li><li><p>可乐一听倒入2/3罐子</p></li><li><p>放入半勺盐调味，盖上锅盖煮沸</p></li><li><p>放入香料：香叶八角都可以</p></li><li><p>大火煮至汤汁收干</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160844786.png" alt="image-20210126160844786"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora自动上传图片</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</id>
    <published>2022-01-03T12:13:16.000Z</published>
    <updated>2022-01-16T02:17:05.322Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora-图片自动上传服务器设置"><a href="#Typora-图片自动上传服务器设置" class="headerlink" title="Typora 图片自动上传服务器设置"></a>Typora 图片自动上传服务器设置</h1><ul><li>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>（比较稳定建议使用）</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/1972718-20200323210552751-1313111323.png" alt="img"></p><ul><li><p>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，有两个插件都可以用</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323194553126.png" alt="image-20200323194553126"></p></li><li><p>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323195546145.png" alt="image-20200323195546145"></p></li><li><p>token获取：进入码云，点击进入设置页</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323200633225.png" alt="image-20200323200847954"></p></li><li><p>在PicGo配置Gitee</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220103171035455.png" alt="image-20220103171035455"></p></li><li><p>配置Typora，点击 文件，偏好设置，选择图像，设置PicGo二进制文件的路径</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323201738802.png" alt="image-20200323201738802"></p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/">https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</a></li><li><a href="https://www.cnblogs.com/qtzd/p/12554902.html">https://www.cnblogs.com/qtzd/p/12554902.html</a></li><li><a href="https://blog.csdn.net/weixin_41800884/article/details/104718367">https://blog.csdn.net/weixin_41800884/article/details/104718367</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>word绘制三线表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/word%E7%BB%98%E5%88%B6%E4%B8%89%E7%BA%BF%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/word%E7%BB%98%E5%88%B6%E4%B8%89%E7%BA%BF%E8%A1%A8/</id>
    <published>2022-01-03T12:13:16.000Z</published>
    <updated>2022-01-21T03:58:05.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="word绘制三线表"><a href="#word绘制三线表" class="headerlink" title="word绘制三线表"></a>word绘制三线表</h1><ul><li><p>插入表格</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115217794.png" alt="image-20220121115217794"></p></li><li><p>全选表格-右键点击表格属性</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115451664.png" alt="image-20220121115451664"></p></li><li><p>选择边框和底纹，左边选择“无”</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115532407.png" alt="image-20220121115532407"></p></li><li><p>手动设置宽度1.5磅，完成下图后确定</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115649343.png" alt="image-20220121115649343"></p></li><li><p>选择第一行的表格重复上面动作，设置不同宽度的线</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115745079.png" alt="image-20220121115745079"></p></li><li><p>然后就完成了</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220121115805179.png" alt="image-20220121115805179"></p></li></ul><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_36890370/article/details/107854266">论文中的三线表绘制（word）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>伪代码</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-03T12:13:16.000Z</published>
    <updated>2022-01-22T13:19:46.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><ol><li><p>for,end for,do,while, end while,if,else都用加粗</p></li><li><p>变量要用花体</p></li><li><p>不要使用括号，而是使用缩进表示代码块</p></li><li><p>需要有input，output</p></li><li><p>需要有行标</p></li></ol><h2 id="伪代码规范"><a href="#伪代码规范" class="headerlink" title="伪代码规范"></a>伪代码规范</h2><p>伪代码是一种接近自然语言的算法描述形式，其目的是在不涉及具体实现（各种编程语言）的情况下将算法的流程和含义清楚的表达出来，因此它没有一个统一的规范，有的仅仅是在长期的实践过程中形成的一些约定俗成的表达样式。下图是一个简单的例子<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:1">1</a>，但已经包含了大多数主要元素</p><p><img src="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20210118_%E7%A4%BA%E4%BE%8B%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt="示例伪代码"></p><p>首先需要一个<strong>标题</strong>来描述整个算法，一般还会有一个与之一起的编号。在上图中，算法的标题为「Acesscontrol algorithm flow」，编号为「Algorithm 1」。标题与编号一般位于算法顶部，但也有人放在底部，编号多按全文的算法总数进行索引，但也可以按章节分别进行索引。</p><p>其次，在正式的算法流之前需要声明<strong>输入和输出</strong>。通常使用关键字 Input 和 Output 来声明，但也有人使用关键字 Data 和 Result。</p><p>顺序、选择与循环结构是算法的主体。通常，不同的程序块使用缩进来保持结构清晰，但也有不少人使用垂直连接线进行进一步划分，如上图。另外，和编程语言类似，伪代码中的选择和循环使用 if-then-else、while-do 和 for-do 等关键字和结构来描述<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:2">2</a>，举例如下，其中，每个程序块结束的 end 关键字有人选择写，也有人选择不写。</p><p><img src="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20210118_%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="算法流程结构">算法流程结构</p><p>赋值操作一般使用左箭头「&lt;—」表示。A[i] 用来表示数组 A 的第 i 个元素，A[1…j] 则表示下标从 1 到 j 的子数组；函数调用使用函数名+传入参数的形式；返回值使用 return 关键字，这些都和常规编程语言相同。需要注意的是，未声明而使用的变量都可以视为算法内的局部变量，如果是全局变量则需要进行解释，可以在上下文中，也可以使用注释；注释的形式也和传统语言相同，使用 // 或 /<em>……</em>/。</p><p>算法整体通常使用三线框包围，但也有少部分人使用一个完整的框。</p><p>伪代码的语句一般不需要在末尾使用分号，但行首通常会添加行号。</p><p><strong>参考：</strong></p><ul><li><a href="https://shuzang.github.io/2021/pseudocode-specification/">科研基础3-伪代码规范</a></li><li>怎么在要投稿发表的论文里添加 好看的规范格式的伪代码？ - 张熠的回答 - 知乎 <a href="https://www.zhihu.com/question/29907421/answer/243307404">https://www.zhihu.com/question/29907421/answer/243307404</a></li><li><a href="https://blog.csdn.net/u010126059/article/details/51077514">伪代码规范</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>希腊字母表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</id>
    <published>2022-01-03T12:11:42.000Z</published>
    <updated>2022-01-03T12:12:08.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h1><table><thead><tr><th>希腊字母小写、大写</th><th>LaTeX形式</th><th>希腊字母小写、大写</th><th>LaTeX形式</th></tr></thead><tbody><tr><td>α <em><strong>A</strong></em></td><td>\alpha A</td><td>μ <em><strong>N</strong></em></td><td>\mu N</td></tr><tr><td>β <em><strong>B</strong></em></td><td>\beta B</td><td>ξ Ξ</td><td>\xi \Xi</td></tr><tr><td>γ Γ</td><td>\gamma \Gamma</td><td><strong>o</strong> <em><strong>O</strong></em></td><td>o O</td></tr><tr><td>δ Δ</td><td>\delta \ Delta</td><td>π Π</td><td>\pi \Pi</td></tr><tr><td>ϵ ε <em><strong>E</strong></em></td><td>\epsilon \varepsilon E</td><td>ρ ϱ <em><strong>P</strong></em></td><td>\rho \varrho P</td></tr><tr><td>ζ <em><strong>Z</strong></em></td><td>\zeta Z</td><td>σ Σ</td><td>\sigma \Sigma</td></tr><tr><td>η <em><strong>H</strong></em></td><td>\eta H</td><td>τ <em><strong>T</strong></em></td><td>\tau T</td></tr><tr><td>θ ϑ Θ</td><td>\theta \vartheta \Theta</td><td>υ Υ</td><td>\upsilon \Upsilon</td></tr><tr><td>ι <em><strong>I</strong></em></td><td>\iota I</td><td>ϕ φ Φ</td><td>\phi \varphi \Phi</td></tr><tr><td>κ <em><strong>K</strong></em></td><td>\kappa K</td><td>χ <em><strong>X</strong></em></td><td>\chi X</td></tr><tr><td>λ Λ</td><td>\lambda \Lambda</td><td>ψ Ψ</td><td>\psi \Psi</td></tr><tr><td>μ <em><strong>M</strong></em></td><td>\mu M</td><td>ω Ω</td><td>\omega \Omega</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源代码包”和“二进制包”的区别</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-03T11:33:43.000Z</published>
    <updated>2022-01-07T02:09:09.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="“源代码包”和“二进制包”的区别"><a href="#“源代码包”和“二进制包”的区别" class="headerlink" title="“源代码包”和“二进制包”的区别"></a><a href="https://blog.csdn.net/Tomstrong_369/article/details/51741012">“源代码包”和“二进制包”的区别</a></h1><p>源代码方式和二进制包是软件包的两种形式。二进制包里面包括了已经经过编译，可以马上运行的程 序。你只需要下载和解包（安装）它们以后，就马上可以使用。源代码包里面包括了程序原始的程序代码，需要在你的计算机上进行编译以后才可以产生可以运行程 序,所以从源代码安装的时间会比较长。</p><p>source code 是程序員寫的碼， binary code 是機器跑的碼。 source code 得經過 compile 才能成為 binary code 。 </p><p>RPM 有分兩種：binary rpm 跟 source rpm 。<br>前者是編好的 binary ，安裝就可用。<br>後者是還沒編好的 source ，需 rebuild 之後才能安裝。</p><p>rpm格式很好区分，二进制格式的包名字很长，都带有版本号、适应平台、适应的硬件类型等，而源码格式仅仅就是一个版本号的tar包。<br>mysql-5.0.45.tar.gz 是 源码包    像这样的 mysql-5.0.45-linux-x86_64-glibc23.tar.gz   是二进制包</p><p>如果你用过压缩工具就会明白，压缩包未必就是软件，它也可能是备份的许多图片，也可能是打包在一起的普通资料，要分辨它到底是什么最好的办法就是查看包里的文件清单，使用命令tar ztvf *. 或者tar ytvf *.bz2</p><p>源代码包里的文件往往会含有种种源代码文件，头文件*.h、c代码源文件*.c、C++代码源文件*.cc/*.cpp等；而二进制包里的文件则会有可执行文件（与软件同名的往往是主执行文件），标志是其所在路径含有名为bin的目录（仅有少数例外）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="科普" scheme="https://sssuper-bear.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实战例子</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/</id>
    <published>2022-01-03T10:58:10.000Z</published>
    <updated>2022-01-07T02:00:33.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">腾讯一面</a>：</p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>进程间有六种通信方式：</p><ol><li><strong>管道（pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</li><li><strong>信号（signal）</strong>：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的</li><li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限的进程可以从消息队列中读取信息</li><li><strong>共享内存（share memory）</strong>：他使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量（也就是一个进行在未完成写操作之前，另一个进程不能读取）</li><li><strong>信号量（semaphore）</strong>：它是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据（而信号量一般常用于保护一段代码，使其每次只被一个执行线程运行）。对于二值信号量（0-1），信号量大于0时，可以对进程操作，等于0时要等待，知道信号量大于0</li><li><strong>套接字（socket）</strong>：一种更为一般的进程通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛</li></ol><h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><p><strong>僵尸进程：</strong>一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait或wait pid来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。</p><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记在该进程的退出状态等信息，供其他进程收集，除此之外，僵尸进程需要它的父进程来为它收尸，如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，他还是能被清除的。但是如果父进程是进入一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会很多僵尸进程。</p><p><strong>僵尸进程解决</strong></p><ul><li>调用wait函数，进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，知道有一个出现为止</li><li>当子进程终止时，内核就会向它的父进程发送一个SIGCHLD信号，当父进程接收到SIGCHLD信号后就应该调用wait或waitpid函数对子进程进行善后处理，释放子进程占用的资源</li></ul><p><strong>孤儿进程：</strong>一个父进程退出，而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并有init进程对它们完成状态收集的工作</p><p>子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会向僵尸进程那样占用ID，损害运行系统。</p><h4 id="TCP为啥需要三次握手"><a href="#TCP为啥需要三次握手" class="headerlink" title="TCP为啥需要三次握手"></a>TCP为啥需要三次握手</h4><h5 id="三次握手原理"><a href="#三次握手原理" class="headerlink" title="三次握手原理"></a>三次握手原理</h5><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303831393232333433313438.jpg" alt="这里写图片描述"></p><ol><li><p>上图的名词解释</p><ul><li>SYN：同步序号。<strong>它表示建立连接</strong>。TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此随机选取一个序列号为seq=x数据包（该数据包里就是一个标记seq，并没有任何有效的数据）</li><li>ACK：确认序号。<strong>它表示响应</strong>（都能响应了 那肯定上一步就连接成功了啊，所以说ACK=1代表确认连接成功啦）</li></ul><p>因此<strong>SYN和ACK同时为1，表示建立连接之后的响应</strong>；而只是<strong>单个的SYN=1，表示的只是建立连接。</strong></p><ul><li>seq：（sequence number）序列号。他是发送端数据包的初始序列号。<strong>seq=x表示发送端数据包的初始序号为x</strong>（seq=0就代表这是第0号帧）</li><li>ack：（acknowledge number）确认号。它是对这次收到数据包的确认，以及对下次收到数据包的期待。<strong>ack=x+1表示我方到x位置的所有数据都已正确收到，且我方告知对方：我期待你下次给我发送包的初始序号（seq）是x+1。</strong></li></ul><p>为了方便记忆，可以这么理解：SYN/ACK是TCP协议层面的标记，而seq/ack是数据层面的标记。</p></li></ol><h5 id="TCP三次握手过程："><a href="#TCP三次握手过程：" class="headerlink" title="TCP三次握手过程："></a><strong>TCP三次握手过程：</strong></h5><ol><li><strong>首先Client向Server发送连接：SYN=1，seq=x；</strong><ul><li><strong>因为</strong>要<strong>建立连接，所以SYN=1</strong>；又<strong>因为</strong>TCP规定SYN=1时不能携带数据，但要消耗一个序号，<strong>所以</strong>Client随机选取一个<strong>初始序号seq=x</strong>。（因为并没有相应动作，所以这里没ACK什么事，我们就认为ACK=0吧）</li><li>发送后Client进入syn_sent状态，表示客户端等待服务器的回复</li></ul></li><li><strong>Server收到请求后 再向Client发送确认：SYN=1，ACK=1，seq=y，ack=x+1；</strong><ul><li>因为Server建立连接后做出了相应，所以SYN=1，ACK=1.因为TCP规定SYN=1时不能携带数据，但要消耗一个序号，所以Server随机选取一个初始序号seq=y。又因为Server到x为止的所有数据都已正确收到了，且Server告诉Client：我期待你下次给我发送包的初始序号（seq）是x+1，所以ack=x+1。</li><li>发送后服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待Client的确认。</li></ul></li><li><strong>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据：ACK=1，seq=x+1,ack=y+1;连接建立</strong><ul><li><strong>因为</strong>有响应动作，<strong>所以ACK=1</strong>（因为要携带发送的数据，所以这没SYN什么事）。<strong>因为2中s</strong>erver已经告诉了这次它想收到包的初始序列号是x+1，<strong>所以初始序号为seq=x+1</strong>。<strong>又因为</strong>Client到y为止的所有数据都已正确收到了，准备接收序列号为y+1的包，<strong>所以ack=y+1</strong></li><li>server收到后，这个TCP连接就进入到Established状态，就可以发起http请求了。</li></ul></li></ol><p><strong>形象些：</strong></p><ul><li><p>第一次握手，由浏览器发起，告诉服务器我要发送请求了</p></li><li><p>第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧</p></li><li><p>第三次握手，由浏览器发送，告诉服务器，我马上发了，准备接收吧</p></li></ul><h5 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h5><p>  其实这是由TCP的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认<code>双方</code>的<code>接收和发送能力</code>,不然容易出现丢包的现象</p><ul><li>第一次握手: 服务端 可以确认<code>客户端</code>具有发送能力</li><li>第二次握手: 客户端 可以确认<code>服务端</code>具有接收能力和发送能力</li><li>第三次握手: 服务端 可以确认<code>客户端</code>具有接收能力</li></ul><h5 id="为什么不能改成两次握手？"><a href="#为什么不能改成两次握手？" class="headerlink" title="为什么不能改成两次握手？"></a>为什么不能改成两次握手？</h5><p>如果两次握手，则会出现下面这种情况：</p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。</p><h5 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h5><p>其实第三次握手的时候,是可以携带数据的.但是,第一次,第二次握手不可以携带数据.</p><p>为什么这样呢?假如第一次握手可以携带数据的话,如果有人要恶意攻击服务器,那他每次都在第一次握手中的<code>SYN</code>报文中放入大量的数据.因为攻击者根本就不理服务器的接收 发送能力是否正常,然后疯狂重复发<code>SYN</code>报文的话,这会让服务器话费很多时间 内存空间来接收这些报文.</p><p>也就是说,第一次握手不可以放数据,其中一个简单的原因就是会让服务器更加容易受到攻击了.而对于第三次的话,此时客户端已经处于<code>ESTAB-LISHED</code>状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h5 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h5><p>static_assert这个关键字，用来做编译期间的断言，因此叫做静态断言。</p><p>语法：static_assert(常量表达式，提示字符串)——如果第一个参数常量表达式的值为真（true或者非零值），那么static_assert不做任何事情，就像它不存在一样，否则会产生一条编译错误，错误位置就是该static_assert语句所在行，错误提示就是第二个参数提示字符串。</p><p>编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。</p><p>static_assert的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果使用变量，则会导致错误</p><h5 id="write和fwrite"><a href="#write和fwrite" class="headerlink" title="write和fwrite"></a>write和fwrite</h5><p>fwrite：带缓冲区；write：不带缓冲区</p><h5 id="程序中1-0是在编译期出错还是在运行的时候出错"><a href="#程序中1-0是在编译期出错还是在运行的时候出错" class="headerlink" title="程序中1/0是在编译期出错还是在运行的时候出错"></a>程序中1/0是在编译期出错还是在运行的时候出错</h5><p>在linux系统中gcc编译期测试：编译可以通过，运行时报错</p><p>参考：</p><ul><li><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></li><li><a href="https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md">https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-03T10:58:10.000Z</published>
    <updated>2022-02-25T02:30:28.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h3><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><p>做一个形象的比喻：</p><p>并发 = 两个队列和一台咖啡机。</p><p>并行 = 两个队列和两台咖啡机。</p><p>串行 = 一个队列和一台咖啡机。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>指在系统中正在运行的一个应用程序；程序一旦运行就是进程；或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</p><p><strong>线程进程的区别体现在4个方面：</strong></p><p>1、因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p><p>2、体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。</p><p>3、体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p><p>4、体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p><p><strong>什么情况下使用进程个线程：</strong></p><p>1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的</p><p>2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p><p>3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程</p><p>4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求</p><p>5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</p><p>​    因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。</p><p>​    如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。。。</p><p><strong>进程和线程的关系：</strong></p><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p><p>2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p><p>3、处理机分给线程，即真正在处理机上运行的是线程。</p><p>4、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p><strong>系统线程数量上限是多少</strong></p><p><strong>参考回答：</strong></p><p>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。</p><p>这个限制可以在/usr/include/bits/local_lim.h中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。</p><p>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是8M=8192KB</p><p><strong>如何杀死一个进程</strong></p><p>kill pid</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。</p><p><strong>多线程一般用在哪些地方？</strong></p><p>1、java多线程一般多用于高并发的地方，如订单状态的修改，可以通过多线程，固定时间执行修改订单状态，还有就是支付方面一般都会用到多线程。</p><p>2、最典型的如：</p><p>用户注册完成送大礼包/积分之类，且积分等也是另一个系统并比较耗时；且这类任务即使失败也不是特别重要的。<br>后台线程：比如定期执行一些特殊任务，如定期更新配置文件，任务调度（如quartz），一些监控用于定期信息采集等。</p><p>3、最典型的应用比如tomcat，tomcat内部采用的就是多线程，上百个客户端访问同一个web应用，tomcat接入后都是把后续的处理扔给一个新的线程来处理，这个新的线程最后调用到我们的servlet程序，比如doGet或者doPost方法。</p><p>如果不采用多线程机制，上百个人同时访问一个web应用的时候，tomcat就得排队串行处理了，那样客户端根本是无法忍受那种访问速度的。</p><p>还有就是需要异步处理的时候，需要使用多线程。比如task a和task b要并行处理，单个线程只能串行处理，先做完task a然后再做task b。如果想要多个task同时执行的话，就必须为每个task分配一个线程，然后通过java虚拟机的线程调度，来同时执行多个任务。比如你的CPU是多核心的话，就可以让一个CPU执行一个线程。如果只有一个CPU的话，底层是按照分时复用的原则，各个线程按照时间片来获得CPU资源。</p><p>4、特别耗时的操作，如备份数据库，可以开个线程执行备份，然后执行返回，前台不断向后台询问线程执行状态</p><p>5、一个业务逻辑有很多次的循环，每次循环之间没有影响，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。</p><p>6、需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。</p><p>总之使用多线程就是为了充分利用cpu的资源，提高程序执行效率，当你发现一个业务逻辑执行效率特别低，耗时特别长，就可以考虑使用多线程。不过CPU执行哪个线程的时间和顺序是不确定的，即使设置了线程的优先级，因此使用多线程</p><p><strong>多线程的优点？</strong><br>1、使用线程可以把占据时间长的程序中的任务放到后台去处理<br>2、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>3、程序的运行速度可能加快<br>4、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>5、多个线程交替执行，减少或避免因程序阻塞或意外情况造成的响应过慢现象，降低了用户等待的概率。</p><p><strong>多线程的缺点？</strong><br>1、如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。<br>2、更多的线程需要更多的内存空间。<br>3、程可能会给程序带来更多“bug”，因此要小心使用<br>4、程的中止需要考虑其对程序运行的影响。<br>5、通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p>开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”…</p><h3 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h3><p>守护线程和用户线程</p><ul><li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 <strong>“佣人”</strong>。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p><p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>参考：</p><ul><li><a href="https://www.cnblogs.com/feily/articles/14133501.html">https://www.cnblogs.com/feily/articles/14133501.html</a></li></ul><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace [ɪm’breɪs]拥抱) ，若无外力作用，这些进程（线程）都将无法向前推进</p><h3 id="什么情况下会发生死锁？解决死锁的策略有哪些"><a href="#什么情况下会发生死锁？解决死锁的策略有哪些" class="headerlink" title="什么情况下会发生死锁？解决死锁的策略有哪些"></a>什么情况下会发生死锁？解决死锁的策略有哪些</h3><h4 id="死锁发生的四个必要条件是："><a href="#死锁发生的四个必要条件是：" class="headerlink" title="死锁发生的四个必要条件是："></a>死锁发生的四个必要条件是：</h4><ol><li><p>资源互斥使用。 </p><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>多个进程保持一定的资源，但又请求新的资源。 </p><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>资源不可被剥夺。 </p><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p></li><li><p>多个进程循环等待。</p><p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</p><p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p><p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。<br><img src="https://gitee.com/sssuperbear/typora/raw/master/img/2200001-20201214151927691-2101847455.png" alt="img"></p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资 源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。 </p><p>以上<strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立</strong>，而只要上述条件之一不满足，就不会发生死锁。</p></li></ol><p><strong>一般死锁的应对策略有：</strong> </p><ol><li>死锁预防。如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。 </li><li>死锁避免。如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。 </li><li>死锁处理。破坏四个必要条件的其中一个，比如kill掉一个进程。 </li><li>死锁忽略。不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。</li></ol><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="通常系统CPU比较高是什么原因"><a href="#通常系统CPU比较高是什么原因" class="headerlink" title="通常系统CPU比较高是什么原因"></a>通常系统CPU比较高是什么原因</h3><h4 id="如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？"><a href="#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><p>windows上面用任务管理器看，linux下可以用 top 这个工具看。</p><ol><li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p 查找出cpu利用最厉害的pid号</li><li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查找出cpu利用率最厉害的线程号，比如top -H -p 1328</li><li>将获取到的线程号转换成16进制，去百度转换一下就行</li><li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; /tmp/t.dat，比如jstack 31365 &gt; /tmp/t.dat</li><li>编辑/tmp/t.dat文件，查找线程号对应的信息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java多线程与并发编程</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-03T10:58:02.000Z</published>
    <updated>2022-02-25T14:37:30.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java多线程与并发编程在面试中的高频考点"><a href="#Java多线程与并发编程在面试中的高频考点" class="headerlink" title="Java多线程与并发编程在面试中的高频考点"></a>Java多线程与并发编程在面试中的高频考点</h1><h2 id="1-说说什么是线程安全？如何实现线程安全？"><a href="#1-说说什么是线程安全？如何实现线程安全？" class="headerlink" title="1. 说说什么是线程安全？如何实现线程安全？"></a>1. 说说什么是线程安全？如何实现线程安全？</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>答：当多个线程同时访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不 需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><h3 id="实现线程安全的三大方法"><a href="#实现线程安全的三大方法" class="headerlink" title="实现线程安全的三大方法"></a>实现线程安全的三大方法</h3><ul><li>互斥同步：同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。Java中实现互斥同步的手段主要有synchronized关键字或ReentrantLock等。</li><li>非阻塞同步，类似是一种乐观并发的策略，比如CAS。</li><li>无同步方案，比如使用ThreadLocal</li></ul><h3 id="synchronized关键字或ReentrantLock的区别是什么？"><a href="#synchronized关键字或ReentrantLock的区别是什么？" class="headerlink" title="synchronized关键字或ReentrantLock的区别是什么？"></a>synchronized关键字或ReentrantLock的区别是什么？</h3><p><strong>相同点：</strong></p><ol><li>都是可重入锁</li><li>都保证了可见性和互斥性</li><li>都可以用于控制多线程对共享对象的访问</li></ol><p><strong>不同点：</strong></p><ol><li>ReentrantLock等待可中断</li><li>synchronized中的锁是非公平的，ReentrantLock默认也是非公平的，但是可以通过修改参数来实现共平锁。</li><li>ReentrantLock绑定多个条件</li><li>synchronized是Java中的关键字，是JVM级别的锁，而ReentrantLock是一个Lock接口下的实现类，是API层面的锁。</li><li>synchronized隐试获取锁和释放锁，ReetrantLock显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作。</li></ol><h2 id="2-Java中线程的状态有哪些？线程间的通信方式有哪些？"><a href="#2-Java中线程的状态有哪些？线程间的通信方式有哪些？" class="headerlink" title="2. Java中线程的状态有哪些？线程间的通信方式有哪些？"></a>2. Java中线程的状态有哪些？线程间的通信方式有哪些？</h2><p>答：Java中线程生命周期分为新建（New）、运行（Runnable）、阻塞（Blocked）、无限期等待（Waiting）、限期等待（Time Waiting）和结束（Terminated）这6种状态。</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>New</td><td>初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>Runnable</td><td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td>Blocked</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>Waiting</td><td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>Time Waiting</td><td>超时等待状态，该状态不同于Waiting，它是可以在指定的时间自行返回的</td></tr><tr><td>Terminated</td><td>终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><p>Java中线程间<strong>通信方式</strong>有：</p><p><strong>互斥量（Mutex）</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。</p><p><strong>信号量（Semphares）</strong>:它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</p><p><strong>事件（Event）</strong>：Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h3 id="sleep后进入什么状态，wait后进入什么状态？"><a href="#sleep后进入什么状态，wait后进入什么状态？" class="headerlink" title="sleep后进入什么状态，wait后进入什么状态？"></a>sleep后进入什么状态，wait后进入什么状态？</h3><p>答：sleep后进入Time waiting超市等待状态，wait后进入waiting状态</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul><li> sleep方法属于Thread类，wait方法属于Object类</li><li> sleep方法暂停执行指定的时间，让出CPU给其他线程，但其监控状态依然保持在指定的时间过后又会自动恢复运行状态</li><li> 在调用sleep方法的过程中，线程不会释放对象锁，而wait会释放对象锁。</li></ul><h3 id="wait为什么是数Object类下面的方法？"><a href="#wait为什么是数Object类下面的方法？" class="headerlink" title="wait为什么是数Object类下面的方法？"></a>wait为什么是数Object类下面的方法？</h3><p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait()就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及到硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p><h3 id="start方法和run方法有什么区别？"><a href="#start方法和run方法有什么区别？" class="headerlink" title="start方法和run方法有什么区别？"></a>start方法和run方法有什么区别？</h3><ol><li>star方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法周，线程会在后台执行，无须等待run方法体的代码执行完毕。</li><li>通过调用start方法启动一个线程时，此线程处于就绪状态，并没有运行。</li><li>run方法也叫线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码，在run方法运行结束后，该线程终止，CPU在调度其他线程。 </li></ol><h2 id="线程的几种实现"><a href="#线程的几种实现" class="headerlink" title="线程的几种实现"></a>线程的几种实现</h2><p><strong>1、继承Thread类，重写该类的run方法</strong></p><p><strong>2、实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象</strong></p><p><strong>3、使用Callable和Future接口创建线程。****具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程</strong></p><p><strong>继承Thread和实现Runnable接口实现多线程的区别：</strong></p><p>继承Thread类、实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下优势：</p><p> 1、可以避免由于Java的单继承特性而带来的局限；</p><p> 2、增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；</p><p> 3、适合多个相同程序代码的线程区处理同一资源的情况。</p><h2 id="几种线程同步的方法："><a href="#几种线程同步的方法：" class="headerlink" title="几种线程同步的方法："></a><strong>几种线程同步的方法：</strong></h2><p><strong>1、使用synchronized获取对象互斥锁：</strong>这种方式是最常用也比较安全的一种方式，采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。我们在使用同步的时候进来爸锁的粒度控制的精细一点，有时候没必要锁整个方法，只需要锁一个代码块即可达到我们的业务需求，这样避免其他线程阻塞时间过长造成性能上的影响。</p><p><strong>2、使用特殊域变量volatile实现线程同步：</strong>volatile修饰的变量是一种稍弱的同步机制，因为每个线程中的成员变量都会对这个对象的一个私有拷贝，每个线程获取的数据都是从私有拷贝内存中获取，而volatile修饰之后代表这个变量只能从共享内存中获取，禁止私有拷贝。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。从内存的可见性上来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。但代码中过度依赖于volatile变量来控制同步状态，往往比使用锁更加不安全，使用同步机制会更安全一些。当且仅当满足以下所有条件时，才应该使用volatile变量： 1、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 2、该变量没有包含在具有其他变量的不变式中。</p><p><strong>3、使用重入锁Lock实现线程同步:</strong> 在jdk1.5以后java.util.concurrent.locks包下提供了这一种方式来实现同步访问。因为synchronized同步之后会存在一个阻塞的过程，如果这个阻塞的时间过久，严重影响我们代码的质量以及带来系统性能上的问题。因为我们需要一种机制，让等待的线程到达一定时间之后能够响应中断，这就是Lock的作用。另外lock还可以知道线程有没有成功获取到对象锁，synchronized无法做到。Lock比synchronized提供更多的功能。但要注意的是：1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p><blockquote><p>注：关于Lock对象和synchronized关键字的选择： </p><p>​    a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。<br>​    b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码<br>​    c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 </p></blockquote><p><strong>4、使用ThreadLocal管理变量：</strong>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响；ThreadLocal 类的常用方法：</p><p><strong>5、使用阻塞队列实现线程同步：</strong>自从Java 1.5之后，在java.util.concurrent包下提供了若干个阻塞队列，或Redis消息队列等来实现同步等等。。。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.nowcoder.com/discuss/805699?source_id=profile_create_nctrack&channel=-1">Java多线程与并发编程在面试中的高频考点！</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-03T10:57:37.000Z</published>
    <updated>2022-01-07T02:01:41.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a><a href="https://www.nowcoder.com/discuss/807495?type=all&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=5C27F5E8CC05D3FEFF557CD8FC40F544-1641215720650">linux基本命令</a></h2><h6 id="cd-（change-directory：英文释义是改变目录）切换目录"><a href="#cd-（change-directory：英文释义是改变目录）切换目录" class="headerlink" title="cd （change directory：英文释义是改变目录）切换目录"></a>cd （change directory：英文释义是改变目录）切换目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../ ;跳到上级目录</span><br><span class="line">cd /opt ;不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line">cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。 </span><br></pre></td></tr></table></figure><h6 id="pwd-（print-working-directory：显示当前工作目录的绝对路径）"><a href="#pwd-（print-working-directory：显示当前工作目录的绝对路径）" class="headerlink" title="pwd （print working directory：显示当前工作目录的绝对路径）"></a>pwd （print working directory：显示当前工作目录的绝对路径）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd </span><br><span class="line">显示当前的绝对路径 </span><br></pre></td></tr></table></figure><h6 id="ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）"><a href="#ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）" class="headerlink" title="ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）"></a>ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -a ;显示所有文件夹,隐藏文件也显示出来</span><br><span class="line">ls -R ;连同子目录一起列出来 </span><br></pre></td></tr></table></figure><h6 id="ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）"><a href="#ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）" class="headerlink" title="ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）"></a>ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll -a ;显示所有文件,隐藏文件也显示出来</span><br><span class="line">ll -R ;连同子目录内容一起列出来</span><br><span class="line">ll -h ;友好展示详情信息,可以看大小</span><br><span class="line">ll -al ;即能显示隐藏文件又能显示详细列表。 </span><br></pre></td></tr></table></figure><h6 id="touch-（touch：创建文件）创建文件"><a href="#touch-（touch：创建文件）创建文件" class="headerlink" title="touch （touch：创建文件）创建文件"></a>touch （touch：创建文件）创建文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt  ;创建test.txt文件</span><br><span class="line">touch /opt/java/test.java ;在指定目录创建test.java文件 </span><br></pre></td></tr></table></figure><h6 id="mkdir-（mkdir：创建目录）-创建目录"><a href="#mkdir-（mkdir：创建目录）-创建目录" class="headerlink" title="mkdir （mkdir：创建目录） 创建目录"></a>mkdir （mkdir：创建目录） 创建目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹名称 ;在此目录创建文件夹</span><br><span class="line">mkdir /opt/java/jdk ;在指定目录创建文件夹 </span><br></pre></td></tr></table></figure><h6 id="cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"><a href="#cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）" class="headerlink" title="cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"></a>cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat lj.log ;快捷查看文件命令 </span><br><span class="line">Ctrl + c ;暂停显示文件</span><br><span class="line">Ctrl + d ;退出查看文件命令 </span><br></pre></td></tr></table></figure><h6 id="more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"><a href="#more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）" class="headerlink" title="more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"></a>more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回车：向下n行，需要定义，默认为1行。</span><br><span class="line">空格键：向下滚动一屏或Ctrl+F</span><br><span class="line">B：返回上一层或Ctrl+B</span><br><span class="line">q：退出more </span><br></pre></td></tr></table></figure><h6 id="less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"><a href="#less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）" class="headerlink" title="less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"></a>less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">less -m 显示类似于more命令的百分比。</span><br><span class="line">less -N 显示每行的行号。(大写的N)</span><br><span class="line">两参数一起使用如：less -mN 文件名，如此可分页并显示行号。</span><br><span class="line"></span><br><span class="line">空格键：前下一页或page down。</span><br><span class="line">回车：向下一行。</span><br><span class="line">b：后退一页 或 page up。</span><br><span class="line">q：退出。</span><br><span class="line">d：前进半页。</span><br><span class="line">u：后退半页 </span><br></pre></td></tr></table></figure><h6 id="tail（尾巴）-查看文件命令（看最后多少行）"><a href="#tail（尾巴）-查看文件命令（看最后多少行）" class="headerlink" title="tail（尾巴） 查看文件命令（看最后多少行）"></a>tail（尾巴） 查看文件命令（看最后多少行）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -10 ;文件名 看最后10行 </span><br></pre></td></tr></table></figure><h6 id="cp（copy单词缩写，复制功能）"><a href="#cp（copy单词缩写，复制功能）" class="headerlink" title="cp（copy单词缩写，复制功能）"></a>cp（copy单词缩写，复制功能）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下</span><br><span class="line">cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为aaa.log</span><br><span class="line">cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中 </span><br></pre></td></tr></table></figure><h6 id="mv（move单词缩写，移动功能，该文件名称功能）"><a href="#mv（move单词缩写，移动功能，该文件名称功能）" class="headerlink" title="mv（move单词缩写，移动功能，该文件名称功能）"></a>mv（move单词缩写，移动功能，该文件名称功能）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下</span><br><span class="line">mv java.log mysql.log ;把java.log改名为mysql.log </span><br></pre></td></tr></table></figure><h6 id="rm（remove：移除的意思）删除文件，或文件夹"><a href="#rm（remove：移除的意思）删除文件，或文件夹" class="headerlink" title="rm（remove：移除的意思）删除文件，或文件夹"></a>rm（remove：移除的意思）删除文件，或文件夹</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件    </span><br><span class="line">-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。 </span><br><span class="line">-rf 强制删除文件夹及内容</span><br><span class="line"></span><br><span class="line">rm 文件名 ;安全删除命令  （yes删除 no取消）</span><br><span class="line">rm -rf 强制删除文件夹及内容</span><br><span class="line">rm -rf *  删除当前目录下的所有内容。</span><br><span class="line">rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。 </span><br></pre></td></tr></table></figure><h6 id="find-（find：找到的意思）查找指定文件或目录"><a href="#find-（find：找到的意思）查找指定文件或目录" class="headerlink" title="find （find：找到的意思）查找指定文件或目录"></a>find （find：找到的意思）查找指定文件或目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 表示0~多个任意字符。</span><br><span class="line"></span><br><span class="line">find -name 文件名;按照指定名称查找在当前目录下查找文件</span><br><span class="line">find / -name 文件名按照指定名称全局查找文件</span><br><span class="line">find -name &#x27;*文件名&#x27; ;任意前缀加上文件名在当前目录下查找文件</span><br><span class="line">find / -name &#x27;*文件名*&#x27; ;全局进行模糊查询带文件名的文件 </span><br></pre></td></tr></table></figure><h6 id="vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）"><a href="#vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）" class="headerlink" title="vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）"></a>vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）</h6><h6 id="vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）"><a href="#vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）" class="headerlink" title="vim （VI IMproved：改进版视觉）改进版文本编辑器   （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）"></a>vim （VI IMproved：改进版视觉）改进版文本编辑器   （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入”vim 文件名” 打开文件，刚刚时是”一般模式”。</span><br><span class="line"></span><br><span class="line">一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。</span><br><span class="line">插入模式：可以编辑文件内容。</span><br><span class="line">底行模式：可以进行强制退出操作,不保存   :q!</span><br><span class="line">         可以进行保存并退出操作       :wq</span><br><span class="line"></span><br><span class="line">按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。</span><br><span class="line">在编辑模式下按”Esc” 即可到一般模式</span><br><span class="line">在一般模式下按”:”，冒号进入底行模式。</span><br><span class="line"></span><br><span class="line">在一般模式下的快捷键</span><br><span class="line">    dd ;删除一整行</span><br><span class="line">    X ;向前删除  等同于windowns系统中的删除键</span><br><span class="line">    x ;向后删除和大写x相反方向</span><br><span class="line">    Ctrl + f ;向后看一页</span><br><span class="line">    Ctrl + b ;向前看一页</span><br><span class="line">    u ;撤销上一步操作</span><br><span class="line">    /word ;向下查找word关键字  输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反）</span><br><span class="line">    ?log ;向上查找log关键字  输入:n查找上一个,N查找下一个</span><br><span class="line">    :1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的</span><br><span class="line">    :0 ;光标移动到第一行</span><br><span class="line">    :$ ;光标移动到最后一行</span><br><span class="line">    :300 ;光标移动到300行,输入多少数字移动到多少行</span><br><span class="line">    :w  ;保存</span><br><span class="line">    :w! ;强制保存</span><br><span class="line">    :q  ;退出</span><br><span class="line">    :q! ;强制退出</span><br><span class="line">    5dd ;删除后面5行,打一个参数为自己填写</span><br><span class="line">    5x ;删除此光标后面5个字符</span><br><span class="line">    d1G ;删除此光标之前的所有</span><br><span class="line">    d0 ;从光标当前位置删除到此行的第一个位置</span><br><span class="line">    yy ;复制</span><br><span class="line">    p ;在光标的下面进行粘贴</span><br><span class="line">    P ;在光标的上门进行粘贴 </span><br></pre></td></tr></table></figure><h6 id="管道命令（把多个命令组合起来使用）"><a href="#管道命令（把多个命令组合起来使用）" class="headerlink" title="| 管道命令（把多个命令组合起来使用）"></a>| 管道命令（把多个命令组合起来使用）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管道命令的语法：命令1 | 命令2 | 命令3。 </span><br></pre></td></tr></table></figure><h6 id="grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过"><a href="#grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过" class="headerlink" title="grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过"></a>grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单独使用：</span><br><span class="line">grep String test.java ；在test.java文件中查找String的位置，返回整行</span><br><span class="line">一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）</span><br><span class="line"></span><br><span class="line">ps aux|grep java ；查找带java关键字的进程</span><br><span class="line">ll |grep java ；查找带java关键字的文件夹及文件 </span><br></pre></td></tr></table></figure><h6 id="yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）"><a href="#yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）" class="headerlink" title="yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）"></a>yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件</span><br><span class="line">#等待下载完了就可以输入：</span><br><span class="line"></span><br><span class="line">rz  从win系统中选择文件上传到Linux系统中</span><br><span class="line"></span><br><span class="line">sz  文件名 选择Linux系统的文件复制到win系统中 </span><br></pre></td></tr></table></figure><h6 id="tar-（解压-压缩-命令）"><a href="#tar-（解压-压缩-命令）" class="headerlink" title="tar （解压 压缩 命令）"></a>tar （解压 压缩 命令）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用的组合命令：</span><br><span class="line">-z 是否需要用gzip压缩。</span><br><span class="line">-c 建立一个压缩文件的参数指令(create) –压缩</span><br><span class="line">    -x 解开一个压缩文件的参数指令(extract) –解压  </span><br><span class="line">    -v 压缩的过程中显示文件(verbose)</span><br><span class="line">    -f 使用档名，在f之后要立即接档中(file)</span><br><span class="line">    常用解压参数组合：zxvf</span><br><span class="line">    常用压缩参数组合：zcvf </span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录</span><br><span class="line"></span><br><span class="line">压缩命令：（注意 语法有点反了，我反正每次都搞反）</span><br><span class="line">tar -zcvf redis-3.2.8.tar.gz  redis-3.2.8/  ;语法 tar -zcvf  压缩后的名称  要压缩的文件</span><br><span class="line">tar -zcvf 压缩后的文件（可指定目录）  要压缩的文件（可指定目录） </span><br></pre></td></tr></table></figure><h6 id="ps-（process-status：进程状态，类似于windows的任务管理器）"><a href="#ps-（process-status：进程状态，类似于windows的任务管理器）" class="headerlink" title="ps （process status：进程状态，类似于windows的任务管理器）"></a>ps （process status：进程状态，类似于windows的任务管理器）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用组合：ps -ef     标准的格式查看系统进程</span><br><span class="line">      ps -aux    BSD格式查看系统进程</span><br><span class="line">      ps -aux|grep redis  BSD格式查看进程名称带有redis的系统进程（常用技巧）</span><br><span class="line">//显示进程的一些属性,需要了解（ps aux）</span><br><span class="line">USER     //用户名</span><br><span class="line">PID         //进程ID号,用来杀死进程的</span><br><span class="line">%CPU     //进程占用的CPU的百分比</span><br><span class="line">%MEM     //占用内存的的百分比</span><br><span class="line">VSZ      //该进程使用的虚拟內存量（KB）</span><br><span class="line">RSS      //该进程占用的固定內存量（KB）</span><br><span class="line">STAT     //进程的状态</span><br><span class="line">START    //该进程被触发启动时间</span><br><span class="line">TIME     //该进程实际使用CPU运行的时间 </span><br></pre></td></tr></table></figure><h6 id="clear-清屏命令。（强迫症患者使用）"><a href="#clear-清屏命令。（强迫症患者使用）" class="headerlink" title="clear 清屏命令。（强迫症患者使用）"></a>clear 清屏命令。（强迫症患者使用）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程）</span><br><span class="line">（ps类似于打开任务管理器，kill类似于关闭进程）</span><br><span class="line">    kill -5 进程的PID ;推荐,和平关闭进程</span><br><span class="line">    kill -9 PID ;不推荐,强制杀死进程 </span><br></pre></td></tr></table></figure><h6 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改）</span><br><span class="line">如果此命令输入无效，先输入yum -y install net-tools</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure><h6 id="ping-（用于检测与目标的连通性）语法：ping-ip地址"><a href="#ping-（用于检测与目标的连通性）语法：ping-ip地址" class="headerlink" title="ping （用于检测与目标的连通性）语法：ping ip地址"></a>ping （用于检测与目标的连通性）语法：ping ip地址</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">1、在Windows操作系统中cmdipconfig，查看本机IP地址：</span><br><span class="line">2、再到LInux系统中输入 ping ip地址</span><br><span class="line">（公司电脑，我就不暴露Ip了,没图片  自己去试）</span><br><span class="line">按Ctrl + C 可以停止测试。 </span><br></pre></td></tr></table></figure><h6 id="free-命令-（显示系统内存）"><a href="#free-命令-（显示系统内存）" class="headerlink" title="free 命令 （显示系统内存）"></a>free 命令 （显示系统内存）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</span><br><span class="line">-b 以Byte显示内存使用情况</span><br><span class="line">-k 以kb为单位显示内存使用情况</span><br><span class="line">-m 以mb为单位显示内存使用情况</span><br><span class="line">-g 以gb为单位显示内存使用情况</span><br><span class="line">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">-t 显示内存使用总合 </span><br></pre></td></tr></table></figure><h6 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</span><br><span class="line">-c 显示完整的进程命令</span><br><span class="line">-s 保密模式</span><br><span class="line">-p &lt;进程号&gt; 指定进程显示</span><br><span class="line">-n &lt;次数&gt;循环显示次数 </span><br></pre></td></tr></table></figure><h6 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Linux netstat命令用于显示网络状态。</span><br><span class="line">#利用netstat指令可让你得知整个Linux系统的网络情况。</span><br><span class="line">#语法：</span><br><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] </span><br></pre></td></tr></table></figure><h6 id="file-（可查看文件类型）"><a href="#file-（可查看文件类型）" class="headerlink" title="file （可查看文件类型）"></a>file （可查看文件类型）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名 </span><br></pre></td></tr></table></figure><h6 id="重启linux"><a href="#重启linux" class="headerlink" title="重启linux"></a>重启linux</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 重启命令：reboot </span><br></pre></td></tr></table></figure><h6 id="关机linux"><a href="#关机linux" class="headerlink" title="关机linux"></a>关机linux</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 关机命令：halt </span><br></pre></td></tr></table></figure><h6 id="同步时间命令"><a href="#同步时间命令" class="headerlink" title="同步时间命令"></a>同步时间命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp1.aliyun.com </span><br></pre></td></tr></table></figure><h6 id="更改为北京时间命令"><a href="#更改为北京时间命令" class="headerlink" title="更改为北京时间命令"></a>更改为北京时间命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </span><br></pre></td></tr></table></figure><h6 id="查看时间命令："><a href="#查看时间命令：" class="headerlink" title="查看时间命令："></a>查看时间命令：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
