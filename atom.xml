<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuperBear&#39;s blog</title>
  
  
  <link href="https://sssuper-bear.github.io/atom.xml" rel="self"/>
  
  <link href="https://sssuper-bear.github.io/"/>
  <updated>2022-01-03T12:17:36.277Z</updated>
  <id>https://sssuper-bear.github.io/</id>
  
  <author>
    <name>SuperBear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手撕包菜</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/</id>
    <published>2022-01-03T12:16:18.000Z</published>
    <updated>2022-01-03T12:17:36.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>typora-copy-images-to: images</p><hr><h3 id="手撕包菜"><a href="#手撕包菜" class="headerlink" title="手撕包菜"></a><a href="https://www.bilibili.com/video/BV1hh41197hh?from=search&seid=4921812292540006215">手撕包菜</a></h3><ul><li><p>包菜去根，用手撕成小块 <strong>根部用刀拍一下</strong></p></li><li><p>清水+少许食用盐，在水中清洗浸泡彻底洗净</p></li><li><p>洗好以后控水备用</p></li><li><p>几粒大蒜拍碎+干辣椒+花椒</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126162351153.png" alt="image-20210126162351153"></p></li><li><p>五花肉切成薄片</p></li><li><p><strong>猪油+五花肉来炒</strong>这样的才香</p></li><li><p>猪油熬化以后加入五花肉片</p></li><li><p>先将五花肉煸炒出油，肉片变色，微微发黄时，加入准备好的小料，煸炒出香味，（火要大，锅要热，油要多）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102537195.png" alt="image-20210127102537195"></p></li><li><p>彻底炒出香味以后放入准备好的包菜</p></li><li><p>少许米酒或者料酒沿锅边淋入去腥增香</p></li><li><p>放入少许米醋或者香醋（先放醋，炒出来的包菜更脆）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102716126.png" alt="image-20210127102716126"></p></li><li><p>大火将包菜炒至塌陷</p></li><li><p>塌陷以后开始调味（适量盐+少许白糖+蒸鱼豉油）</p></li><li><p>大火翻炒均匀</p></li><li><p>香醋沿锅边淋入将整道菜的香味彻底激发出来</p></li><li><p>这道菜要的是干香脆爽，翻炒时间不要太长</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127103410622.png" alt="image-20210127103410622"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>可乐鸡翅</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/</id>
    <published>2022-01-03T12:16:12.000Z</published>
    <updated>2022-01-03T12:16:48.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="可乐鸡翅"><a href="#可乐鸡翅" class="headerlink" title="可乐鸡翅"></a><a href="https://www.bilibili.com/video/BV1pJ411v7S9?from=search&seid=2151627749794461067">可乐鸡翅</a></h3><ul><li><p>原料</p><ul><li>鸡翅250g（11个左右）</li></ul></li><li><p>做法</p><ul><li><p>鸡翅泡水解冻</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155937382.png" alt="image-20210126155937382"></p></li><li><p>捞出，加姜片料酒腌制20分钟（用手抓一抓，搅拌均匀）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155946527.png" alt="image-20210126155946527"></p></li><li><p>放入锅中焯水捞出</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160034775.png" alt="image-20210126160034775"></p></li><li><p>锅内热油加入姜片</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160120839.png" alt="image-20210126160120839"></p></li><li><p>鸡翅正面朝下煎至金黄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160210270.png" alt="image-20210126160210270"></p></li><li><p>加入调味</p><ul><li>一勺料酒</li><li>一勺生抽</li><li>半勺老抽</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160624263.png" alt="image-20210126160624263"></p></li><li><p>翻炒均匀上色</p></li><li><p>可乐一听倒入2/3罐子</p></li><li><p>放入半勺盐调味，盖上锅盖煮沸</p></li><li><p>放入香料：香叶八角都可以</p></li><li><p>大火煮至汤汁收干</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160844786.png" alt="image-20210126160844786"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora自动上传图片</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</id>
    <published>2022-01-03T12:13:16.000Z</published>
    <updated>2022-01-03T12:13:59.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora-图片自动上传服务器设置"><a href="#Typora-图片自动上传服务器设置" class="headerlink" title="Typora 图片自动上传服务器设置"></a>Typora 图片自动上传服务器设置</h1><ul><li>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>（比较稳定建议使用）</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/1972718-20200323210552751-1313111323.png" alt="img"></p><ul><li><p>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，有两个插件都可以用</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323194553126.png" alt="image-20200323194553126"></p></li><li><p>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323195546145.png" alt="image-20200323195546145"></p></li><li><p>token获取：进入码云，点击进入设置页</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323200633225.png" alt="image-20200323200847954"></p></li><li><p>在PicGo配置Gitee</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220103171035455.png" alt="image-20220103171035455"></p></li><li><p>配置Typora，点击 文件，偏好设置，选择图像，设置PicGo二进制文件的路径</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323201738802.png" alt="image-20200323201738802"></p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/">https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</a></li><li><a href="https://www.cnblogs.com/qtzd/p/12554902.html">https://www.cnblogs.com/qtzd/p/12554902.html</a></li><li><a href="https://blog.csdn.net/weixin_41800884/article/details/104718367">https://blog.csdn.net/weixin_41800884/article/details/104718367</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>希腊字母表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</id>
    <published>2022-01-03T12:11:42.000Z</published>
    <updated>2022-01-03T12:12:08.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h1><table><thead><tr><th>希腊字母小写、大写</th><th>LaTeX形式</th><th>希腊字母小写、大写</th><th>LaTeX形式</th></tr></thead><tbody><tr><td>α <em><strong>A</strong></em></td><td>\alpha A</td><td>μ <em><strong>N</strong></em></td><td>\mu N</td></tr><tr><td>β <em><strong>B</strong></em></td><td>\beta B</td><td>ξ Ξ</td><td>\xi \Xi</td></tr><tr><td>γ Γ</td><td>\gamma \Gamma</td><td><strong>o</strong> <em><strong>O</strong></em></td><td>o O</td></tr><tr><td>δ Δ</td><td>\delta \ Delta</td><td>π Π</td><td>\pi \Pi</td></tr><tr><td>ϵ ε <em><strong>E</strong></em></td><td>\epsilon \varepsilon E</td><td>ρ ϱ <em><strong>P</strong></em></td><td>\rho \varrho P</td></tr><tr><td>ζ <em><strong>Z</strong></em></td><td>\zeta Z</td><td>σ Σ</td><td>\sigma \Sigma</td></tr><tr><td>η <em><strong>H</strong></em></td><td>\eta H</td><td>τ <em><strong>T</strong></em></td><td>\tau T</td></tr><tr><td>θ ϑ Θ</td><td>\theta \vartheta \Theta</td><td>υ Υ</td><td>\upsilon \Upsilon</td></tr><tr><td>ι <em><strong>I</strong></em></td><td>\iota I</td><td>ϕ φ Φ</td><td>\phi \varphi \Phi</td></tr><tr><td>κ <em><strong>K</strong></em></td><td>\kappa K</td><td>χ <em><strong>X</strong></em></td><td>\chi X</td></tr><tr><td>λ Λ</td><td>\lambda \Lambda</td><td>ψ Ψ</td><td>\psi \Psi</td></tr><tr><td>μ <em><strong>M</strong></em></td><td>\mu M</td><td>ω Ω</td><td>\omega \Omega</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源代码包”和“二进制包”的区别</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-03T11:33:43.000Z</published>
    <updated>2022-01-03T11:44:33.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="“源代码包”和“二进制包”的区别"><a href="#“源代码包”和“二进制包”的区别" class="headerlink" title="“源代码包”和“二进制包”的区别"></a><a href="https://blog.csdn.net/Tomstrong_369/article/details/51741012">“源代码包”和“二进制包”的区别</a></h1><p>源代码方式和二进制包是软件包的两种形式。二进制包里面包括了已经经过编译，可以马上运行的程 序。你只需要下载和解包（安装）它们以后，就马上可以使用。源代码包里面包括了程序原始的程序代码，需要在你的计算机上进行编译以后才可以产生可以运行程 序,所以从源代码安装的时间会比较长。</p><p>source code 是程序員寫的碼， binary code 是機器跑的碼。 source code 得經過 compile 才能成為 binary code 。 </p><p>RPM 有分兩種：binary rpm 跟 source rpm 。<br>前者是編好的 binary ，安裝就可用。<br>後者是還沒編好的 source ，需 rebuild 之後才能安裝。</p><p>rpm格式很好区分，二进制格式的包名字很长，都带有版本号、适应平台、适应的硬件类型等，而源码格式仅仅就是一个版本号的tar包。<br>mysql-5.0.45.tar.gz 是 源码包    像这样的 mysql-5.0.45-linux-x86_64-glibc23.tar.gz   是二进制包</p><p>如果你用过压缩工具就会明白，压缩包未必就是软件，它也可能是备份的许多图片，也可能是打包在一起的普通资料，要分辨它到底是什么最好的办法就是查看包里的文件清单，使用命令tar ztvf *. 或者tar ytvf *.bz2</p><p>源代码包里的文件往往会含有种种源代码文件，头文件*.h、c代码源文件*.c、C++代码源文件*.cc/*.cpp等；而二进制包里的文件则会有可执行文件（与软件同名的往往是主执行文件），标志是其所在路径含有名为bin的目录（仅有少数例外）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="科普" scheme="https://sssuper-bear.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实战例子</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/</id>
    <published>2022-01-03T10:58:10.000Z</published>
    <updated>2022-01-03T11:26:12.510Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">腾讯一面</a>：</p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>进程间有六种通信方式：</p><ol><li><strong>管道（pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</li><li><strong>信号（signal）</strong>：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的</li><li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限的进程可以从消息队列中读取信息</li><li><strong>共享内存（share memory）</strong>：他使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量（也就是一个进行在未完成写操作之前，另一个进程不能读取）</li><li><strong>信号量（semaphore）</strong>：它是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据（而信号量一般常用于保护一段代码，使其每次只被一个执行线程运行）。对于二值信号量（0-1），信号量大于0时，可以对进程操作，等于0时要等待，知道信号量大于0</li><li><strong>套接字（socket）</strong>：一种更为一般的进程通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛</li></ol><h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><p><strong>僵尸进程：</strong>一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait或wait pid来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。</p><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记在该进程的退出状态等信息，供其他进程收集，除此之外，僵尸进程需要它的父进程来为它收尸，如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，他还是能被清除的。但是如果父进程是进入一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会很多僵尸进程。</p><p><strong>僵尸进程解决</strong></p><ul><li>调用wait函数，进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，知道有一个出现为止</li><li>当子进程终止时，内核就会向它的父进程发送一个SIGCHLD信号，当父进程接收到SIGCHLD信号后就应该调用wait或waitpid函数对子进程进行善后处理，释放子进程占用的资源</li></ul><p><strong>孤儿进程：</strong>一个父进程退出，而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并有init进程对它们完成状态收集的工作</p><p>子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会向僵尸进程那样占用ID，损害运行系统。</p><h4 id="TCP为啥需要三次握手"><a href="#TCP为啥需要三次握手" class="headerlink" title="TCP为啥需要三次握手"></a>TCP为啥需要三次握手</h4><h5 id="三次握手原理"><a href="#三次握手原理" class="headerlink" title="三次握手原理"></a>三次握手原理</h5><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303831393232333433313438.jpg" alt="这里写图片描述"></p><ol><li><p>上图的名词解释</p><ul><li>SYN：同步序号。<strong>它表示建立连接</strong>。TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此随机选取一个序列号为seq=x数据包（该数据包里就是一个标记seq，并没有任何有效的数据）</li><li>ACK：确认序号。<strong>它表示响应</strong>（都能响应了 那肯定上一步就连接成功了啊，所以说ACK=1代表确认连接成功啦）</li></ul><p>因此<strong>SYN和ACK同时为1，表示建立连接之后的响应</strong>；而只是<strong>单个的SYN=1，表示的只是建立连接。</strong></p><ul><li>seq：（sequence number）序列号。他是发送端数据包的初始序列号。<strong>seq=x表示发送端数据包的初始序号为x</strong>（seq=0就代表这是第0号帧）</li><li>ack：（acknowledge number）确认号。它是对这次收到数据包的确认，以及对下次收到数据包的期待。<strong>ack=x+1表示我方到x位置的所有数据都已正确收到，且我方告知对方：我期待你下次给我发送包的初始序号（seq）是x+1。</strong></li></ul><p>为了方便记忆，可以这么理解：SYN/ACK是TCP协议层面的标记，而seq/ack是数据层面的标记。</p></li></ol><h5 id="TCP三次握手过程："><a href="#TCP三次握手过程：" class="headerlink" title="TCP三次握手过程："></a><strong>TCP三次握手过程：</strong></h5><ol><li><strong>首先Client向Server发送连接：SYN=1，seq=x；</strong><ul><li><strong>因为</strong>要<strong>建立连接，所以SYN=1</strong>；又<strong>因为</strong>TCP规定SYN=1时不能携带数据，但要消耗一个序号，<strong>所以</strong>Client随机选取一个<strong>初始序号seq=x</strong>。（因为并没有相应动作，所以这里没ACK什么事，我们就认为ACK=0吧）</li><li>发送后Client进入syn_sent状态，表示客户端等待服务器的回复</li></ul></li><li><strong>Server收到请求后 再向Client发送确认：SYN=1，ACK=1，seq=y，ack=x+1；</strong><ul><li>因为Server建立连接后做出了相应，所以SYN=1，ACK=1.因为TCP规定SYN=1时不能携带数据，但要消耗一个序号，所以Server随机选取一个初始序号seq=y。又因为Server到x为止的所有数据都已正确收到了，且Server告诉Client：我期待你下次给我发送包的初始序号（seq）是x+1，所以ack=x+1。</li><li>发送后服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待Client的确认。</li></ul></li><li><strong>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据：ACK=1，seq=x+1,ack=y+1;连接建立</strong><ul><li><strong>因为</strong>有响应动作，<strong>所以ACK=1</strong>（因为要携带发送的数据，所以这没SYN什么事）。<strong>因为2中s</strong>erver已经告诉了这次它想收到包的初始序列号是x+1，<strong>所以初始序号为seq=x+1</strong>。<strong>又因为</strong>Client到y为止的所有数据都已正确收到了，准备接收序列号为y+1的包，<strong>所以ack=y+1</strong></li><li>server收到后，这个TCP连接就进入到Established状态，就可以发起http请求了。</li></ul></li></ol><p><strong>形象些：</strong></p><ul><li><p>第一次握手，由浏览器发起，告诉服务器我要发送请求了</p></li><li><p>第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧</p></li><li><p>第三次握手，由浏览器发送，告诉服务器，我马上发了，准备接收吧</p></li></ul><h5 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h5><p>  其实这是由TCP的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认<code>双方</code>的<code>接收和发送能力</code>,不然容易出现丢包的现象</p><ul><li>第一次握手: 服务端 可以确认<code>客户端</code>具有发送能力</li><li>第二次握手: 客户端 可以确认<code>服务端</code>具有接收能力和发送能力</li><li>第三次握手: 服务端 可以确认<code>客户端</code>具有接收能力</li></ul><h5 id="为什么不能改成两次握手？"><a href="#为什么不能改成两次握手？" class="headerlink" title="为什么不能改成两次握手？"></a>为什么不能改成两次握手？</h5><p>如果两次握手，则会出现下面这种情况：</p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。</p><h5 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h5><p>其实第三次握手的时候,是可以携带数据的.但是,第一次,第二次握手不可以携带数据.</p><p>为什么这样呢?假如第一次握手可以携带数据的话,如果有人要恶意攻击服务器,那他每次都在第一次握手中的<code>SYN</code>报文中放入大量的数据.因为攻击者根本就不理服务器的接收 发送能力是否正常,然后疯狂重复发<code>SYN</code>报文的话,这会让服务器话费很多时间 内存空间来接收这些报文.</p><p>也就是说,第一次握手不可以放数据,其中一个简单的原因就是会让服务器更加容易受到攻击了.而对于第三次的话,此时客户端已经处于<code>ESTAB-LISHED</code>状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h5 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h5><p>static_assert这个关键字，用来做编译期间的断言，因此叫做静态断言。</p><p>语法：static_assert(常量表达式，提示字符串)——如果第一个参数常量表达式的值为真（true或者非零值），那么static_assert不做任何事情，就像它不存在一样，否则会产生一条编译错误，错误位置就是该static_assert语句所在行，错误提示就是第二个参数提示字符串。</p><p>编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。</p><p>static_assert的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果使用变量，则会导致错误</p><h5 id="write和fwrite"><a href="#write和fwrite" class="headerlink" title="write和fwrite"></a>write和fwrite</h5><p>fwrite：带缓冲区；write：不带缓冲区</p><h5 id="程序中1-0是在编译期出错还是在运行的时候出错"><a href="#程序中1-0是在编译期出错还是在运行的时候出错" class="headerlink" title="程序中1/0是在编译期出错还是在运行的时候出错"></a>程序中1/0是在编译期出错还是在运行的时候出错</h5><p>在linux系统中gcc编译期测试：编译可以通过，运行时报错</p><p>参考：</p><ul><li><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></li><li><a href="https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md">https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java多线程与并发编程</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-03T10:58:02.000Z</published>
    <updated>2022-01-03T11:26:17.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java多线程与并发编程在面试中的高频考点"><a href="#Java多线程与并发编程在面试中的高频考点" class="headerlink" title="Java多线程与并发编程在面试中的高频考点"></a>Java多线程与并发编程在面试中的高频考点</h1><h2 id="1-说说什么是线程安全？如何实现线程安全？"><a href="#1-说说什么是线程安全？如何实现线程安全？" class="headerlink" title="1. 说说什么是线程安全？如何实现线程安全？"></a>1. 说说什么是线程安全？如何实现线程安全？</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>答：当多个线程同时访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不 需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><h3 id="实现线程安全的三大方法"><a href="#实现线程安全的三大方法" class="headerlink" title="实现线程安全的三大方法"></a>实现线程安全的三大方法</h3><ul><li>互斥同步：同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。Java中实现互斥同步的手段主要有synchronized关键字或ReentrantLock等。</li><li>非阻塞同步，类似是一种乐观并发的策略，比如CAS。</li><li>无同步方案，比如使用ThreadLocal</li></ul><h3 id="synchronized关键字或ReentrantLock的区别是什么？"><a href="#synchronized关键字或ReentrantLock的区别是什么？" class="headerlink" title="synchronized关键字或ReentrantLock的区别是什么？"></a>synchronized关键字或ReentrantLock的区别是什么？</h3><p><strong>相同点：</strong></p><ol><li>都是可重入锁</li><li>都保证了可见性和互斥性</li><li>都可以用于控制多线程对共享对象的访问</li></ol><p><strong>不同点：</strong></p><ol><li>ReentrantLock等待可中断</li><li>synchronized中的锁是非公平的，ReentrantLock默认也是非公平的，但是可以通过修改参数来实现共平锁。</li><li>ReentrantLock绑定多个条件</li><li>synchronized是Java中的关键字，是JVM级别的锁，而ReentrantLock是一个Lock接口下的实现类，是API层面的锁。</li><li>synchronized隐试获取锁和释放锁，ReetrantLock显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作。</li></ol><h2 id="2-Java中线程的状态有哪些？线程间的通信方式有哪些？"><a href="#2-Java中线程的状态有哪些？线程间的通信方式有哪些？" class="headerlink" title="2. Java中线程的状态有哪些？线程间的通信方式有哪些？"></a>2. Java中线程的状态有哪些？线程间的通信方式有哪些？</h2><p>答：Java中线程生命周期分为新建（New）、运行（Runnable）、阻塞（Blocked）、无限期等待（Waiting）、限期等待（Time Waiting）和结束（Terminated）这6种状态。</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>New</td><td>初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>Runnable</td><td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td>Blocked</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>Waiting</td><td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>Time Waiting</td><td>超时等待状态，该状态不同于Waiting，它是可以在指定的时间自行返回的</td></tr><tr><td>Terminated</td><td>终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><p>Java中线程间<strong>通信方式</strong>有：</p><p><strong>互斥量（Mutex）</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。</p><p><strong>信号量（Semphares）</strong>:它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</p><p><strong>事件（Event）</strong>：Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h3 id="sleep后进入什么状态，wait后进入什么状态？"><a href="#sleep后进入什么状态，wait后进入什么状态？" class="headerlink" title="sleep后进入什么状态，wait后进入什么状态？"></a>sleep后进入什么状态，wait后进入什么状态？</h3><p>答：sleep后进入Time waiting超市等待状态，wait后进入waiting状态</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul><li> sleep方法属于Thread类，wait方法属于Object类</li><li> sleep方法暂停执行指定的时间，让出CPU给其他线程，但其监控状态依然保持在指定的时间过后又会自动恢复运行状态</li><li> 在调用sleep方法的过程中，线程不会释放对象锁，而wait会释放对象锁。</li></ul><h3 id="wait为什么是数Object类下面的方法？"><a href="#wait为什么是数Object类下面的方法？" class="headerlink" title="wait为什么是数Object类下面的方法？"></a>wait为什么是数Object类下面的方法？</h3><p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait()就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及到硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p><h3 id="start方法和run方法有什么区别？"><a href="#start方法和run方法有什么区别？" class="headerlink" title="start方法和run方法有什么区别？"></a>start方法和run方法有什么区别？</h3><ol><li>star方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法周，线程会在后台执行，无须等待run方法体的代码执行完毕。</li><li>通过调用start方法启动一个线程时，此线程处于就绪状态，并没有运行。</li><li>run方法也叫线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码，在run方法运行结束后，该线程终止，CPU在调度其他线程。 </li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.nowcoder.com/discuss/805699?source_id=profile_create_nctrack&channel=-1">Java多线程与并发编程在面试中的高频考点！</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/</id>
    <published>2022-01-03T10:57:37.000Z</published>
    <updated>2022-01-03T11:26:36.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="String，StringBuilder，StringBuffer的区别："><a href="#String，StringBuilder，StringBuffer的区别：" class="headerlink" title="String，StringBuilder，StringBuffer的区别："></a>String，StringBuilder，StringBuffer的区别：</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.操作数量较少的字符串用String，不可修改的字符串；</span><br><span class="line">2.在单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；</span><br><span class="line">3.在多线程且操作大量字符串用StringBuffer，线程安全，可修改。</span><br></pre></td></tr></table></figure><h4 id="String的拼接优化"><a href="#String的拼接优化" class="headerlink" title="String的拼接优化:"></a>String的拼接优化:</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = s1 + s2;</span><br><span class="line">java实际运行时优化为</span><br><span class="line">String s = new StringBuilder(s1).append(s2).toString();</span><br></pre></td></tr></table></figure><h4 id="Java支持的数据类型有哪些"><a href="#Java支持的数据类型有哪些" class="headerlink" title="Java支持的数据类型有哪些"></a>Java支持的数据类型有哪些</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br></pre></td></tr></table></figure><h4 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱</span><br></pre></td></tr></table></figure><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Int是java的原始数据类型，Integer是java为int提供的封装类。</span><br><span class="line">Java为每个原始类型提供了封装类。</span><br><span class="line">原始类型封装类</span><br><span class="line">booleanBoolean</span><br><span class="line">charCharacter</span><br><span class="line">byteByte</span><br><span class="line">shortShort</span><br><span class="line">intInteger</span><br><span class="line">longLong</span><br><span class="line">floatFloat</span><br><span class="line">doubleDouble</span><br></pre></td></tr></table></figure><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</span><br></pre></td></tr></table></figure><h4 id="Java中如何跳出当前的多重嵌套循环"><a href="#Java中如何跳出当前的多重嵌套循环" class="headerlink" title="Java中如何跳出当前的多重嵌套循环"></a>Java中如何跳出当前的多重嵌套循环</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</span><br></pre></td></tr></table></figure><h4 id="比较一下Java和JavaSciprt"><a href="#比较一下Java和JavaSciprt" class="headerlink" title="比较一下Java和JavaSciprt"></a>比较一下Java和JavaSciprt</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。</span><br><span class="line">下面对两种语言间的异同作如下比较：</span><br><span class="line">- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</span><br><span class="line">- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）</span><br><span class="line">- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</span><br><span class="line">- 代码格式不一样</span><br></pre></td></tr></table></figure><h4 id="数组-Array-和列表-ArrayList-的区别"><a href="#数组-Array-和列表-ArrayList-的区别" class="headerlink" title="数组(Array)和列表(ArrayList)的区别"></a>数组(Array)和列表(ArrayList)的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array和ArrayList的不同点：</span><br><span class="line">Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</span><br><span class="line">Array大小是固定的，ArrayList的大小是动态变化的。</span><br><span class="line">ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</span><br><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></table></figure><h4 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</span><br><span class="line">引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递</span><br></pre></td></tr></table></figure><h4 id="为什么会出现4-0-3-6-0-40000001这种现象"><a href="#为什么会出现4-0-3-6-0-40000001这种现象" class="headerlink" title="为什么会出现4.0-3.6=0.40000001这种现象"></a>为什么会出现4.0-3.6=0.40000001这种现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</span><br><span class="line">出现0.40000001的情况可以使用BigDecimal类解决，其实浮点数基本上都不精确，BigDecimal使用String来解决的</span><br></pre></td></tr></table></figure><h4 id="十进制的数在内存中是怎么存的"><a href="#十进制的数在内存中是怎么存的" class="headerlink" title="十进制的数在内存中是怎么存的"></a>十进制的数在内存中是怎么存的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码的形式。把一个十进制转换为二进制的方法是：把被转换的十进制数反复地除以 2，直到商为 0 为止，所得余数（从末位读起）就是这个数的二进制表示，简单地说，就是 &quot;除 2 取余法&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151652729.png" alt="image-20211125151652729"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151705033.png" alt="image-20211125151705033"></p><h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原码：是一种计算机中对数字的二进制定点表示法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为 0，负数该位为 1</span><br><span class="line"></span><br><span class="line">反码：一个数字用原码表示是容易理解的，但是需要单独一个位来表示符号位，并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是让符号位参与运算。要实现这个功能，我们就要用到反码。</span><br><span class="line">对于单个数值（二进制的 0 和 1）而言，对其进行取反操作就是将 0 变为 1，1 变为 0。正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。</span><br><span class="line"></span><br><span class="line">补码：补码是一种用二进制表示有符号数的方法。正数和 0 的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加 1。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式</span><br><span class="line">只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路和补码电路即可以完成各种有符号数加法和减法，在电路设计上相当方便。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">十进制</th><th align="center">原码</th><th align="center">反码</th><th align="center">补码</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">0000 0110</td><td align="center">0000 0110</td><td align="center">0000 0110</td></tr><tr><td align="center">-3</td><td align="center">1000 0011</td><td align="center">1111 1100</td><td align="center">1111 1101</td></tr></tbody></table><h4 id="符号“-”比较的是什么"><a href="#符号“-”比较的是什么" class="headerlink" title="符号“==”比较的是什么"></a>符号“==”比较的是什么</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final关键字是怎么用的"><a href="#final关键字是怎么用的" class="headerlink" title="final关键字是怎么用的"></a>final关键字是怎么用的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</span><br><span class="line"></span><br><span class="line">对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-03T09:38:14.000Z</published>
    <updated>2022-01-03T10:48:47.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></h4><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p><p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p><p><strong>说明:</strong></p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li><li>输入单词数组 <code>words</code> 至少包含一个单词。</li></ul><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br><span class="line">     因为最后一行应为左对齐，而不是左右两端对齐。       </span><br><span class="line">     第二行同样为左对齐，这是因为这行只包含一个单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth = 20</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解答：分三种情况一种是一个单词一行、普通情况、最后一行；每个写成一个 函数，返回String，主函数ArrayList.append();算出每行还剩多少空格在进行分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            count += words[i].length();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxWidth) &#123;</span><br><span class="line">                resultList.add(helper(words, start, i - <span class="number">1</span>, maxWidth));</span><br><span class="line">                start = i ;</span><br><span class="line">                count =  words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//单词结束后的空格</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后一截</span></span><br><span class="line">        resultList.add(helper(words,start,words.length-<span class="number">1</span>,maxWidth));</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">            <span class="comment">// 一行只有一个单词</span></span><br><span class="line">            oneWordOneRow(words,start,maxWidth,sb);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end == words.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//最后一行</span></span><br><span class="line">            lastRow(words,start,end,maxWidth,sb);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            normal(words,start,end,maxWidth,sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneWordOneRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb.append(words[start]);</span><br><span class="line">        <span class="keyword">int</span> num = maxWidth - words[start].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lastRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end; i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = maxWidth - sb.length();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">normal</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordsLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            wordsLength += words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> seperate =  (maxWidth -wordsLength) / (end - start);</span><br><span class="line">        <span class="keyword">int</span> remain = (maxWidth -wordsLength) % (end - start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=end;i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; seperate; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(remain-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>难度中等6301</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>思路：</strong></p><ul><li>不同的 圈起来，逐步右移，</li><li>出现相同的，最左边位置就变成相同的中下标最大的地方，这样可以避免重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (s.length()==0) return 0;</span></span><br><span class="line">        <span class="comment">// HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span></span><br><span class="line">        <span class="comment">// int max = 0;</span></span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; s.length(); i ++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(map.containsKey(s.charAt(i)))&#123;</span></span><br><span class="line">        <span class="comment">//         left = Math.max(left,map.get(s.charAt(i)) + 1);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     map.put(s.charAt(i),i);</span></span><br><span class="line">        <span class="comment">//     max = Math.max(max,i-left+1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return max;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            max = Math.max(max, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></h4><p>难度简单164</p><p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p><p><strong>美式键盘</strong> 中：</p><ul><li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li><li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li><li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/keyboard.png" alt="American keyboard"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;omk&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;adsdf&quot;,&quot;sfd&quot;]</span><br><span class="line">输出：[&quot;adsdf&quot;,&quot;sfd&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 20</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li></ul><p><strong>思路：</strong></p><ul><li>大小写的处理：全部存入String遍历</li><li>返回字符串数组 的构造： List<String> ans = new ArrayList&lt;&gt;(); 返回String需要对其进行重新构造ans.toArray(new String[ans.size()]);</li><li>字符串的s.contains()使用：最后+“”，使其变成字符串</li><li></li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span>, <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span>, <span class="string">&quot;zxcvbnmZXCVBNM&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, n3 = <span class="number">0</span>, leng = word.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leng; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ss[<span class="number">0</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n2++;</span><br><span class="line">                <span class="keyword">else</span> n3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n1 == leng || n2 == leng || n3 == leng) ans.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-03T09:38:08.000Z</published>
    <updated>2022-01-03T10:48:38.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 循环判断左右指针是否走到一起，判断中间值大于还是小于目标值，等于则返回否则，重新复制左右指针，继续循环。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></h4><p>难度简单184</p><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 <code>duration</code> 秒。</p><p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p><p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p><p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [1,4], duration = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。</span><br><span class="line">艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [1,2], duration = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。</span><br><span class="line">艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= timeSeries.length &lt;= 104</code></li><li><code>0 &lt;= timeSeries[i], duration &lt;= 107</code></li><li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li></ul><p><strong>思路：</strong>抛开惯性思维，不要本能 想着 从前往后 看，可以从后往前看，最后一个单独处理。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastTime = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timeSeries.length; i++) &#123;</span><br><span class="line">            ans += Math.min(timeSeries[i]-timeSeries[i-<span class="number">1</span>], duration);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += duration;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p>难度中等1653</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>思路：</strong>每次for没 执行完就继续dfs了，return回来之后，后面的就是没有执行的数放进去，接着遍历，然后不断重复回到根节点之时，就是遍历完成之时。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">                used[i]=<span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><p>难度中等870</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>思路：</strong>对数组进行排序，当前与前一个的根节点相同时，跳过这一次遍历</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i-1] == false保证前一个根节点，刚撤销选择</span></span><br><span class="line">            <span class="comment">// i&gt;0保证第二位开始</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">            used[i]=<span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-03T09:38:02.000Z</published>
    <updated>2022-01-03T10:48:31.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NC78-反转链表"><a href="#NC78-反转链表" class="headerlink" title="NC78 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&&tqId=38547&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC78 反转链表</a></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： n\leq1000<em>n</em>≤1000</p><p>要求：空间复杂度 O(1)<em>O</em>(1) ，时间复杂度 O(n)<em>O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/4A47A0DB6E60853DEDFCFDF08A5CA249.jpg" alt="img"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空链表则输出空         </span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>利用next往head列表下一步走</li><li>利用pre来保存拼接信息</li></ul><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211226122019794.png" alt="image-20211226122019794"></p><h1 id="NC4-判断链表中是否有环"><a href="#NC4-判断链表中是否有环" class="headerlink" title="NC4 判断链表中是否有环"></a>NC4 判断链表中是否有环</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p><p>数据范围：链表长度 0 \le n \le 100000≤<em>n</em>≤10000，链表中任意节点的值满足 |val| &lt;= 100000∣<em>v<strong>a</strong>l</em>∣&lt;=100000</p><p>要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>输入分为2部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p><p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/9A058E6590B998B9F7B637155842F993.jpg" alt="img"></p><p>可以看出环的入口结点为从头结点开始的第1个结点，所以输出true。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,0,-4&#125;,1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分&#123;3,2,0,-4&#125;代表一个链表，第二部分的1表示，-4到位置1，即-4-&gt;3存在一个链接，组成传入的head为一个带环的链表，返回true        </span><br></pre></td></tr></table></figure><h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#125;,-1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分&#123;1&#125;代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false        </span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;-1,-7,7,-4,19,6,-9,-5,-2,-5&#125;,6</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><ul><li>构建快慢指针</li><li>快的走两步，慢的走一步</li><li>判断每次只能判断当前与下一步的所指情况，否则容易出现越界的问题（null.next）</li></ul><h2 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>经典题</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E7%BB%8F%E5%85%B8%E9%A2%98/</id>
    <published>2022-01-03T09:37:53.000Z</published>
    <updated>2022-01-03T09:40:15.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合。"><a href="#数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合。" class="headerlink" title="数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。"></a>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</h3><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>题解：</strong>暴力递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        generateAll(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>*n], <span class="number">0</span>, combinations);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateAll</span><span class="params">(<span class="keyword">char</span>[] current, <span class="keyword">int</span> pos, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == current.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> String(current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current[pos]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">            current[pos]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            generateAll(current, pos+<span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[] current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : current ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                balance++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p> 解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算每个数出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title">countNums</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!counts.containsKey(num)) counts.put(num,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> counts.put(num, counts.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 打擂台选出最大数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; counts = countNums(nums);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(majorityEntry == <span class="keyword">null</span> || entry.getValue() &gt; majorityEntry.getValue()) majorityEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E7%9F%A9%E9%98%B5/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E7%9F%A9%E9%98%B5/</id>
    <published>2022-01-03T09:37:47.000Z</published>
    <updated>2022-01-03T10:48:24.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4><p>难度中等1064</p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1]]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2],[3,4]]</span><br><span class="line">输出：[[3,1],[4,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>matrix.length == n</code></li><li><code>matrix[i].length == n</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><p><strong>思路：</strong>先转置，后中心轴对称，<strong>巧</strong></p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,left=<span class="number">0</span>,right=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 转置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt; matrix.length; j++) &#123;</span><br><span class="line">                tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中间轴对称</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123;</span><br><span class="line">                tmp=matrix[i][left];</span><br><span class="line">                matrix[i][left]=matrix[i][right];</span><br><span class="line">                matrix[i][right]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2022-01-03T09:37:41.000Z</published>
    <updated>2022-01-03T10:48:18.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a></h4><p>给定平面上 <code>n</code> 对 <strong>互不相同</strong> 的点 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 。<strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p><p>返回平面上所有回旋镖的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[1,0],[2,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑数组顺序，可以用排列组合的方式,枚举一个个算距离，存储距离相同的点的个数放入哈希表中，最后取出哈希表中的数据，一个个排列组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] p:points) &#123;</span><br><span class="line">            Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] q : points) &#123;</span><br><span class="line">                <span class="keyword">int</span> dis = ((p[<span class="number">0</span>] - q[<span class="number">0</span>])) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]) + (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] -  q[<span class="number">1</span>]);</span><br><span class="line">                cnt.put(dis, cnt.getOrDefault(dis, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = entry.getValue();</span><br><span class="line">                ans += m * (m-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>难度中等490收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0]</span><br><span class="line">输出：[-1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li></ul><p><strong>思路：</strong>建一个hashmap 把它每个算出来是多少然后遍历出来。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;nums.length; i++ ) &#123;</span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;nums.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) == <span class="number">1</span>) ans[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></h4><p>难度中等164</p><p>你在和朋友一起玩 <a href="https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p><p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p><ul><li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），</li><li>有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li></ul><p>给你一个秘密数字 <code>secret</code> 和朋友猜测的数字 <code>guess</code> ，请你返回对朋友这次猜测的提示。</p><p>提示的格式为 <code>&quot;xAyB&quot;</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code> 表示奶牛。</p><p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line">输出: &quot;1A3B&quot;</span><br><span class="line">解释: 数字和位置都对（公牛）用 &#x27;|&#x27; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line">&quot;1807&quot;</span><br><span class="line">  |</span><br><span class="line">&quot;7810&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line">输出: &quot;1A1B&quot;</span><br><span class="line">解释: 数字和位置都对（公牛）用 &#x27;|&#x27; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line">&quot;1123&quot;        &quot;1123&quot;</span><br><span class="line">  |      or     |</span><br><span class="line">&quot;0111&quot;        &quot;0111&quot;</span><br><span class="line">注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：secret = &quot;1&quot;, guess = &quot;0&quot;</span><br><span class="line">输出：&quot;0A0B&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：secret = &quot;1&quot;, guess = &quot;1&quot;</span><br><span class="line">输出：&quot;1A0B&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li><li><code>secret.length == guess.length</code></li><li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li></ul><p><strong>思路：</strong></p><ul><li>数字位置都对的  +1</li><li>数字对位置不对的 哈希表存起来 +1</li><li>对比 哈希表中的数字，取小的</li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        Map &lt;Character, Integer&gt; secret_map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map &lt;Character, Integer&gt; guess_map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> bull=<span class="number">0</span>, cow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;secret.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(secret.charAt(i) == guess.charAt(i)) &#123;</span><br><span class="line">                bull++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                secret_map.put(secret.charAt(i), secret_map.getOrDefault(secret.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                guess_map.put(guess.charAt(i), guess_map.getOrDefault(guess.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> k : secret_map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess_map.containsKey(k)) cow = cow + Math.min(secret_map.get(k), guess_map.get(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bull+<span class="string">&quot;A&quot;</span>+cow+<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%B3%95/</id>
    <published>2022-01-03T09:37:35.000Z</published>
    <updated>2022-01-03T11:02:21.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></h4><p>难度简单165</p><p>猜数字游戏的规则如下：</p><ul><li>每轮游戏，我都会从 <strong>1</strong> 到 <em><strong>n</strong></em> 随机选择一个数字。 请你猜选出的是哪个数字。</li><li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li></ul><p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><ul><li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li><li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li><li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li></ul><p>返回我选出的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10, pick = 6</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, pick = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, pick = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, pick = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li><li><code>1 &lt;= pick &lt;= n</code></li></ul><p><strong>思路：</strong></p><ul><li><p>设置左右两个端点</p></li><li><p>每次循环区间内折半</p></li><li><p>左右相等时退出得到正确答案</p></li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>, right=n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right -left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid) &lt;=<span class="number">0</span>) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-01-03T09:37:23.000Z</published>
    <updated>2022-01-03T10:47:54.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="600-不含连续1的非负整数"><a href="#600-不含连续1的非负整数" class="headerlink" title="600. 不含连续1的非负整数"></a><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h4><p>难度困难138</p><p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 <strong>连续的1</strong> 的个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">下面是带有相应二进制表示的非负整数&lt;= 5：</span><br><span class="line">0 : 0</span><br><span class="line">1 : 1</span><br><span class="line">2 : 10</span><br><span class="line">3 : 11</span><br><span class="line">4 : 100</span><br><span class="line">5 : 101</span><br><span class="line">其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 1 &lt;= n &lt;= 109</p><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据构建斐波那也数列</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = getBinary(num);</span><br><span class="line">        <span class="comment">//一位位移动，不连续遇到1加上它</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res  += dp[numStr.length() - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numStr.charAt(i - <span class="number">1</span> ) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//整数 转 二进制数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBinary</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>,num &amp; <span class="number">1</span>);</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l: 左括号最少可能有多少个</span></span><br><span class="line">        <span class="comment">// r: 左括号最多可能有多少个</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 遇到&#x27;(&#x27;所有可能性加一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;)&#x27;所有可能性减一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;*&#x27;，最少的可能性可以变少，最多的可能性也同样可以变多，这取决于这个星号最终我们看成什么，但是可能性都在</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                l++; r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                l--; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l--; r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前左括号最少个数不能为负</span></span><br><span class="line">            l = Math.max(l, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这种情况其实发生在r本身是负数的时候，也就是我们常见的右括号太多了</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能取到0个左括号才是满足平衡的</span></span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-01-03T09:37:17.000Z</published>
    <updated>2022-01-03T10:47:50.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="600-不含连续1的非负整数"><a href="#600-不含连续1的非负整数" class="headerlink" title="600. 不含连续1的非负整数"></a><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h4><p>难度困难138</p><p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 <strong>连续的1</strong> 的个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">下面是带有相应二进制表示的非负整数&lt;= 5：</span><br><span class="line">0 : 0</span><br><span class="line">1 : 1</span><br><span class="line">2 : 10</span><br><span class="line">3 : 11</span><br><span class="line">4 : 100</span><br><span class="line">5 : 101</span><br><span class="line">其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 1 &lt;= n &lt;= 109</p><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据构建斐波那也数列</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = getBinary(num);</span><br><span class="line">        <span class="comment">//一位位移动，不连续遇到1加上它</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res  += dp[numStr.length() - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numStr.charAt(i - <span class="number">1</span> ) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//整数 转 二进制数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBinary</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>,num &amp; <span class="number">1</span>);</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// l: 左括号最少可能有多少个</span></span><br><span class="line">        <span class="comment">// r: 左括号最多可能有多少个</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 遇到&#x27;(&#x27;所有可能性加一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;)&#x27;所有可能性减一</span></span><br><span class="line">            <span class="comment">// 遇到&#x27;*&#x27;，最少的可能性可以变少，最多的可能性也同样可以变多，这取决于这个星号最终我们看成什么，但是可能性都在</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                l++; r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                l--; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l--; r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前左括号最少个数不能为负</span></span><br><span class="line">            l = Math.max(l, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 这种情况其实发生在r本身是负数的时候，也就是我们常见的右括号太多了</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能取到0个左括号才是满足平衡的</span></span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-01-03T09:16:22.000Z</published>
    <updated>2022-01-03T11:20:20.260Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTP，HTTPS"><a href="#HTTP，HTTPS" class="headerlink" title="HTTP，HTTPS"></a><a href="https://www.cnblogs.com/klb561/p/10289199.html">HTTP，HTTPS</a></h2><h3 id="1-HTTP，HTTPS-概念"><a href="#1-HTTP，HTTPS-概念" class="headerlink" title="1. HTTP，HTTPS 概念"></a>1. HTTP，HTTPS 概念</h3><p>  HTTP：<strong>HTTP</strong>协议以<strong>明文的方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，如：卡号、密码等支付信息。<br>  HTTPS：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。是以安全为目标的HTTP通道，简单讲是HTTP的安全版。<br>  HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="2-HTTP与HTTPS的区别"><a href="#2-HTTP与HTTPS的区别" class="headerlink" title="2. HTTP与HTTPS的区别"></a>2. HTTP与HTTPS的区别</h3><pre><code>   1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。      2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。      3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。      4. http的连接很简单，是无状态的；HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</code></pre><h3 id="3-HTTPS的工作原理"><a href="#3-HTTPS的工作原理" class="headerlink" title="3. HTTPS的工作原理"></a>3. HTTPS的工作原理</h3><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以<strong>很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议</strong></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/1-150H120343I41.jpg" alt="HTTP与HTTPS的区别-马海祥博客"></p><p>客户端在使用HTTPS方式与Web服务器<strong>通信时有以下几个步骤</strong>，如图所示。</p><pre><code>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。（5）Web服务器利用自己的私钥解密出会话密钥。（6）Web服务器利用会话密钥加密与客户端之间的通信。</code></pre><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/2012071410212142.gif" alt="img"></p><h3 id="4-HTTPS的优点"><a href="#4-HTTPS的优点" class="headerlink" title="4. HTTPS的优点"></a>4. HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，<strong>掌握根证书的机构、掌握加密算法的组织</strong>同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><pre><code>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</code></pre><h3 id="5-HTTPS的缺点"><a href="#5-HTTPS的缺点" class="headerlink" title="5. HTTPS的缺点"></a>5. HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><pre><code>（1）HTTPS协议**握手阶段比较费时**，会使页面的加载时间延长近50%，增加10%到20%的耗电；（2）HTTPS连接**缓存不如HTTP高效**，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；（3）**SSL证书需要钱**，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。（4）**SSL证书通常需要绑定IP**，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。（5）HTTPS协议的**加密范围也比较有限**，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</code></pre><h3 id="6-http切换到HTTPS"><a href="#6-http切换到HTTPS" class="headerlink" title="6. http切换到HTTPS"></a>6. http切换到HTTPS</h3><pre><code>如果需要将网站从http切换到https到底该如何实现呢？</code></pre><p>   这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https//www.baidu.com">http://www.baidu.com改为https://www.baidu.com</a></p><pre><code>BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</code></pre><h2 id="cookie和session的区别详解"><a href="#cookie和session的区别详解" class="headerlink" title="cookie和session的区别详解"></a><a href="https://www.cnblogs.com/klb561/p/10289199.html">cookie和session的区别详解</a></h2><h3 id="cookie和session的定义："><a href="#cookie和session的定义：" class="headerlink" title="cookie和session的定义："></a>cookie和session的定义：</h3><p>当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，<strong>Cookie 会把你在网站上所打的文字或是一些选择，都纪录下来</strong>。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。</p><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p><p>同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。</p><p>cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。<strong>这种生命期为浏览器会话期的cookie被称为会话cookie</strong>。 </p><p>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p><p><strong>session机制</strong>。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来。使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但<strong>cookie可以被人为的禁止</strong>，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做<strong>URL重写</strong>，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;testform&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/xxx&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jsessionid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>实际上这种技术可以简单的用对action应用URL重写来代替。</p><h3 id="cookie和session的区别："><a href="#cookie和session的区别：" class="headerlink" title="cookie和session的区别："></a>cookie和session的区别：</h3><p>1、cookie数据存放在<strong>客户的浏览器上</strong>，session数据放在<strong>服务器上</strong>。</p><p>2、<strong>cookie不是很安全</strong>，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>      <strong>考虑到安全应当使用session</strong>。</p><p>3、<strong>session</strong>会在一定时间内保存在服务器上。当访问增多，<strong>会比较占用你服务器的性能</strong><br>     考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：<br>      将登陆信息等重要信息存放为SESSION<br>      其他信息如果需要保留，可以放在COOKIE中</p><h2 id="TCP，UDP"><a href="#TCP，UDP" class="headerlink" title="TCP，UDP"></a><a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html">TCP，UDP</a></h2><h3 id="1-TCP-IP网络模型"><a href="#1-TCP-IP网络模型" class="headerlink" title="1. TCP/IP网络模型"></a>1. TCP/IP网络模型</h3><p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ul><table border="1">    <tr>        <th align="center">OSI七层模型</th>   <!-- 左对齐 -->        <th align="center"> TCP/IP概念层模型</th> <!-- 居中对其（默认）-->        <th align="center">功能</th>  <!-- 右对齐-->        <th align="center">TCP/IP协议族</th>  <!-- 右对齐-->    </tr>    <tr>        <td>应用层</td>        <td rowspan="3">应用层</td>        <td>文件传输，电子邮件，文件服务，虚拟终端</td>        <td>TFTP，HTTP，SNMP，DNS，Telnet</td>    </tr>    <tr>        <td>表示层</td>        <td>数据格式化，代码转换，数据加密</td>        <td>没有协议</td>    </tr>    <tr>        <td>会话层</td>        <td>解除或建立与别的接口的联系</td>        <td>没有协议</td>    </tr>    <tr>        <td>传输层</td>        <td>传输层</td>        <td>提供端到端的接口</td>        <td>TCP，UDP</td>    </tr>    <tr>        <td>网络层</td>        <td>网络层</td>        <td>为数据包选择路由</td>        <td>IP，ICMP，RIP，OSPF，BGF，IGMP</td>    </tr>    <tr>        <td>数据链路层</td>        <td rowspan="2">链路层</td>        <td>传输有地址的帧以及错误检测功能</td>        <td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>    </tr>    <tr>        <td>物理层</td>        <td>以二进制数据形式在物理层媒体上传输数据</td>        <td>ISO2110.IEEE802，IEEE802.2</td>    </tr></table><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，<strong>数据在发送端时经过各层时都要附加上相应层的协议头和协议尾</strong>（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h3><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样<strong>用于处理数据包</strong>，是一种<strong>无连接的协议</strong>。在OSI模型中，在第四层——<strong>传输层，处于IP协议的上一层</strong>。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><h4 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h4><h5 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h5><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><h5 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h5><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <strong>UDP 提供了单播，多播，广播的功能</strong>。</p><h5 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h5><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h5 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h5><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/2019-03-21-02.gif" alt="img"></p><p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><h5 id="5-头部开销小，传输数据报文时是很高效的。"><a href="#5-头部开销小，传输数据报文时是很高效的。" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的。"></a>5. 头部开销小，传输数据报文时是很高效的。</h5><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/2019-03-21-03.png" alt="img"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="3-TCP与UDP的比较"><a href="#3-TCP与UDP的比较" class="headerlink" title="3. TCP与UDP的比较"></a>3. TCP与UDP的比较</h3><table><thead><tr><th align="left"></th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td align="left">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td align="left">只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td align="left">面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td align="left">首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td align="left">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><ul><li><strong>TCP</strong>向上层提供面向<strong>连接的可靠服务</strong> ，<strong>UDP</strong>向上层提供<strong>无连接不可靠服务</strong>。</li><li>虽然 <strong>UDP</strong> 并没有 TCP 传输来的准确，但是也能在很多<strong>实时性要求高</strong>的地方有所作为</li><li>对数据<strong>准确性要求高</strong>，速度可以相对较慢的，可以选用<strong>TCP</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>差分与复原</title>
    <link href="https://sssuper-bear.github.io/2021/12/26/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%A4%8D%E5%8E%9F/"/>
    <id>https://sssuper-bear.github.io/2021/12/26/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%A4%8D%E5%8E%9F/</id>
    <published>2021-12-26T13:45:41.000Z</published>
    <updated>2022-01-03T11:11:30.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间序列的差分与复原"><a href="#时间序列的差分与复原" class="headerlink" title="时间序列的差分与复原"></a>时间序列的差分与复原</h1><p><strong>在时序分析时，我们经常需要将原始序列进行差分，然后做出拟合或者预测，最后还需要将拟合的或者预测的值恢复成原始序列。这里，使用Pandas的Series中的diff和cumsum函数可以方便的实现。</strong></p><h2 id="一阶差分与复原"><a href="#一阶差分与复原" class="headerlink" title="一阶差分与复原"></a>一阶差分与复原</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">time_series = pd.Series([2, 4, 3, 5, 6, 7, 4, 5, 6, 3, 2, 4])</span><br><span class="line">time_series_diff = time_series.diff(1).dropna()</span><br><span class="line">time_series_restored = pd.Series([time_series[0]], index=[time_series.index[0]]).append(time_series_diff).cumsum()</span><br><span class="line">print(time_series)</span><br><span class="line">print(time_series_diff)</span><br><span class="line">print(time_series_restored)</span><br><span class="line">plt.plot(time_series, color=&#x27;red&#x27;, label=&#x27;time_series&#x27;)</span><br><span class="line">plt.plot(time_series_diff, color=&#x27;green&#x27;, label=&#x27;time_series_diff&#x27;)</span><br><span class="line">plt.plot(time_series_restored, color=&#x27;blue&#x27;,linestyle=&#x27;--&#x27;, label=&#x27;time_series_restored&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="多阶差分复原"><a href="#多阶差分复原" class="headerlink" title="多阶差分复原"></a>多阶差分复原</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">time_series = pd.Series([2,4,3,5,6,7,4,5,6,3,2,4], index=pd.date_range(start=&#x27;2000&#x27;, periods=12, freq=&#x27;a&#x27;))</span><br><span class="line">time_series_diff = time_series</span><br><span class="line">diff_times = 3</span><br><span class="line">first_values = []</span><br><span class="line">for i in range(diff_times):</span><br><span class="line">    first_values.append(pd.Series([time_series_diff[0]],index=[time_series_diff.index[0]]))</span><br><span class="line">    time_series_diff = time_series_diff.diff(1).dropna()</span><br><span class="line"></span><br><span class="line">time_series_restored = time_series_diff</span><br><span class="line">for first in reversed(first_values):</span><br><span class="line">    time_series_restored = first.append(time_series_restored).cumsum()</span><br><span class="line">print(time_series)</span><br><span class="line">print(time_series_diff)</span><br><span class="line">print(time_series_restored)</span><br><span class="line">plt.plot(time_series, color=&#x27;red&#x27;, label=&#x27;time_series&#x27;)</span><br><span class="line">plt.plot(time_series_diff, color=&#x27;green&#x27;, label=&#x27;time_series_diff&#x27;)</span><br><span class="line">plt.plot(time_series_restored, color=&#x27;blue&#x27;,linestyle=&#x27;--&#x27;, label=&#x27;time_series_restored&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.jianshu.com/p/88d663ecdf25">Pandas 连续差分diff后恢复原始的序列</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="study" scheme="https://sssuper-bear.github.io/categories/study/"/>
    
    
    <category term="信号处理" scheme="https://sssuper-bear.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>添加git快捷方式</title>
    <link href="https://sssuper-bear.github.io/2021/12/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0git%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://sssuper-bear.github.io/2021/12/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%B7%BB%E5%8A%A0git%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2021-12-26T12:57:30.000Z</published>
    <updated>2022-01-03T11:07:03.477Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git-右键添加Git-Bash"><a href="#Git-右键添加Git-Bash" class="headerlink" title="Git 右键添加Git Bash"></a>Git 右键添加Git Bash</h2><ol><li><strong>win + r</strong></li><li><strong>输入regedit</strong></li><li><strong>进入 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</strong></li><li><strong>新建如下的项 git bash 和 command</strong></li></ol><p><img src="https://pic.imgdb.cn/item/61c867322ab3f51d91d28270.jpg" alt="img"></p><ol start="5"><li><strong>在git bash 中添加字符串值 Icon ，数值位于git 安装目录下\Git\mingw64\share\git\git-for-windows.ico</strong><img src="https://pic.imgdb.cn/item/61c8674a2ab3f51d91d289b4.jpg" alt="img"></li><li><strong>在command 中添加运行的命令，修改默认的数值 \Git\git-bash.exe</strong><img src="https://pic.imgdb.cn/item/61c867662ab3f51d91d2ac8f.jpg" alt="img"></li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.cnblogs.com/mythdoraemon/p/9865567.html">Git 右键添加Git Bash</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://sssuper-bear.github.io/tags/git/"/>
    
  </entry>
  
</feed>
