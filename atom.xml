<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuperBear&#39;s blog</title>
  
  
  <link href="https://sssuper-bear.github.io/atom.xml" rel="self"/>
  
  <link href="https://sssuper-bear.github.io/"/>
  <updated>2022-01-08T02:54:50.708Z</updated>
  <id>https://sssuper-bear.github.io/</id>
  
  <author>
    <name>SuperBear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>递归</title>
    <link href="https://sssuper-bear.github.io/2022/01/08/%E5%88%B7%E9%A2%98/%E9%80%92%E5%BD%92/"/>
    <id>https://sssuper-bear.github.io/2022/01/08/%E5%88%B7%E9%A2%98/%E9%80%92%E5%BD%92/</id>
    <published>2022-01-08T02:37:23.000Z</published>
    <updated>2022-01-08T02:54:50.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NC68-跳台阶"><a href="#NC68-跳台阶" class="headerlink" title="NC68 跳台阶"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&&tqId=38622&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC68 跳台阶</a></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>数据范围：0≤<em>n</em>≤40</p><p>要求：时间复杂度：$O(n)$ ，空间复杂度： $O(1)$</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2     </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>你可以想如果青蛙当前在第n级台阶上，那它上一步是在哪里呢？</li><li>显然，由于它可以跳1级台阶或者2级台阶，所以<strong>它上一步必定在第n-1,或者第n-2级台阶</strong>，也就是说<strong>它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和</strong>。</li><li>设跳上 $i$级台阶有 $f(n)$ 种跳法，则它跳上n级的台阶有$f(n)=f(n-1)+f(n-2)$种跳法。</li></ul><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            c = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="https://sssuper-bear.github.io/2022/01/07/%E5%88%B7%E9%A2%98/%E5%A0%86%E6%A0%88/"/>
    <id>https://sssuper-bear.github.io/2022/01/07/%E5%88%B7%E9%A2%98/%E5%A0%86%E6%A0%88/</id>
    <published>2022-01-07T02:37:23.000Z</published>
    <updated>2022-01-08T02:16:47.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NC76-用两个栈实现队列"><a href="#NC76-用两个栈实现队列" class="headerlink" title="NC76 用两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&&tqId=38552&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC76 用两个栈实现队列</a></h1><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p><p>数据范围： n\le1000<em>n</em>≤1000</p><p>要求：存储n个元素的空间复杂度为 O(n)<em>O</em>(<em>n</em>) ，插入与删除的时间复杂度都是 O(1)<em>O</em>(1)</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;PSH1&quot;:代表将1插入队列尾部</span><br><span class="line">&quot;PSH2&quot;:代表将2插入队列尾部</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回1</span><br><span class="line">&quot;POP“:代表删除一个元素，先进先出=&gt;返回2   </span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;PSH2&quot;,&quot;POP&quot;,&quot;PSH1&quot;,&quot;POP&quot;]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,1</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>push操作就直接往stack1中push</li><li>pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据<strong>全部</strong>转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</li></ul><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty() &amp;&amp; stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://sssuper-bear.github.io/2022/01/04/%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/"/>
    <id>https://sssuper-bear.github.io/2022/01/04/%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/</id>
    <published>2022-01-04T02:37:53.000Z</published>
    <updated>2022-01-07T02:13:23.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="NC140-排序"><a href="#NC140-排序" class="headerlink" title="NC140 排序"></a><strong>NC140</strong> <strong>排序</strong></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个长度为 n 的数组，请你编写一个函数，返回该数组按升序排序后的结果。</p><p>数据范围： 0 \le n \le 10^50≤<em>n</em>≤105，数组中每个元素都满足 0 \le val \le 10^90≤<em>v<strong>a</strong>l</em>≤109</p><p>要求：时间复杂度 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)，空间复杂度 O(n)<em>O</em>(<em>n</em>)</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,2,3,1,4]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>复制</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,1,6,2,5]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,5,5,6]</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>**快速排序(Quick Sort)**：是对冒泡排序的一种改进方法，在冒泡排序中，进行元素的比较和交换是在相邻元素之间进行的，元素每次交换只能移动一个位置，所以比较次数和移动次数较多，效率相对较低。而在快速排序中，元素的比较和交换是从两端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，y速度较快，故称为“快速排序”。<br><strong>快速排序的基本思想是：</strong></p><ol><li>在待排序的元素任取一个元素作为基准(通常选第一个元素，但最的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；</li><li>将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；</li><li>对左右两个分区重复以上步骤直到所有元素都是有序的</li></ol><h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 将给定数组排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] MySort (<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        quickSort(arr , <span class="number">0</span> , arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 分割数组，找到分割点</span></span><br><span class="line">            <span class="keyword">int</span> point = partition(list, left, right);</span><br><span class="line">            <span class="comment">// 递归调用，对左子数组进行快速排序</span></span><br><span class="line">            quickSort(list, left, point - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归调用，对右子数组进行快速排序</span></span><br><span class="line">            quickSort(list, point + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分割数组，找到分割点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用数组的第一个元素作为基准数</span></span><br><span class="line">        <span class="keyword">int</span> first = list[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; list[right] &gt;= first) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            swap(list, left, right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; list[left] &lt;= first) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            swap(list, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回分割点所在的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频解释快排"><a href="#视频解释快排" class="headerlink" title="视频解释快排"></a>视频解释快排</h3><div style="position: relative; padding: 30% 45%;">    <iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"         src="//player.bilibili.com/player.html?aid=62621532&bvid=BV1at411T75o&cid=108813206&page=1"         scrolling="no"         border="0"         frameborder="no" framespacing="0" allowfullscreen="true">    </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2022-01-03T12:50:20.000Z</published>
    <updated>2022-01-07T02:00:25.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a><a href="https://www.cnblogs.com/lonely-wolf/p/15674526.html">时间复杂度与空间复杂度</a></h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="O-1-常数阶"><a href="#O-1-常数阶" class="headerlink" title="O(1) 常数阶"></a>O(1) 常数阶</h3><p>0(1) 复杂度算法也称之为常数阶算法。这里的 <code>1</code> 是用来代指常量，也就是说这个算法的效率是固定的，无论你的数据量如何变化，效率都一样，这种复杂度也是最优的一种算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中不论有多少行代码，时间复杂度都是属于常数阶。换言之：只要代码不存在<strong>循环</strong>，<strong>递归</strong>等循环类调用，不论代码有多少行，其复杂度都是常数阶</p><h3 id="O-n-线性阶"><a href="#O-n-线性阶" class="headerlink" title="O(n) 线性阶"></a>O(n) 线性阶</h3><p><code>O(n)</code> 复杂度算法也称之为线性阶。比如下面这个示例我们应该怎么分析复杂度呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面常量阶没分析是因为常量阶比较容易理解，接下来我们就以线性阶这个为例子来分析下具体是怎么得到的。</p><p>我们假设每一行代码的执行时间是 <code>T</code>，那么上面这段代码的执行复杂度是多少呢？</p><p>答案很明显，那就是 <code>T+n*T</code>，也就是 <code>(n+1)T</code>，而在算法中有一个原则，那就是常量可以被忽略，所以就得到了 <code>nT</code>，换成大 <code>O</code> 表示法就是 <code>O(n)</code>。</p><p>这只是一个简略的计算过程，大家也不用较真说每行代码执行时间可能不一样之类的，也不要较真说 <code>for</code> 循环占用了一行，下面的大括号也占用了一行，如果要较真这个，那我建议可以去想一下 <code>1=1</code> 为什么等于 <code>2</code>。</p><p>算法中的复杂度反应的只是一个趋势，这里 <code>O(n)</code> 反应的就是一个趋势，也就是随着 <code>n</code> 的变化，算法的执行时间是会降低的。</p><h3 id="O-n²-平方阶"><a href="#O-n²-平方阶" class="headerlink" title="O(n²) 平方阶"></a>O(n²) 平方阶</h3><p>知道了上面的线性阶，那么平方阶就很好理解了，双层循环就是平方阶，同理，三次循环就是立方阶，<code>k</code> 次循环就是 <code>k</code> 次方阶。</p><h3 id="O-logn-对数阶"><a href="#O-logn-对数阶" class="headerlink" title="O(logn) 对数阶"></a>O(logn) 对数阶</h3><p><code>O(logn)</code> 也称之为对数阶，对数阶也很常见，像二分查找，二叉树之类的问题中会见到比较多的对数阶复杂度，但是对数阶也是比较难理解的一种算法复杂度。</p><p>下面我们还是来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码又该如何分析复杂度呢？这段代码最关键就是要分析出 <code>while</code> 循环中到底循环了多少次，我们观察这个循环，发现 <code>i</code> 并不是逐一递增，而是不断的翻倍：<code>1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;32-&gt;64</code> 一直到等于 <code>n</code> 为止才会结束，所以我们得到了这样的一个公式：<code>2^x=n</code>。</p><p>也就是我们只要计算出 <code>x</code> 的值，就得到了循环次数，而根据高中的数学知识我们可以得到 <strong>x=log<sub>2</sub>n</strong>，所以根据上面线性阶的分析方法，我们省略常量，就得到了示例中的算法复杂度为 <code>O(log2n)</code>。</p><p>同样的分析方式，下面的例子，我们可以很快的分析出复杂度就为 <code>O(log3n)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面得到的 <code>log3n</code> 我们可以再做进一步的转换：<code>log3n=log32 * log2n</code>，而 <code>log32</code>（注意这几个地方的 <code>3</code> 是底数，在下面） 是一个常量，常量可以省略，所以也就得到了：<code>O(log3n)=O(log2n)</code>。同样的道理，不论底数是多少，其实最终都可以转化成和 <code>O(log2n)</code> 相等，正因为如此，为了方便，我们算法中通常就会省略底数，直接写作 <code>O(logn)</code>。</p><p>上面的数学公式大家如果忘了或者看不懂也没关系，只要记住不论对数的底数是多少，我们都算作 <code>O(logn)</code>，而对于一个算法的复杂度是否是对数阶，还有一个简易的判断方法：<strong>当循环中下标以指定倍数形式衰减，那么这就是一个对数阶</strong>。</p><h3 id="O-nlogn-线性对数阶"><a href="#O-nlogn-线性对数阶" class="headerlink" title="O(nlogn) 线性对数阶"></a>O(nlogn) 线性对数阶</h3><p>如果理解了上面的对数阶，那么这种线性对数阶就非常好理解了，只需要在对数阶的算法中再嵌一层循环就是线性对数阶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析了前面这些最常用的时间复杂度，其实我们可以得到以下规律：</p><ul><li>只要是常量级别，不论多大，效率都是一样的（如：常量阶复杂度例子）。</li><li>分析一段代码的时间复杂度，只需要分析执行次数最多的一段代码（如：所以例子中我们只分析了循环体中代码执行次数）。</li><li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积（如：分析线性对数阶复杂度例子）。</li></ul><h3 id="其他复杂度"><a href="#其他复杂度" class="headerlink" title="其他复杂度"></a>其他复杂度</h3><p>除了上面常用的复杂度之外，另外还有指数阶，阶层阶，根号阶等，这些接触的相对会较少，我们就不特意做分析了，如果大家感兴趣的话，可以自己去了解下。</p><h3 id="组合式复杂度分析"><a href="#组合式复杂度分析" class="headerlink" title="组合式复杂度分析"></a>组合式复杂度分析</h3><p>前面我们分析的都是只有一段代码比较复杂的情况下得到的复杂度结果，那么假如我一个算法中，有多段代码都比较复杂呢？这时候复杂度该如何分析？</p><h4 id="取最大复杂度作为整个算法复杂度"><a href="#取最大复杂度作为整个算法复杂度" class="headerlink" title="取最大复杂度作为整个算法复杂度"></a>取最大复杂度作为整个算法复杂度</h4><p>我们先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;n;p++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;n;q++)&#123;</span><br><span class="line">            System.out.println(p+q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中有三个循环，首先第一个，是一个常量，那么根据前面的结论，不论这个常量是多大，都属于常量级，所以第一个循环中的复杂度为 <code>O(1)</code>，第二个和第三个循环我们前面也分析过，复杂度分别为 <code>O(n)</code> 和 <code>O(n²)</code>。</p><p>也就是这一段代码中有三段代码产生了三种不同复杂度，而且这三个复杂度可以很明显得到的大小关系为：<code>O(1)&lt;O(n)&lt;O(n²)</code>，像这种在同一个算法中有明确大小关系的，我们就可以直接取最大值作为这个算法的复杂度，所以这个例子中算法的复杂度就是 <code>O(n²)</code>。</p><h4 id="取多个复杂度之和作为整个算法复杂度"><a href="#取多个复杂度之和作为整个算法复杂度" class="headerlink" title="取多个复杂度之和作为整个算法复杂度"></a>取多个复杂度之和作为整个算法复杂度</h4><p>接下来我们再来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子我们同样对三段循环分别分析可以分别得到如下复杂度：<code>O(1)</code>，<code>O(m)</code>，<code>O(n)</code>。这时候我们只能知道 <code>O(1)</code> 最小可以忽略，但是后面两个无法却无法确定大小，所以这时候我们需要取两段循环复杂度之和来作为算法的复杂度，所以可以得到这个例子的算法复杂度为：<code>O(m+n)</code>。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度全称就是渐进空间复杂度，用来表示算法的存储空间与数据规模之间的增长关系。和时间复杂度一样，空间复杂度也是用大 <code>O</code> 进行表示。</p><p>其实学会了分析时间复杂度，那么空间复杂度的分析就简单了，主要就看我们在一个算法当中到底有没有使用到了额外的空间来进行存储数据，然后判断这个额外空间的大小会不会随着 <code>n</code> 的变化而变化，从而得到空间复杂度。</p><p>我们来看一个给数组赋值例子，假设这就是一个算法，我们可以来分析下这个算法的空间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        arr[i]=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始定义了一个变量，这里需要空间，但是这是一个常量级的（不随 <code>n</code> 的变化而变化），然后再定义了一个数组，数组的长度为 <code>n</code>，这里数组也需要占用空间，而且数组的空间是随着 <code>n</code> 的变化而变化的，其余代码没有占用额外空间，所以我们就可以认为上面示例中的空间复杂度为 <code>O(n)</code>。</p><p>对于算法的空间复杂度也可以简单的进行总结一下：</p><ul><li>如果申请的是有限个数（常量）的变量，空间复杂度为 <code>O(1)</code>。</li><li>如果申请的是一维数组，队列或者链表等，那么空间复杂度为 <code>O(n)</code>。</li><li>如果申请的是二维数组，那么空间复杂度为 <code>O(n²)</code>。</li><li>如果是在循环体中申请的数组等，可能就需要取嵌套的乘积来作为空间复杂度，这种就需要具体的进一步分析</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>手机拍照技巧</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E6%8A%80%E5%B7%A7/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E6%8A%80%E5%B7%A7/</id>
    <published>2022-01-03T12:36:34.000Z</published>
    <updated>2022-01-07T02:07:07.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="自拍"><a href="#自拍" class="headerlink" title="自拍"></a>自拍</h4><ul><li>灯光在头顶，正午拍照，光源在头顶，脸上会有非常明显的三角形投影，不适合自拍。<ul><li>脸部朝向灯光的方向，避免顶光在脸部形成强烈的投影</li><li>带个帽子</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208205624811.png" alt="image-20201208205624811"></p><ul><li><p>室内怎么让自拍照更美？靠近窗户的时候，逆光，脸部光线不好。</p></li><li><p>换个方向，面向光源，逆光自拍会看到脸部的瑕疵（颗粒，皱纹等等），顺光自拍可以减少脸部的瑕疵。</p></li><li><p>自拍角度决定你的胖瘦。</p><ul><li><p>低于30°的仰拍角，容易拍出圆乎乎的大脸</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210135055.png" alt="image-20201208210135055"></p></li><li><p>手机保持30-45°的仰拍角度，更容易拍出巴掌脸与尖下巴</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210352336.png" alt="image-20201208210352336"></p></li><li><p>脸大脸圆？学会遮挡术</p><ul><li><p>利用树叶花朵等作为前景，虚化并遮住部分脸，即显得脸小又增加画面趣味。(借助道具，手、围巾、帽子、花花草草。)</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210639392.png" alt="image-20201208210639392"></p></li><li><p>还可以用双手或者单手托脸既可以遮住部分脸又显得可爱</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210742655.png" alt="image-20201208210742655"></p></li><li><p>借助道具，比如饮料杯遮住部分脸</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208210830160.png" alt="image-20201208210830160"></p></li></ul></li><li><p>怎么让自拍照看起来不像自拍照</p><ul><li>借助手机自拍杆+定时遥控器</li><li>放在桌子或者窗台+定时自拍</li></ul></li><li><p>全身照瞬间拥有大长腿</p><ul><li>错误角度：俯拍容易拍的比本人显矮</li><li>蹲下来采用仰拍角度<ul><li>脚与地面的留白一定要少留地面</li></ul></li></ul></li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211431040.png" alt="image-20201208211431040"></p><h4 id="拍照的构图"><a href="#拍照的构图" class="headerlink" title="拍照的构图"></a>拍照的构图</h4><ul><li><p><strong>黄金分割</strong>，拍摄人像不知道把任务放置于画面哪个位置的时候，置于黄金分割点是最稳妥的构图方法。</p><ul><li><p>设置九宫格四个交叉点的位置就是黄金分割点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211908865.png" alt="image-20201208211908865"></p></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208211942688.png" alt="image-20201208211942688"></p></li><li><p><strong>点构图</strong>：点构图是拍摄环境人像时，最喜欢使用的一种构图方法，这样的构图，<strong>人物在画面里的比例很小</strong>，强调环境与人物和谐统一的关系。</p><ul><li>点构图的适用场景通常为视野开阔画面干净纯粹没有过多杂物的环境</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212412080.png" alt="image-20201208212412080"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212426560.png" alt="image-20201208212426560"></p><ul><li><p><strong>对角线构图</strong>：拍摄静物或者风光照片时，对角线构图特别适用</p><ul><li><p>对角线构图适合用于拍摄静物、花草植物或大面积的草坪、画面中有道路的自然风景</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212932256.png" alt="image-20201208212932256"></p></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212723202.png" alt="image-20201208212723202"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208212746080.png" alt="image-20201208212746080"></p></li></ul><ul><li><p><strong>中心对称构图</strong> </p><ul><li><p>有倒影的时候，为了追求画面平衡对称，把人物放置于画面正中间，倒影与人物聚焦中心对称点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213049793.png" alt="image-20201208213049793"></p></li><li><p>横构图中如果有弧形的线条横穿画面拍摄主体为一颗树时，可以将树放置于画面正中心</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213322513.png" alt="image-20201208213322513"></p></li><li><p>用竖构图拍摄人物特写，为了画面饱满，突出人物神态，也适用中心对称构图。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213428017.png" alt="image-20201208213428017"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213437744.png" alt="image-20201208213437744"></p></li></ul></li><li><p><strong>三角形构图</strong>，利用三角形构图，达到画面的平衡、稳定、饱满同时又不失灵活与动感</p><ul><li><p>拍摄静物或者人像时都可以尝试三角形构图</p><p><img src="images/image-20201208213524368.png?lastModify=1607434632" alt="image-20201208213524368"></p></li><li><p>拍摄前摆设物品时，有意识的选择三角形构图，把几个物品分别放在三个角，这样构图比较饱满不会显得呆板。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213739834.png" alt="image-20201208213739834"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213755697.png" alt="image-20201208213755697"></p></li><li><p>拍摄人像如何使用三角形构图</p><ul><li><p>利用模特的手或腿摆出不同的pose，让人物呈现三角形的构图画面</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208213944752.png" alt="image-20201208213944752"></p></li><li><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214024680.png" alt="image-20201208214024680"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214041217.png" alt="image-20201208214041217"></p></li></ul></li></ul></li><li><p><strong>引导线构图</strong>，利用画面中的线条，引导观者的目光，让视线可以汇聚到画面的焦点</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214225858.png" alt="image-20201208214225858"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214244817.png" alt="image-20201208214244817"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214254865.png" alt="image-20201208214254865"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214707089.png" alt="image-20201208214707089"></p></li><li><p><strong>重复线条构图</strong>：利用画面中规律排列的物体进行构图，让照片充满工整与秩序感</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214916083.png" alt="image-20201208214916083"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214926913.png" alt="image-20201208214926913"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214937969.png" alt="image-20201208214937969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214946433.png" alt="image-20201208214946433"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208214955154.png" alt="image-20201208214955154"></p></li><li><p><strong>开放式构图</strong>：主体不一定放在画中心，有意在画面周围留下被切割的不完整形象，引导观众产生画外空间联想</p><ul><li><p>什么是封闭式构图：讲究画面完整，主体在画面之中，构图较工整，框架内部布局均衡、严禁、完整</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215546274.png" alt="image-20201208215546274"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215809810.png" alt="image-20201208215809810"></p></li><li><p>什么是开放式构图：主体不一定放在画中心，注重主体与画外的联系有意在画面周围留下切割的不完整形象，引导观众突破画框限制，产生画外空间联系</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215557329.png" alt="image-20201208215557329"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215825762.png" alt="image-20201208215825762"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215840816.png" alt="image-20201208215840816"></p></li><li><p>开放式构图拍摄静物或美食：拍摄画面里，桌面露出一小部分边角，这样的开放构图也会让人产生能长久注视画面思考遐想的效果</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208215955632.png" alt="image-20201208215955632"></p></li></ul></li><li><p><strong>前景虚化构图</strong>：利用花草树木等物品作为前景，用大光圈拍摄虚化前景，制造梦幻、神秘的画面</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220521634.png" alt="image-20201208220521634"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220549714.png" alt="image-20201208220549714"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220601698.png" alt="image-20201208220601698"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220615777.png" alt="image-20201208220615777"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201208220625584.png" alt="image-20201208220625584"></p></li></ul><h4 id="小道具"><a href="#小道具" class="headerlink" title="小道具"></a>小道具</h4><ul><li><p>拍照的时候不知道手往哪里放，眼睛该往哪儿看</p></li><li><p>道具一：书、报纸、杂志</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113723831.png" alt="image-20201210113723831"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113740913.png" alt="image-20201210113740913"></p></li><li><p>道具二：食物（假装吃，假装喝）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210113840257.png" alt="image-20201210113840257"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114107202.png" alt="image-20201210114107202"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114038513.png" alt="image-20201210114038513"></p></li><li><p>道具三：围巾、披肩、帽子</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114229969.png" alt="image-20201210114229969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114249425.png" alt="image-20201210114249425"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114304577.png" alt="image-20201210114304577"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114315969.png" alt="image-20201210114315969"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114348323.png" alt="image-20201210114348323"></p></li><li><p>相机</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114427329.png" alt="image-20201210114427329"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114455826.png" alt="image-20201210114455826"></p></li><li><p>镜子</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114556977.png" alt="image-20201210114556977"></p></li><li><p>花草树叶等植物</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114640865.png" alt="image-20201210114640865"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114711890.png" alt="image-20201210114711890"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114746689.png" alt="image-20201210114746689"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114928673.png" alt="image-20201210114928673"></p></li><li><p>自行车</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210114958755.png" alt="image-20201210114958755"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115016593.png" alt="image-20201210115016593"></p></li><li><p>雨、雪、风、阳光</p><ul><li>雨，躲在屋檐下把手放在头顶装作要遮雨一样</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115258513.png" alt="image-20201210115258513"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115315522.png" alt="image-20201210115315522"></p><ul><li>雪</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115421905.png" alt="image-20201210115421905"></p><ul><li>雪+逆光<ul><li>最好是很细颗粒的雪花，逆光拍摄，把雪花朝着镜头洒过来</li><li>模特洒雪花的同时要保持微笑，表情不能太奔放与放松</li><li>伞，伞柄不能把脸遮住</li></ul></li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115832982.png" alt="image-20201210115832982"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115851699.png" alt="image-20201210115851699"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210115924946.png" alt="image-20201210115924946"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120224994.png" alt="image-20201210120224994"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120244786.png" alt="image-20201210120244786"></p></li><li><p>风</p><ul><li>当有风的时候，利用风将头发和衣服吹起来</li><li>最好是顺风，迎着风摆pose，眼神表情一定要到位</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120424421.png" alt="image-20201210120424421"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120529268.png" alt="image-20201210120529268"></p></li><li><p>阳光</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120614675.png" alt="image-20201210120614675"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120829954.png" alt="image-20201210120829954"></p></li><li><p>逆光拍摄</p><ul><li>日出、日落是逆光拍摄的最佳时间段</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210120959832.png" alt="image-20201210120959832"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121240403.png" alt="image-20201210121240403"></p><ul><li>当屋外太阳比较高时可以选择路面有积雪的或者四周有白色墙面的环境进行拍摄逆光</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121734771.png" alt="image-20201210121734771"></p><ul><li>或者躲进屋内拍摄逆光</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121820695.png" alt="image-20201210121820695"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121830145.png" alt="image-20201210121830145"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201210121839586.png" alt="image-20201210121839586"></p><ul><li>逆光帮手：三棱镜</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211222932427.png" alt="image-20201211222932427"></p><ul><li>逆光剪影怎么拍<ul><li>人物背后要有大面积空景，不能有山等阻挡（山顶、楼顶、海边、或者站高一点与其他人物脱离）</li></ul></li><li>光背景过亮 人脸过黑怎么办<ul><li>对焦锁焦以后加曝光</li></ul></li><li>逆光条件不理想，比如天空惨白怎么办<ul><li>只利用光线，天空部分少拍入画面</li></ul></li><li>太阳角度比较高的逆光拍摄<ul><li>可以选择室内拍摄，让光线透过玻璃窗打进屋内</li><li>寻找有积雪、四周白色墙壁环境的地方拍摄逆光，让白色物体的反光对人物进行补光</li></ul></li><li>巧妙的利用小道具制造不一样的逆光（三棱镜）</li><li>逆光拍摄剪影有哪些诀窍<ul><li>任务的背后要有大面积的空景，不能有建筑物或山等阻挡</li><li>天空中最好有美丽的火烧云，这样逆光照片色彩好看</li><li>最好挑选在山顶、楼顶、海边等空旷环境拍摄逆光剪影</li></ul></li></ul></li><li><p>哪些小技巧，可以让你的照片更有感觉</p><ul><li><p>虚化背景，突出主题（相机人像模式）。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224712762.png" alt="image-20201211224712762"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224731048.png" alt="image-20201211224731048"></p></li><li><p>三棱镜：遮挡杂物，营造梦幻效果。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224823643.png" alt="image-20201211224823643"></p></li><li><p>分身效果：全景模式下模特由起始点移动到结束点，中间不能有路人闯入。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224920330.png" alt="image-20201211224920330"></p></li><li><p>镜面效果：积水，湖泊</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224938235.png" alt="image-20201211224938235"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211224957947.png" alt="image-20201211224957947"></p></li><li><p>悬浮效果：站板凳上一张，空景一张，app合成去掉板凳（设置一个蒙版，把它擦出来）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225121692.png" alt="image-20201211225121692"></p></li><li><p>制造画框，将拍摄主体置于任何框内</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225222522.png" alt="image-20201211225222522"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225238832.png" alt="image-20201211225238832"></p></li><li><p>用手机如何拍出车辆运动轨迹的照片</p><ul><li>快门速度设置到1/20,1/30秒的速度</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225456114.png" alt="image-20201211225456114"></p></li><li><p>一组人像：景大人小，互相衬托，人景合一</p><ul><li>尝试拍摄景大人小的环境人像，这样的照片更耐看</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225614266.png" alt="image-20201211225614266"></p><ul><li>环境人像要斟酌人物着装是否与环境相呼应</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225706777.png" alt="image-20201211225706777"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225718601.png" alt="image-20201211225718601"></p></li></ul></li><li><p>男友拍照指南？？？</p><ul><li><p>餐厅</p><ul><li><p>挑选靠窗户的光源位置，让女朋友面朝窗户</p></li><li><p>跟实物合影，可以近距离高角度把她和食物一起拍进画面</p></li><li><p>注意看看脸上细节，进行补妆</p></li><li><p>端着水杯，或者利用桌上的植物作为虚化的前景增添照片的意境</p></li><li><p>不一定要看镜头，不看镜头的照片可能更加自然</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211225858985.png" alt="image-20201211225858985"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230014394.png" alt="image-20201211230014394"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230232644.png" alt="image-20201211230232644"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230320730.png" alt="image-20201211230320730"></p></li></ul></li><li><p>街景拍照</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230434330.png" alt="image-20201211230434330"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230456826.png" alt="image-20201211230456826"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230537417.png" alt="image-20201211230537417"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211230832809.png" alt="image-20201211230832809"></p></li><li><p>旅行拍摄赢芳心</p><ul><li><p>大头照与景大人小的照片都要拍</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231020307.png" alt="image-20201211231020307"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231032234.png" alt="image-20201211231032234"></p></li><li><p>寻找好的光源或者利用小道具，让她的皮肤在镜头里显得水汪汪</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231125843.png" alt="image-20201211231125843"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231135144.png" alt="image-20201211231135144"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231148765.png" alt="image-20201211231148765"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231159066.png" alt="image-20201211231159066"></p></li><li><p>想避开人群或拍出大长腿只需要蹲下拍摄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231255965.png" alt="image-20201211231255965"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231304281.png" alt="image-20201211231304281"></p></li><li><p>手机采用竖构图拍摄更容易拉长腿</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201211231335864.png" alt="image-20201211231335864"></p></li><li><p>与可爱的小动物合影，抓拍自然生动的照片</p><p>​    <img src="images/image-20201211231418986.png" alt="image-20201211231418986"></p></li></ul></li></ul></li><li><p><strong>拍美食</strong> </p><ul><li><p>尽量在光线充足明亮的地方拍照，最好是靠近窗户的光源</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133702979.png" alt="image-20201213133702979"></p></li><li><p>当地特色美食纪念照</p><ul><li><p>寻找漂亮的背景，如店铺的招牌</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213133824287.png" alt="image-20201213133824287"></p></li><li><p>尽量让拍摄角度与背景面板保持垂直平行</p></li><li><p>用当地的特色建筑或街道作为背景</p></li></ul></li><li><p>只拍一款美食时诀窍</p><ul><li><p>构图采用中心点构图，将一盘美食放置于画面最中间（尽量让整盘食物充满画面，但也不能太拥挤，画面至少保留餐盘边缘）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134024640.png" alt="image-20201213134024640"></p></li></ul></li><li><p>采用俯拍，保持30-45°的角度拍摄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134215182.png" alt="image-20201213134215182"></p></li><li><p>部分实物，采用特殊角度拍摄</p><ul><li><p>饮料蛋糕冰淇淋等有立体感的食物，有时候采用平视角度更加合适</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213134343823.png" alt="image-20201213134343823"></p></li><li><p>整桌的食物更适合俯视平拍角度</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135433744.png" alt="image-20201213135433744"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135454240.png" alt="image-20201213135454240"></p></li><li><p>加入手的元素，让照片有互动感</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135532991.png" alt="image-20201213135532991"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135552575.png" alt="image-20201213135552575"></p></li><li><p>拍摄前整理盘内食物形状与盘边食物残渣</p></li><li><p>利用小道具让画面摆脱单调，更丰富</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135846143.png" alt="image-20201213135846143"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135857777.png" alt="image-20201213135857777"></p></li><li><p>foodie APP</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213135944030.png" alt="image-20201213135944030"></p></li></ul></li></ul></li><li><p><strong>拯救镜头恐惧症</strong></p><ul><li><p>低头微笑</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140114237.png" alt="image-20201213140114237"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140144768.png" alt="image-20201213140144768"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140201519.png" alt="image-20201213140201519"></p></li><li><p>撩头发</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140221731.png" alt="image-20201213140221731"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140236419.png" alt="image-20201213140236419"></p></li><li><p>回眸一笑</p><ul><li>回眸时，压低头。否则容易拍出大脸</li><li>回眸瞬间记得用头发遮下脸，别用力太猛把头发甩开了</li><li>回头时可以保持微笑，头与身体朝镜头方向倾斜一些，这样可以显瘦</li><li>若想要自然状态，可以不看镜头，看自己的斜后方</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140306240.png" alt="image-20201213140306240"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140322080.png" alt="image-20201213140322080"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140331437.png" alt="image-20201213140331437"></p></li><li><p>托住脸颊</p><ul><li><p>轻轻放在脸颊旁边，真正托住脸颊的话，脸会被压变形</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140703775.png" alt="image-20201213140703775"></p></li><li><p>不看镜头，等待观看，凝视</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140738606.png" alt="image-20201213140738606"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140753038.png" alt="image-20201213140753038"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140806898.png" alt="image-20201213140806898"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140822623.png" alt="image-20201213140822623"></p></li><li><p>借助食物饮料等作为道具拿在手里</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140909615.png" alt="image-20201213140909615"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213140958000.png" alt="image-20201213140958000"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141013536.png" alt="image-20201213141013536"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141025585.png" alt="image-20201213141025585"></p></li><li><p>抬头闭眼微笑</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141052558.png" alt="image-20201213141052558"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141103600.png" alt="image-20201213141103600"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141128318.png" alt="image-20201213141128318"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141139502.png" alt="image-20201213141139502"></p></li><li><p>坐下来</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141242494.png" alt="image-20201213141242494"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141255040.png" alt="image-20201213141255040"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141310287.png" alt="image-20201213141310287"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141327583.png" alt="image-20201213141327583"></p></li><li><p>奔跑（奔跑的速度比平时慢一点，动作比平时夸张，拍摄角度最好从侧面拍摄）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141426483.png" alt="image-20201213141426483"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141505295.png" alt="image-20201213141505295"></p></li><li><p>走路（连拍，步子迈的明显一些）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141536080.png" alt="image-20201213141536080"></p></li><li><p>跳跃</p><ul><li>机位蹲低，可以显高</li><li>跳跃时人脸容易变形、表情不受控制，采用侧面拍摄可以避免尴尬</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141749071.png" alt="image-20201213141749071"></p></li><li><p>旋转，转圈</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141822223.png" alt="image-20201213141822223"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141832320.png" alt="image-20201213141832320"></p></li><li><p>凝望镜头，眼睛里要有戏</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20201213141917825.png" alt="image-20201213141917825"></p></li></ul></li></ul></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bilibili.com/video/BV1Gb411S7wC?from=search&seid=5668966452379294491">手机摄影之生活拍照技巧</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="摄影" scheme="https://sssuper-bear.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>PsTips</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/PsTips/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E6%91%84%E5%BD%B1/PsTips/</id>
    <published>2022-01-03T12:29:51.000Z</published>
    <updated>2022-01-07T02:05:57.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>[ 画笔增大</li><li>] 画笔减小</li><li>ctrl+i 反向</li><li>ctrl+t 自由变换工具</li><li>调出红色非选区遮罩：快捷键shift+alt + 点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="PS" scheme="https://sssuper-bear.github.io/categories/PS/"/>
    
    
  </entry>
  
  <entry>
    <title>手撕包菜</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C/</id>
    <published>2022-01-03T12:16:18.000Z</published>
    <updated>2022-01-07T01:57:21.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>typora-copy-images-to: images</p><hr><h3 id="手撕包菜"><a href="#手撕包菜" class="headerlink" title="手撕包菜"></a><a href="https://www.bilibili.com/video/BV1hh41197hh?from=search&seid=4921812292540006215">手撕包菜</a></h3><ul><li><p>包菜去根，用手撕成小块 <strong>根部用刀拍一下</strong></p></li><li><p>清水+少许食用盐，在水中清洗浸泡彻底洗净</p></li><li><p>洗好以后控水备用</p></li><li><p>几粒大蒜拍碎+干辣椒+花椒</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126162351153.png" alt="image-20210126162351153"></p></li><li><p>五花肉切成薄片</p></li><li><p><strong>猪油+五花肉来炒</strong>这样的才香</p></li><li><p>猪油熬化以后加入五花肉片</p></li><li><p>先将五花肉煸炒出油，肉片变色，微微发黄时，加入准备好的小料，煸炒出香味，（火要大，锅要热，油要多）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102537195.png" alt="image-20210127102537195"></p></li><li><p>彻底炒出香味以后放入准备好的包菜</p></li><li><p>少许米酒或者料酒沿锅边淋入去腥增香</p></li><li><p>放入少许米醋或者香醋（先放醋，炒出来的包菜更脆）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127102716126.png" alt="image-20210127102716126"></p></li><li><p>大火将包菜炒至塌陷</p></li><li><p>塌陷以后开始调味（适量盐+少许白糖+蒸鱼豉油）</p></li><li><p>大火翻炒均匀</p></li><li><p>香醋沿锅边淋入将整道菜的香味彻底激发出来</p></li><li><p>这道菜要的是干香脆爽，翻炒时间不要太长</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210127103410622.png" alt="image-20210127103410622"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>可乐鸡翅</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%A3%9F%E7%89%A9/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/</id>
    <published>2022-01-03T12:16:12.000Z</published>
    <updated>2022-01-07T01:57:09.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="可乐鸡翅"><a href="#可乐鸡翅" class="headerlink" title="可乐鸡翅"></a><a href="https://www.bilibili.com/video/BV1pJ411v7S9?from=search&seid=2151627749794461067">可乐鸡翅</a></h3><ul><li><p>原料</p><ul><li>鸡翅250g（11个左右）</li></ul></li><li><p>做法</p><ul><li><p>鸡翅泡水解冻</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155937382.png" alt="image-20210126155937382"></p></li><li><p>捞出，加姜片料酒腌制20分钟（用手抓一抓，搅拌均匀）</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126155946527.png" alt="image-20210126155946527"></p></li><li><p>放入锅中焯水捞出</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160034775.png" alt="image-20210126160034775"></p></li><li><p>锅内热油加入姜片</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160120839.png" alt="image-20210126160120839"></p></li><li><p>鸡翅正面朝下煎至金黄</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160210270.png" alt="image-20210126160210270"></p></li><li><p>加入调味</p><ul><li>一勺料酒</li><li>一勺生抽</li><li>半勺老抽</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160624263.png" alt="image-20210126160624263"></p></li><li><p>翻炒均匀上色</p></li><li><p>可乐一听倒入2/3罐子</p></li><li><p>放入半勺盐调味，盖上锅盖煮沸</p></li><li><p>放入香料：香叶八角都可以</p></li><li><p>大火煮至汤汁收干</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20210126160844786.png" alt="image-20210126160844786"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="食物" scheme="https://sssuper-bear.github.io/categories/%E9%A3%9F%E7%89%A9/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora自动上传图片</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</id>
    <published>2022-01-03T12:13:16.000Z</published>
    <updated>2022-01-03T12:13:59.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora-图片自动上传服务器设置"><a href="#Typora-图片自动上传服务器设置" class="headerlink" title="Typora 图片自动上传服务器设置"></a>Typora 图片自动上传服务器设置</h1><ul><li>下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>（比较稳定建议使用）</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/1972718-20200323210552751-1313111323.png" alt="img"></p><ul><li><p>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，有两个插件都可以用</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323194553126.png" alt="image-20200323194553126"></p></li><li><p>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323195546145.png" alt="image-20200323195546145"></p></li><li><p>token获取：进入码云，点击进入设置页</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323200633225.png" alt="image-20200323200847954"></p></li><li><p>在PicGo配置Gitee</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20220103171035455.png" alt="image-20220103171035455"></p></li><li><p>配置Typora，点击 文件，偏好设置，选择图像，设置PicGo二进制文件的路径</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20200323201738802.png" alt="image-20200323201738802"></p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/">https://www.aliyisheng.blog/post/typora-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</a></li><li><a href="https://www.cnblogs.com/qtzd/p/12554902.html">https://www.cnblogs.com/qtzd/p/12554902.html</a></li><li><a href="https://blog.csdn.net/weixin_41800884/article/details/104718367">https://blog.csdn.net/weixin_41800884/article/details/104718367</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具使用" scheme="https://sssuper-bear.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>希腊字母表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</id>
    <published>2022-01-03T12:11:42.000Z</published>
    <updated>2022-01-03T12:12:08.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h1><table><thead><tr><th>希腊字母小写、大写</th><th>LaTeX形式</th><th>希腊字母小写、大写</th><th>LaTeX形式</th></tr></thead><tbody><tr><td>α <em><strong>A</strong></em></td><td>\alpha A</td><td>μ <em><strong>N</strong></em></td><td>\mu N</td></tr><tr><td>β <em><strong>B</strong></em></td><td>\beta B</td><td>ξ Ξ</td><td>\xi \Xi</td></tr><tr><td>γ Γ</td><td>\gamma \Gamma</td><td><strong>o</strong> <em><strong>O</strong></em></td><td>o O</td></tr><tr><td>δ Δ</td><td>\delta \ Delta</td><td>π Π</td><td>\pi \Pi</td></tr><tr><td>ϵ ε <em><strong>E</strong></em></td><td>\epsilon \varepsilon E</td><td>ρ ϱ <em><strong>P</strong></em></td><td>\rho \varrho P</td></tr><tr><td>ζ <em><strong>Z</strong></em></td><td>\zeta Z</td><td>σ Σ</td><td>\sigma \Sigma</td></tr><tr><td>η <em><strong>H</strong></em></td><td>\eta H</td><td>τ <em><strong>T</strong></em></td><td>\tau T</td></tr><tr><td>θ ϑ Θ</td><td>\theta \vartheta \Theta</td><td>υ Υ</td><td>\upsilon \Upsilon</td></tr><tr><td>ι <em><strong>I</strong></em></td><td>\iota I</td><td>ϕ φ Φ</td><td>\phi \varphi \Phi</td></tr><tr><td>κ <em><strong>K</strong></em></td><td>\kappa K</td><td>χ <em><strong>X</strong></em></td><td>\chi X</td></tr><tr><td>λ Λ</td><td>\lambda \Lambda</td><td>ψ Ψ</td><td>\psi \Psi</td></tr><tr><td>μ <em><strong>M</strong></em></td><td>\mu M</td><td>ω Ω</td><td>\omega \Omega</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源代码包”和“二进制包”的区别</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E7%A7%91%E6%99%AE/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E2%80%9D%E5%92%8C%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-03T11:33:43.000Z</published>
    <updated>2022-01-07T02:09:09.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="“源代码包”和“二进制包”的区别"><a href="#“源代码包”和“二进制包”的区别" class="headerlink" title="“源代码包”和“二进制包”的区别"></a><a href="https://blog.csdn.net/Tomstrong_369/article/details/51741012">“源代码包”和“二进制包”的区别</a></h1><p>源代码方式和二进制包是软件包的两种形式。二进制包里面包括了已经经过编译，可以马上运行的程 序。你只需要下载和解包（安装）它们以后，就马上可以使用。源代码包里面包括了程序原始的程序代码，需要在你的计算机上进行编译以后才可以产生可以运行程 序,所以从源代码安装的时间会比较长。</p><p>source code 是程序員寫的碼， binary code 是機器跑的碼。 source code 得經過 compile 才能成為 binary code 。 </p><p>RPM 有分兩種：binary rpm 跟 source rpm 。<br>前者是編好的 binary ，安裝就可用。<br>後者是還沒編好的 source ，需 rebuild 之後才能安裝。</p><p>rpm格式很好区分，二进制格式的包名字很长，都带有版本号、适应平台、适应的硬件类型等，而源码格式仅仅就是一个版本号的tar包。<br>mysql-5.0.45.tar.gz 是 源码包    像这样的 mysql-5.0.45-linux-x86_64-glibc23.tar.gz   是二进制包</p><p>如果你用过压缩工具就会明白，压缩包未必就是软件，它也可能是备份的许多图片，也可能是打包在一起的普通资料，要分辨它到底是什么最好的办法就是查看包里的文件清单，使用命令tar ztvf *. 或者tar ytvf *.bz2</p><p>源代码包里的文件往往会含有种种源代码文件，头文件*.h、c代码源文件*.c、C++代码源文件*.cc/*.cpp等；而二进制包里的文件则会有可执行文件（与软件同名的往往是主执行文件），标志是其所在路径含有名为bin的目录（仅有少数例外）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="科普" scheme="https://sssuper-bear.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实战例子</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90/</id>
    <published>2022-01-03T10:58:10.000Z</published>
    <updated>2022-01-07T02:00:33.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">腾讯一面</a>：</p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>进程间有六种通信方式：</p><ol><li><strong>管道（pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</li><li><strong>信号（signal）</strong>：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的</li><li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限的进程可以从消息队列中读取信息</li><li><strong>共享内存（share memory）</strong>：他使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量（也就是一个进行在未完成写操作之前，另一个进程不能读取）</li><li><strong>信号量（semaphore）</strong>：它是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据（而信号量一般常用于保护一段代码，使其每次只被一个执行线程运行）。对于二值信号量（0-1），信号量大于0时，可以对进程操作，等于0时要等待，知道信号量大于0</li><li><strong>套接字（socket）</strong>：一种更为一般的进程通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛</li></ol><h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><p><strong>僵尸进程：</strong>一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait或wait pid来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。</p><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记在该进程的退出状态等信息，供其他进程收集，除此之外，僵尸进程需要它的父进程来为它收尸，如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，他还是能被清除的。但是如果父进程是进入一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会很多僵尸进程。</p><p><strong>僵尸进程解决</strong></p><ul><li>调用wait函数，进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，知道有一个出现为止</li><li>当子进程终止时，内核就会向它的父进程发送一个SIGCHLD信号，当父进程接收到SIGCHLD信号后就应该调用wait或waitpid函数对子进程进行善后处理，释放子进程占用的资源</li></ul><p><strong>孤儿进程：</strong>一个父进程退出，而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并有init进程对它们完成状态收集的工作</p><p>子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会向僵尸进程那样占用ID，损害运行系统。</p><h4 id="TCP为啥需要三次握手"><a href="#TCP为啥需要三次握手" class="headerlink" title="TCP为啥需要三次握手"></a>TCP为啥需要三次握手</h4><h5 id="三次握手原理"><a href="#三次握手原理" class="headerlink" title="三次握手原理"></a>三次握手原理</h5><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138303831393232333433313438.jpg" alt="这里写图片描述"></p><ol><li><p>上图的名词解释</p><ul><li>SYN：同步序号。<strong>它表示建立连接</strong>。TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此随机选取一个序列号为seq=x数据包（该数据包里就是一个标记seq，并没有任何有效的数据）</li><li>ACK：确认序号。<strong>它表示响应</strong>（都能响应了 那肯定上一步就连接成功了啊，所以说ACK=1代表确认连接成功啦）</li></ul><p>因此<strong>SYN和ACK同时为1，表示建立连接之后的响应</strong>；而只是<strong>单个的SYN=1，表示的只是建立连接。</strong></p><ul><li>seq：（sequence number）序列号。他是发送端数据包的初始序列号。<strong>seq=x表示发送端数据包的初始序号为x</strong>（seq=0就代表这是第0号帧）</li><li>ack：（acknowledge number）确认号。它是对这次收到数据包的确认，以及对下次收到数据包的期待。<strong>ack=x+1表示我方到x位置的所有数据都已正确收到，且我方告知对方：我期待你下次给我发送包的初始序号（seq）是x+1。</strong></li></ul><p>为了方便记忆，可以这么理解：SYN/ACK是TCP协议层面的标记，而seq/ack是数据层面的标记。</p></li></ol><h5 id="TCP三次握手过程："><a href="#TCP三次握手过程：" class="headerlink" title="TCP三次握手过程："></a><strong>TCP三次握手过程：</strong></h5><ol><li><strong>首先Client向Server发送连接：SYN=1，seq=x；</strong><ul><li><strong>因为</strong>要<strong>建立连接，所以SYN=1</strong>；又<strong>因为</strong>TCP规定SYN=1时不能携带数据，但要消耗一个序号，<strong>所以</strong>Client随机选取一个<strong>初始序号seq=x</strong>。（因为并没有相应动作，所以这里没ACK什么事，我们就认为ACK=0吧）</li><li>发送后Client进入syn_sent状态，表示客户端等待服务器的回复</li></ul></li><li><strong>Server收到请求后 再向Client发送确认：SYN=1，ACK=1，seq=y，ack=x+1；</strong><ul><li>因为Server建立连接后做出了相应，所以SYN=1，ACK=1.因为TCP规定SYN=1时不能携带数据，但要消耗一个序号，所以Server随机选取一个初始序号seq=y。又因为Server到x为止的所有数据都已正确收到了，且Server告诉Client：我期待你下次给我发送包的初始序号（seq）是x+1，所以ack=x+1。</li><li>发送后服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待Client的确认。</li></ul></li><li><strong>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据：ACK=1，seq=x+1,ack=y+1;连接建立</strong><ul><li><strong>因为</strong>有响应动作，<strong>所以ACK=1</strong>（因为要携带发送的数据，所以这没SYN什么事）。<strong>因为2中s</strong>erver已经告诉了这次它想收到包的初始序列号是x+1，<strong>所以初始序号为seq=x+1</strong>。<strong>又因为</strong>Client到y为止的所有数据都已正确收到了，准备接收序列号为y+1的包，<strong>所以ack=y+1</strong></li><li>server收到后，这个TCP连接就进入到Established状态，就可以发起http请求了。</li></ul></li></ol><p><strong>形象些：</strong></p><ul><li><p>第一次握手，由浏览器发起，告诉服务器我要发送请求了</p></li><li><p>第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧</p></li><li><p>第三次握手，由浏览器发送，告诉服务器，我马上发了，准备接收吧</p></li></ul><h5 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h5><p>  其实这是由TCP的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认<code>双方</code>的<code>接收和发送能力</code>,不然容易出现丢包的现象</p><ul><li>第一次握手: 服务端 可以确认<code>客户端</code>具有发送能力</li><li>第二次握手: 客户端 可以确认<code>服务端</code>具有接收能力和发送能力</li><li>第三次握手: 服务端 可以确认<code>客户端</code>具有接收能力</li></ul><h5 id="为什么不能改成两次握手？"><a href="#为什么不能改成两次握手？" class="headerlink" title="为什么不能改成两次握手？"></a>为什么不能改成两次握手？</h5><p>如果两次握手，则会出现下面这种情况：</p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。</p><h5 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h5><p>其实第三次握手的时候,是可以携带数据的.但是,第一次,第二次握手不可以携带数据.</p><p>为什么这样呢?假如第一次握手可以携带数据的话,如果有人要恶意攻击服务器,那他每次都在第一次握手中的<code>SYN</code>报文中放入大量的数据.因为攻击者根本就不理服务器的接收 发送能力是否正常,然后疯狂重复发<code>SYN</code>报文的话,这会让服务器话费很多时间 内存空间来接收这些报文.</p><p>也就是说,第一次握手不可以放数据,其中一个简单的原因就是会让服务器更加容易受到攻击了.而对于第三次的话,此时客户端已经处于<code>ESTAB-LISHED</code>状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h5 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h5><p>static_assert这个关键字，用来做编译期间的断言，因此叫做静态断言。</p><p>语法：static_assert(常量表达式，提示字符串)——如果第一个参数常量表达式的值为真（true或者非零值），那么static_assert不做任何事情，就像它不存在一样，否则会产生一条编译错误，错误位置就是该static_assert语句所在行，错误提示就是第二个参数提示字符串。</p><p>编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。</p><p>static_assert的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果使用变量，则会导致错误</p><h5 id="write和fwrite"><a href="#write和fwrite" class="headerlink" title="write和fwrite"></a>write和fwrite</h5><p>fwrite：带缓冲区；write：不带缓冲区</p><h5 id="程序中1-0是在编译期出错还是在运行的时候出错"><a href="#程序中1-0是在编译期出错还是在运行的时候出错" class="headerlink" title="程序中1/0是在编译期出错还是在运行的时候出错"></a>程序中1/0是在编译期出错还是在运行的时候出错</h5><p>在linux系统中gcc编译期测试：编译可以通过，运行时报错</p><p>参考：</p><ul><li><a href="https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">https://muyi110.github.io/2019/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></li><li><a href="https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md">https://github.com/Vuact/Blog/blob/main/base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.md</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-03T10:58:10.000Z</published>
    <updated>2022-01-07T01:59:58.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>指在系统中正在运行的一个应用程序；程序一旦运行就是进程；或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</p><p><strong>线程进程的区别体现在4个方面：</strong></p><p>1、因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p><p>2、体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。</p><p>3、体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p><p>4、体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p><p><strong>什么情况下使用进程个线程：</strong></p><p>1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的</p><p>2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p><p>3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程</p><p>4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求</p><p>5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</p><p>​    因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。</p><p>​    如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。。。</p><p><strong>进程和线程的关系：</strong></p><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p><p>2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p><p>3、处理机分给线程，即真正在处理机上运行的是线程。</p><p>4、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p><strong>系统线程数量上限是多少</strong></p><p><strong>参考回答：</strong></p><p>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。</p><p>这个限制可以在/usr/include/bits/local_lim.h中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。</p><p>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是8M=8192KB</p><p><strong>如何杀死一个进程</strong></p><p>kill pid</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。</p><p><strong>多线程一般用在哪些地方？</strong></p><p>1、java多线程一般多用于高并发的地方，如订单状态的修改，可以通过多线程，固定时间执行修改订单状态，还有就是支付方面一般都会用到多线程。</p><p>2、最典型的如：</p><p>用户注册完成送大礼包/积分之类，且积分等也是另一个系统并比较耗时；且这类任务即使失败也不是特别重要的。<br>后台线程：比如定期执行一些特殊任务，如定期更新配置文件，任务调度（如quartz），一些监控用于定期信息采集等。</p><p>3、最典型的应用比如tomcat，tomcat内部采用的就是多线程，上百个客户端访问同一个web应用，tomcat接入后都是把后续的处理扔给一个新的线程来处理，这个新的线程最后调用到我们的servlet程序，比如doGet或者doPost方法。</p><p>如果不采用多线程机制，上百个人同时访问一个web应用的时候，tomcat就得排队串行处理了，那样客户端根本是无法忍受那种访问速度的。</p><p>还有就是需要异步处理的时候，需要使用多线程。比如task a和task b要并行处理，单个线程只能串行处理，先做完task a然后再做task b。如果想要多个task同时执行的话，就必须为每个task分配一个线程，然后通过java虚拟机的线程调度，来同时执行多个任务。比如你的CPU是多核心的话，就可以让一个CPU执行一个线程。如果只有一个CPU的话，底层是按照分时复用的原则，各个线程按照时间片来获得CPU资源。</p><p>4、特别耗时的操作，如备份数据库，可以开个线程执行备份，然后执行返回，前台不断向后台询问线程执行状态</p><p>5、一个业务逻辑有很多次的循环，每次循环之间没有影响，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。</p><p>6、需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。</p><p>总之使用多线程就是为了充分利用cpu的资源，提高程序执行效率，当你发现一个业务逻辑执行效率特别低，耗时特别长，就可以考虑使用多线程。不过CPU执行哪个线程的时间和顺序是不确定的，即使设置了线程的优先级，因此使用多线程</p><p><strong>多线程的优点？</strong><br>1、使用线程可以把占据时间长的程序中的任务放到后台去处理<br>2、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>3、程序的运行速度可能加快<br>4、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>5、多个线程交替执行，减少或避免因程序阻塞或意外情况造成的响应过慢现象，降低了用户等待的概率。</p><p><strong>多线程的缺点？</strong><br>1、如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。<br>2、更多的线程需要更多的内存空间。<br>3、程可能会给程序带来更多“bug”，因此要小心使用<br>4、程的中止需要考虑其对程序运行的影响。<br>5、通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p>开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”…</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>参考：</p><ul><li><a href="https://www.cnblogs.com/feily/articles/14133501.html">https://www.cnblogs.com/feily/articles/14133501.html</a></li></ul><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace [ɪm’breɪs]拥抱) ，若无外力作用，这些进程（线程）都将无法向前推进</p><h3 id="什么情况下会发生死锁？解决死锁的策略有哪些"><a href="#什么情况下会发生死锁？解决死锁的策略有哪些" class="headerlink" title="什么情况下会发生死锁？解决死锁的策略有哪些"></a>什么情况下会发生死锁？解决死锁的策略有哪些</h3><h4 id="死锁发生的四个必要条件是："><a href="#死锁发生的四个必要条件是：" class="headerlink" title="死锁发生的四个必要条件是："></a>死锁发生的四个必要条件是：</h4><ol><li><p>资源互斥使用。 </p><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>多个进程保持一定的资源，但又请求新的资源。 </p><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>资源不可被剥夺。 </p><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p></li><li><p>多个进程循环等待。</p><p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</p><p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p><p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。<br><img src="https://gitee.com/sssuperbear/typora/raw/master/img/2200001-20201214151927691-2101847455.png" alt="img"></p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资 源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。 </p><p>以上<strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立</strong>，而只要上述条件之一不满足，就不会发生死锁。</p></li></ol><p><strong>一般死锁的应对策略有：</strong> </p><ol><li>死锁预防。如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。 </li><li>死锁避免。如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。 </li><li>死锁处理。破坏四个必要条件的其中一个，比如kill掉一个进程。 </li><li>死锁忽略。不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。</li></ol><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="通常系统CPU比较高是什么原因"><a href="#通常系统CPU比较高是什么原因" class="headerlink" title="通常系统CPU比较高是什么原因"></a>通常系统CPU比较高是什么原因</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java多线程与并发编程</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-03T10:58:02.000Z</published>
    <updated>2022-01-07T02:01:13.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java多线程与并发编程在面试中的高频考点"><a href="#Java多线程与并发编程在面试中的高频考点" class="headerlink" title="Java多线程与并发编程在面试中的高频考点"></a>Java多线程与并发编程在面试中的高频考点</h1><h2 id="1-说说什么是线程安全？如何实现线程安全？"><a href="#1-说说什么是线程安全？如何实现线程安全？" class="headerlink" title="1. 说说什么是线程安全？如何实现线程安全？"></a>1. 说说什么是线程安全？如何实现线程安全？</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>答：当多个线程同时访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不 需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><h3 id="实现线程安全的三大方法"><a href="#实现线程安全的三大方法" class="headerlink" title="实现线程安全的三大方法"></a>实现线程安全的三大方法</h3><ul><li>互斥同步：同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。Java中实现互斥同步的手段主要有synchronized关键字或ReentrantLock等。</li><li>非阻塞同步，类似是一种乐观并发的策略，比如CAS。</li><li>无同步方案，比如使用ThreadLocal</li></ul><h3 id="synchronized关键字或ReentrantLock的区别是什么？"><a href="#synchronized关键字或ReentrantLock的区别是什么？" class="headerlink" title="synchronized关键字或ReentrantLock的区别是什么？"></a>synchronized关键字或ReentrantLock的区别是什么？</h3><p><strong>相同点：</strong></p><ol><li>都是可重入锁</li><li>都保证了可见性和互斥性</li><li>都可以用于控制多线程对共享对象的访问</li></ol><p><strong>不同点：</strong></p><ol><li>ReentrantLock等待可中断</li><li>synchronized中的锁是非公平的，ReentrantLock默认也是非公平的，但是可以通过修改参数来实现共平锁。</li><li>ReentrantLock绑定多个条件</li><li>synchronized是Java中的关键字，是JVM级别的锁，而ReentrantLock是一个Lock接口下的实现类，是API层面的锁。</li><li>synchronized隐试获取锁和释放锁，ReetrantLock显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作。</li></ol><h2 id="2-Java中线程的状态有哪些？线程间的通信方式有哪些？"><a href="#2-Java中线程的状态有哪些？线程间的通信方式有哪些？" class="headerlink" title="2. Java中线程的状态有哪些？线程间的通信方式有哪些？"></a>2. Java中线程的状态有哪些？线程间的通信方式有哪些？</h2><p>答：Java中线程生命周期分为新建（New）、运行（Runnable）、阻塞（Blocked）、无限期等待（Waiting）、限期等待（Time Waiting）和结束（Terminated）这6种状态。</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>New</td><td>初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>Runnable</td><td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td>Blocked</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>Waiting</td><td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>Time Waiting</td><td>超时等待状态，该状态不同于Waiting，它是可以在指定的时间自行返回的</td></tr><tr><td>Terminated</td><td>终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><p>Java中线程间<strong>通信方式</strong>有：</p><p><strong>互斥量（Mutex）</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。</p><p><strong>信号量（Semphares）</strong>:它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</p><p><strong>事件（Event）</strong>：Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h3 id="sleep后进入什么状态，wait后进入什么状态？"><a href="#sleep后进入什么状态，wait后进入什么状态？" class="headerlink" title="sleep后进入什么状态，wait后进入什么状态？"></a>sleep后进入什么状态，wait后进入什么状态？</h3><p>答：sleep后进入Time waiting超市等待状态，wait后进入waiting状态</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul><li> sleep方法属于Thread类，wait方法属于Object类</li><li> sleep方法暂停执行指定的时间，让出CPU给其他线程，但其监控状态依然保持在指定的时间过后又会自动恢复运行状态</li><li> 在调用sleep方法的过程中，线程不会释放对象锁，而wait会释放对象锁。</li></ul><h3 id="wait为什么是数Object类下面的方法？"><a href="#wait为什么是数Object类下面的方法？" class="headerlink" title="wait为什么是数Object类下面的方法？"></a>wait为什么是数Object类下面的方法？</h3><p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait()就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及到硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p><h3 id="start方法和run方法有什么区别？"><a href="#start方法和run方法有什么区别？" class="headerlink" title="start方法和run方法有什么区别？"></a>start方法和run方法有什么区别？</h3><ol><li>star方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法周，线程会在后台执行，无须等待run方法体的代码执行完毕。</li><li>通过调用start方法启动一个线程时，此线程处于就绪状态，并没有运行。</li><li>run方法也叫线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码，在run方法运行结束后，该线程终止，CPU在调度其他线程。 </li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.nowcoder.com/discuss/805699?source_id=profile_create_nctrack&channel=-1">Java多线程与并发编程在面试中的高频考点！</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux内核</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%86%85%E6%A0%B8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%86%85%E6%A0%B8/</id>
    <published>2022-01-03T10:57:37.000Z</published>
    <updated>2022-01-07T09:57:48.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="程序编译的4个过程"><a href="#程序编译的4个过程" class="headerlink" title="程序编译的4个过程"></a>程序编译的4个过程</h2><p>参考：</p><ul><li><p><a href="">程序编译的4个过程</a></p></li><li><p><a href="https://blog.csdn.net/su_buju/article/details/77144582?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=2">C语言编译过程分成四个步骤</a></p></li></ul><p><strong>1.编译过程的四个阶段</strong></p><p>GCC编译C源代码有四个步骤：预处理—-&gt;编译—-&gt;汇编—-&gt;链接。</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/20190111145806588.jpg" alt="img"></p><p><strong>2.预处理阶段（.c—.i）</strong><br>编译器将C程序的头文件编译进来，还有宏的替换，可以用gcc的参数-E来参看。</p><p>命令：unix&gt;gcc –o hello hello.c<br>作用：将hello.c预处理输出hello.i</p><p><strong>3 编译（.i—.s）转换为汇编语言文件</strong><br>这个阶段编译器主要做词法分析、语法分析、语义分析等，在检查无错误后后，把代码翻译成汇编语言[2]。可用gcc的参数-S来参看。<br>编译器(ccl)将文本文件hello.i 翻译成文本文件hello.s, 它包含一个汇编语言程序。<br>一条低级机器语言指令。<br>命令：gcc -S hello.i -o hello.s<br>作用：将预处理输出文件hello.i汇编成hello.s文件</p><p><strong>4.汇编阶段（.s—.o）得到机器语言</strong><br>汇编器as 将hello.s 翻译成机器语言保存在hello.o 中（二进制文本形式）。</p><p><strong>5.链接阶段（.o文件到可执行文件）</strong><br>printf函数存在于一个名为printf.o的单独预编译目标文件中。必须得将其并入到hello.o的程序中，链接器就是负责处理这两个的并入，结果得到hello文件，它就是一个可执行的目标文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-03T10:57:37.000Z</published>
    <updated>2022-01-07T02:01:41.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a><a href="https://www.nowcoder.com/discuss/807495?type=all&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=5C27F5E8CC05D3FEFF557CD8FC40F544-1641215720650">linux基本命令</a></h2><h6 id="cd-（change-directory：英文释义是改变目录）切换目录"><a href="#cd-（change-directory：英文释义是改变目录）切换目录" class="headerlink" title="cd （change directory：英文释义是改变目录）切换目录"></a>cd （change directory：英文释义是改变目录）切换目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../ ;跳到上级目录</span><br><span class="line">cd /opt ;不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line">cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。 </span><br></pre></td></tr></table></figure><h6 id="pwd-（print-working-directory：显示当前工作目录的绝对路径）"><a href="#pwd-（print-working-directory：显示当前工作目录的绝对路径）" class="headerlink" title="pwd （print working directory：显示当前工作目录的绝对路径）"></a>pwd （print working directory：显示当前工作目录的绝对路径）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd </span><br><span class="line">显示当前的绝对路径 </span><br></pre></td></tr></table></figure><h6 id="ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）"><a href="#ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）" class="headerlink" title="ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）"></a>ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -a ;显示所有文件夹,隐藏文件也显示出来</span><br><span class="line">ls -R ;连同子目录一起列出来 </span><br></pre></td></tr></table></figure><h6 id="ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）"><a href="#ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）" class="headerlink" title="ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）"></a>ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll -a ;显示所有文件,隐藏文件也显示出来</span><br><span class="line">ll -R ;连同子目录内容一起列出来</span><br><span class="line">ll -h ;友好展示详情信息,可以看大小</span><br><span class="line">ll -al ;即能显示隐藏文件又能显示详细列表。 </span><br></pre></td></tr></table></figure><h6 id="touch-（touch：创建文件）创建文件"><a href="#touch-（touch：创建文件）创建文件" class="headerlink" title="touch （touch：创建文件）创建文件"></a>touch （touch：创建文件）创建文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt  ;创建test.txt文件</span><br><span class="line">touch /opt/java/test.java ;在指定目录创建test.java文件 </span><br></pre></td></tr></table></figure><h6 id="mkdir-（mkdir：创建目录）-创建目录"><a href="#mkdir-（mkdir：创建目录）-创建目录" class="headerlink" title="mkdir （mkdir：创建目录） 创建目录"></a>mkdir （mkdir：创建目录） 创建目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹名称 ;在此目录创建文件夹</span><br><span class="line">mkdir /opt/java/jdk ;在指定目录创建文件夹 </span><br></pre></td></tr></table></figure><h6 id="cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"><a href="#cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）" class="headerlink" title="cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"></a>cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat lj.log ;快捷查看文件命令 </span><br><span class="line">Ctrl + c ;暂停显示文件</span><br><span class="line">Ctrl + d ;退出查看文件命令 </span><br></pre></td></tr></table></figure><h6 id="more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"><a href="#more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）" class="headerlink" title="more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"></a>more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回车：向下n行，需要定义，默认为1行。</span><br><span class="line">空格键：向下滚动一屏或Ctrl+F</span><br><span class="line">B：返回上一层或Ctrl+B</span><br><span class="line">q：退出more </span><br></pre></td></tr></table></figure><h6 id="less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"><a href="#less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）" class="headerlink" title="less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"></a>less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">less -m 显示类似于more命令的百分比。</span><br><span class="line">less -N 显示每行的行号。(大写的N)</span><br><span class="line">两参数一起使用如：less -mN 文件名，如此可分页并显示行号。</span><br><span class="line"></span><br><span class="line">空格键：前下一页或page down。</span><br><span class="line">回车：向下一行。</span><br><span class="line">b：后退一页 或 page up。</span><br><span class="line">q：退出。</span><br><span class="line">d：前进半页。</span><br><span class="line">u：后退半页 </span><br></pre></td></tr></table></figure><h6 id="tail（尾巴）-查看文件命令（看最后多少行）"><a href="#tail（尾巴）-查看文件命令（看最后多少行）" class="headerlink" title="tail（尾巴） 查看文件命令（看最后多少行）"></a>tail（尾巴） 查看文件命令（看最后多少行）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -10 ;文件名 看最后10行 </span><br></pre></td></tr></table></figure><h6 id="cp（copy单词缩写，复制功能）"><a href="#cp（copy单词缩写，复制功能）" class="headerlink" title="cp（copy单词缩写，复制功能）"></a>cp（copy单词缩写，复制功能）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下</span><br><span class="line">cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为aaa.log</span><br><span class="line">cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中 </span><br></pre></td></tr></table></figure><h6 id="mv（move单词缩写，移动功能，该文件名称功能）"><a href="#mv（move单词缩写，移动功能，该文件名称功能）" class="headerlink" title="mv（move单词缩写，移动功能，该文件名称功能）"></a>mv（move单词缩写，移动功能，该文件名称功能）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下</span><br><span class="line">mv java.log mysql.log ;把java.log改名为mysql.log </span><br></pre></td></tr></table></figure><h6 id="rm（remove：移除的意思）删除文件，或文件夹"><a href="#rm（remove：移除的意思）删除文件，或文件夹" class="headerlink" title="rm（remove：移除的意思）删除文件，或文件夹"></a>rm（remove：移除的意思）删除文件，或文件夹</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件    </span><br><span class="line">-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。 </span><br><span class="line">-rf 强制删除文件夹及内容</span><br><span class="line"></span><br><span class="line">rm 文件名 ;安全删除命令  （yes删除 no取消）</span><br><span class="line">rm -rf 强制删除文件夹及内容</span><br><span class="line">rm -rf *  删除当前目录下的所有内容。</span><br><span class="line">rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。 </span><br></pre></td></tr></table></figure><h6 id="find-（find：找到的意思）查找指定文件或目录"><a href="#find-（find：找到的意思）查找指定文件或目录" class="headerlink" title="find （find：找到的意思）查找指定文件或目录"></a>find （find：找到的意思）查找指定文件或目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 表示0~多个任意字符。</span><br><span class="line"></span><br><span class="line">find -name 文件名;按照指定名称查找在当前目录下查找文件</span><br><span class="line">find / -name 文件名按照指定名称全局查找文件</span><br><span class="line">find -name &#x27;*文件名&#x27; ;任意前缀加上文件名在当前目录下查找文件</span><br><span class="line">find / -name &#x27;*文件名*&#x27; ;全局进行模糊查询带文件名的文件 </span><br></pre></td></tr></table></figure><h6 id="vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）"><a href="#vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）" class="headerlink" title="vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）"></a>vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）</h6><h6 id="vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）"><a href="#vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）" class="headerlink" title="vim （VI IMproved：改进版视觉）改进版文本编辑器   （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）"></a>vim （VI IMproved：改进版视觉）改进版文本编辑器   （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入”vim 文件名” 打开文件，刚刚时是”一般模式”。</span><br><span class="line"></span><br><span class="line">一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。</span><br><span class="line">插入模式：可以编辑文件内容。</span><br><span class="line">底行模式：可以进行强制退出操作,不保存   :q!</span><br><span class="line">         可以进行保存并退出操作       :wq</span><br><span class="line"></span><br><span class="line">按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。</span><br><span class="line">在编辑模式下按”Esc” 即可到一般模式</span><br><span class="line">在一般模式下按”:”，冒号进入底行模式。</span><br><span class="line"></span><br><span class="line">在一般模式下的快捷键</span><br><span class="line">    dd ;删除一整行</span><br><span class="line">    X ;向前删除  等同于windowns系统中的删除键</span><br><span class="line">    x ;向后删除和大写x相反方向</span><br><span class="line">    Ctrl + f ;向后看一页</span><br><span class="line">    Ctrl + b ;向前看一页</span><br><span class="line">    u ;撤销上一步操作</span><br><span class="line">    /word ;向下查找word关键字  输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反）</span><br><span class="line">    ?log ;向上查找log关键字  输入:n查找上一个,N查找下一个</span><br><span class="line">    :1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的</span><br><span class="line">    :0 ;光标移动到第一行</span><br><span class="line">    :$ ;光标移动到最后一行</span><br><span class="line">    :300 ;光标移动到300行,输入多少数字移动到多少行</span><br><span class="line">    :w  ;保存</span><br><span class="line">    :w! ;强制保存</span><br><span class="line">    :q  ;退出</span><br><span class="line">    :q! ;强制退出</span><br><span class="line">    5dd ;删除后面5行,打一个参数为自己填写</span><br><span class="line">    5x ;删除此光标后面5个字符</span><br><span class="line">    d1G ;删除此光标之前的所有</span><br><span class="line">    d0 ;从光标当前位置删除到此行的第一个位置</span><br><span class="line">    yy ;复制</span><br><span class="line">    p ;在光标的下面进行粘贴</span><br><span class="line">    P ;在光标的上门进行粘贴 </span><br></pre></td></tr></table></figure><h6 id="管道命令（把多个命令组合起来使用）"><a href="#管道命令（把多个命令组合起来使用）" class="headerlink" title="| 管道命令（把多个命令组合起来使用）"></a>| 管道命令（把多个命令组合起来使用）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管道命令的语法：命令1 | 命令2 | 命令3。 </span><br></pre></td></tr></table></figure><h6 id="grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过"><a href="#grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过" class="headerlink" title="grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过"></a>grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单独使用：</span><br><span class="line">grep String test.java ；在test.java文件中查找String的位置，返回整行</span><br><span class="line">一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）</span><br><span class="line"></span><br><span class="line">ps aux|grep java ；查找带java关键字的进程</span><br><span class="line">ll |grep java ；查找带java关键字的文件夹及文件 </span><br></pre></td></tr></table></figure><h6 id="yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）"><a href="#yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）" class="headerlink" title="yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）"></a>yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件</span><br><span class="line">#等待下载完了就可以输入：</span><br><span class="line"></span><br><span class="line">rz  从win系统中选择文件上传到Linux系统中</span><br><span class="line"></span><br><span class="line">sz  文件名 选择Linux系统的文件复制到win系统中 </span><br></pre></td></tr></table></figure><h6 id="tar-（解压-压缩-命令）"><a href="#tar-（解压-压缩-命令）" class="headerlink" title="tar （解压 压缩 命令）"></a>tar （解压 压缩 命令）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用的组合命令：</span><br><span class="line">-z 是否需要用gzip压缩。</span><br><span class="line">-c 建立一个压缩文件的参数指令(create) –压缩</span><br><span class="line">    -x 解开一个压缩文件的参数指令(extract) –解压  </span><br><span class="line">    -v 压缩的过程中显示文件(verbose)</span><br><span class="line">    -f 使用档名，在f之后要立即接档中(file)</span><br><span class="line">    常用解压参数组合：zxvf</span><br><span class="line">    常用压缩参数组合：zcvf </span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录</span><br><span class="line"></span><br><span class="line">压缩命令：（注意 语法有点反了，我反正每次都搞反）</span><br><span class="line">tar -zcvf redis-3.2.8.tar.gz  redis-3.2.8/  ;语法 tar -zcvf  压缩后的名称  要压缩的文件</span><br><span class="line">tar -zcvf 压缩后的文件（可指定目录）  要压缩的文件（可指定目录） </span><br></pre></td></tr></table></figure><h6 id="ps-（process-status：进程状态，类似于windows的任务管理器）"><a href="#ps-（process-status：进程状态，类似于windows的任务管理器）" class="headerlink" title="ps （process status：进程状态，类似于windows的任务管理器）"></a>ps （process status：进程状态，类似于windows的任务管理器）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用组合：ps -ef     标准的格式查看系统进程</span><br><span class="line">      ps -aux    BSD格式查看系统进程</span><br><span class="line">      ps -aux|grep redis  BSD格式查看进程名称带有redis的系统进程（常用技巧）</span><br><span class="line">//显示进程的一些属性,需要了解（ps aux）</span><br><span class="line">USER     //用户名</span><br><span class="line">PID         //进程ID号,用来杀死进程的</span><br><span class="line">%CPU     //进程占用的CPU的百分比</span><br><span class="line">%MEM     //占用内存的的百分比</span><br><span class="line">VSZ      //该进程使用的虚拟內存量（KB）</span><br><span class="line">RSS      //该进程占用的固定內存量（KB）</span><br><span class="line">STAT     //进程的状态</span><br><span class="line">START    //该进程被触发启动时间</span><br><span class="line">TIME     //该进程实际使用CPU运行的时间 </span><br></pre></td></tr></table></figure><h6 id="clear-清屏命令。（强迫症患者使用）"><a href="#clear-清屏命令。（强迫症患者使用）" class="headerlink" title="clear 清屏命令。（强迫症患者使用）"></a>clear 清屏命令。（强迫症患者使用）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程）</span><br><span class="line">（ps类似于打开任务管理器，kill类似于关闭进程）</span><br><span class="line">    kill -5 进程的PID ;推荐,和平关闭进程</span><br><span class="line">    kill -9 PID ;不推荐,强制杀死进程 </span><br></pre></td></tr></table></figure><h6 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改）</span><br><span class="line">如果此命令输入无效，先输入yum -y install net-tools</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure><h6 id="ping-（用于检测与目标的连通性）语法：ping-ip地址"><a href="#ping-（用于检测与目标的连通性）语法：ping-ip地址" class="headerlink" title="ping （用于检测与目标的连通性）语法：ping ip地址"></a>ping （用于检测与目标的连通性）语法：ping ip地址</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">1、在Windows操作系统中cmdipconfig，查看本机IP地址：</span><br><span class="line">2、再到LInux系统中输入 ping ip地址</span><br><span class="line">（公司电脑，我就不暴露Ip了,没图片  自己去试）</span><br><span class="line">按Ctrl + C 可以停止测试。 </span><br></pre></td></tr></table></figure><h6 id="free-命令-（显示系统内存）"><a href="#free-命令-（显示系统内存）" class="headerlink" title="free 命令 （显示系统内存）"></a>free 命令 （显示系统内存）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</span><br><span class="line">-b 以Byte显示内存使用情况</span><br><span class="line">-k 以kb为单位显示内存使用情况</span><br><span class="line">-m 以mb为单位显示内存使用情况</span><br><span class="line">-g 以gb为单位显示内存使用情况</span><br><span class="line">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">-t 显示内存使用总合 </span><br></pre></td></tr></table></figure><h6 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</span><br><span class="line">-c 显示完整的进程命令</span><br><span class="line">-s 保密模式</span><br><span class="line">-p &lt;进程号&gt; 指定进程显示</span><br><span class="line">-n &lt;次数&gt;循环显示次数 </span><br></pre></td></tr></table></figure><h6 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Linux netstat命令用于显示网络状态。</span><br><span class="line">#利用netstat指令可让你得知整个Linux系统的网络情况。</span><br><span class="line">#语法：</span><br><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] </span><br></pre></td></tr></table></figure><h6 id="file-（可查看文件类型）"><a href="#file-（可查看文件类型）" class="headerlink" title="file （可查看文件类型）"></a>file （可查看文件类型）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名 </span><br></pre></td></tr></table></figure><h6 id="重启linux"><a href="#重启linux" class="headerlink" title="重启linux"></a>重启linux</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 重启命令：reboot </span><br></pre></td></tr></table></figure><h6 id="关机linux"><a href="#关机linux" class="headerlink" title="关机linux"></a>关机linux</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 关机命令：halt </span><br></pre></td></tr></table></figure><h6 id="同步时间命令"><a href="#同步时间命令" class="headerlink" title="同步时间命令"></a>同步时间命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp1.aliyun.com </span><br></pre></td></tr></table></figure><h6 id="更改为北京时间命令"><a href="#更改为北京时间命令" class="headerlink" title="更改为北京时间命令"></a>更改为北京时间命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </span><br></pre></td></tr></table></figure><h6 id="查看时间命令："><a href="#查看时间命令：" class="headerlink" title="查看时间命令："></a>查看时间命令：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E9%9D%A2%E8%AF%95/JavaSE/</id>
    <published>2022-01-03T10:57:37.000Z</published>
    <updated>2022-01-07T10:45:01.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="String，StringBuilder，StringBuffer的区别："><a href="#String，StringBuilder，StringBuffer的区别：" class="headerlink" title="String，StringBuilder，StringBuffer的区别："></a>String，StringBuilder，StringBuffer的区别：</h4><ol><li><p>操作数量较少的字符串用<strong>String，不可修改</strong>的字符串；</p><p>String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象。在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢。如下String的拼接优化。</p></li><li><p>在单线程且操作大量字符串用<strong>StringBuilder</strong>,<strong>速度快</strong>，但<strong>线程不安全，可修改</strong>；</p></li><li><p>在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改</strong>。</p><p>使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况</p></li></ol><h4 id="String的拼接优化"><a href="#String的拼接优化" class="headerlink" title="String的拼接优化:"></a>String的拼接优化:</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = s1 + s2;</span><br><span class="line">java实际运行时优化为</span><br><span class="line">String s = new StringBuilder(s1).append(s2).toString();</span><br></pre></td></tr></table></figure><h4 id="Java支持的数据类型有哪些"><a href="#Java支持的数据类型有哪些" class="headerlink" title="Java支持的数据类型有哪些"></a>Java支持的数据类型有哪些</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br></pre></td></tr></table></figure><h4 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱</span><br></pre></td></tr></table></figure><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Int是java的原始数据类型，Integer是java为int提供的封装类。</span><br><span class="line">Java为每个原始类型提供了封装类。</span><br><span class="line">原始类型封装类</span><br><span class="line">booleanBoolean</span><br><span class="line">charCharacter</span><br><span class="line">byteByte</span><br><span class="line">shortShort</span><br><span class="line">intInteger</span><br><span class="line">longLong</span><br><span class="line">floatFloat</span><br><span class="line">doubleDouble</span><br></pre></td></tr></table></figure><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</span><br></pre></td></tr></table></figure><h4 id="Java中如何跳出当前的多重嵌套循环"><a href="#Java中如何跳出当前的多重嵌套循环" class="headerlink" title="Java中如何跳出当前的多重嵌套循环"></a>Java中如何跳出当前的多重嵌套循环</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</span><br></pre></td></tr></table></figure><h4 id="比较一下Java和JavaSciprt"><a href="#比较一下Java和JavaSciprt" class="headerlink" title="比较一下Java和JavaSciprt"></a>比较一下Java和JavaSciprt</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。</span><br><span class="line">下面对两种语言间的异同作如下比较：</span><br><span class="line">- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</span><br><span class="line">- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）</span><br><span class="line">- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</span><br><span class="line">- 代码格式不一样</span><br></pre></td></tr></table></figure><h4 id="数组-Array-和列表-ArrayList-的区别"><a href="#数组-Array-和列表-ArrayList-的区别" class="headerlink" title="数组(Array)和列表(ArrayList)的区别"></a>数组(Array)和列表(ArrayList)的区别</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array和ArrayList的不同点：</span><br><span class="line">Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</span><br><span class="line">Array大小是固定的，ArrayList的大小是动态变化的。</span><br><span class="line">ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</span><br><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></table></figure><h4 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</span><br><span class="line">引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递</span><br></pre></td></tr></table></figure><h4 id="为什么会出现4-0-3-6-0-40000001这种现象"><a href="#为什么会出现4-0-3-6-0-40000001这种现象" class="headerlink" title="为什么会出现4.0-3.6=0.40000001这种现象"></a>为什么会出现4.0-3.6=0.40000001这种现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</span><br><span class="line">出现0.40000001的情况可以使用BigDecimal类解决，其实浮点数基本上都不精确，BigDecimal使用String来解决的</span><br></pre></td></tr></table></figure><h4 id="十进制的数在内存中是怎么存的"><a href="#十进制的数在内存中是怎么存的" class="headerlink" title="十进制的数在内存中是怎么存的"></a>十进制的数在内存中是怎么存的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码的形式。把一个十进制转换为二进制的方法是：把被转换的十进制数反复地除以 2，直到商为 0 为止，所得余数（从末位读起）就是这个数的二进制表示，简单地说，就是 &quot;除 2 取余法&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151652729.png" alt="image-20211125151652729"></p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211125151705033.png" alt="image-20211125151705033"></p><h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原码：是一种计算机中对数字的二进制定点表示法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为 0，负数该位为 1</span><br><span class="line"></span><br><span class="line">反码：一个数字用原码表示是容易理解的，但是需要单独一个位来表示符号位，并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是让符号位参与运算。要实现这个功能，我们就要用到反码。</span><br><span class="line">对于单个数值（二进制的 0 和 1）而言，对其进行取反操作就是将 0 变为 1，1 变为 0。正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。</span><br><span class="line"></span><br><span class="line">补码：补码是一种用二进制表示有符号数的方法。正数和 0 的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加 1。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式</span><br><span class="line">只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路和补码电路即可以完成各种有符号数加法和减法，在电路设计上相当方便。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">十进制</th><th align="center">原码</th><th align="center">反码</th><th align="center">补码</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">0000 0110</td><td align="center">0000 0110</td><td align="center">0000 0110</td></tr><tr><td align="center">-3</td><td align="center">1000 0011</td><td align="center">1111 1100</td><td align="center">1111 1101</td></tr></tbody></table><h4 id="符号“-”比较的是什么"><a href="#符号“-”比较的是什么" class="headerlink" title="符号“==”比较的是什么"></a>符号“==”比较的是什么</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final关键字是怎么用的"><a href="#final关键字是怎么用的" class="headerlink" title="final关键字是怎么用的"></a>final关键字是怎么用的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</span><br><span class="line"></span><br><span class="line">对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</span><br></pre></td></tr></table></figure><h3 id="说说HashMap的原理"><a href="#说说HashMap的原理" class="headerlink" title="说说HashMap的原理"></a><a href="https://www.cnblogs.com/woshimrf/p/hashmap.html">说说HashMap的原理</a></h3><blockquote><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p></blockquote><p>答：HashMap是通过哈希表的数组链表实现的。内部维护一个Node数组，当put时，计算key hash后的值当做索引。如果数组中该位置为null，则放入value。然后判断是否需要扩容，返回null。如果数组上已经有元素，判断hash和key是否相等，相等就表示找到node节点了，不相等则判断该元素是TreeNode还是普通Node。如果是TreeNode，则按照TreeNode的put方法插入。如果不是TreeNode, 遍历链表，对比hash和key，若都不相等，则插入队尾，如果链表长度大于等于8，将链表转换为TreeNode。找到node之后，node不为null则赋值value。最后返回原来的value。</p><h4 id="如何扩容"><a href="#如何扩容" class="headerlink" title="如何扩容"></a>如何扩容</h4><p>答：(直接说1.8的内容，想要装逼体验深度就对比1.7. 比如1.7扩容会导致链表重排倒置，1.8不会，1.8不用再次计算hash等。当然，这样回答要准备好继续入坑，为什么，如何做到)</p><p>要说扩容，首先要知道原来的容量以及什么时候扩容。HashMap初始化的时候可以指定<code>initialCapacity</code>和<code>loadfactor</code>。<code>capacity</code>是2的指数倍，表示数组的长度。</p><p><code>loadfactor</code>表示达到容量的百分比后扩容。<code>threshold=capacity*loadfactor</code>就是HashMap对象中可以容纳的最大K-V键值对数量。</p><p>所以，当size(当前K-V键值对数量)超过<code>threshold</code>，则进行扩容。当然，如果capacity已经大于2^30，则直接将<code>threshold=Integer.MAX_VALUE</code>, 就不扩容了，碰撞吧。</p><p>扩容的时候先计算容量，扩大为原来的2倍，对应<code>threshold</code>也扩大为原来的2倍。</p><p>然后将原来数组上的元素复制到新的数组。对于冲突碰撞的结点，是TreeNode则按TreeNode插入，不是TreeNode则将链表的一半平分到其他新增的索引位置。</p><p>关于几个数字。<code>loadfactor=0.75; DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; MAXIMUM_CAPACITY = 1 &lt;&lt; 30; TREEIFY_THRESHOLD = 8</code>。也就是说，对于我们平时直接new 的HashMap对象，默认数组长度为16，最大容纳12个，超过12个则扩容；当发生碰撞的数量小于8个则维护链表，当数量大于8个则改造成TreeNode.</p><h4 id="说TreeNode是怎么put的"><a href="#说TreeNode是怎么put的" class="headerlink" title="说TreeNode是怎么put的"></a>说TreeNode是怎么put的</h4><p>红黑树</p><h4 id="如何get"><a href="#如何get" class="headerlink" title="如何get"></a>如何get</h4><p>答： 既然知道HashMap的存储原理，那个get也就呼之欲出了。 首先，计算hash索引，如果头结点不为null，如果头结点hash以及key都相等，则取出。</p><p>如果头结点不相等，并且next不为nul，判断next是否是TreeNode, 如果是TreeNode则TreeNode get.</p><p>如果不是TreeNode, 遍历链表，找到hash和key相等的取出value。</p><h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>答：不是，高并发中不仅会不安全，还有可能造成死循环(扩容的时候)。想要在并发中使用<strong>，请使用ConcurrentHashMap.</strong></p><p><a href="https://www.jianshu.com/p/6bc2d81a3f7f"><strong>实现线程安全的方式有三种</strong>，分别是使用<strong>HashTable</strong>、<strong>Collections.SynchronizeMap</strong>、<strong>ConcurrentHashMap</strong>。</a></p><h5 id="一、HashTable"><a href="#一、HashTable" class="headerlink" title="一、HashTable"></a>一、HashTable</h5><p>Hashtable 源码中是使用 synchronized 来保证线程安全的，比如下面的 get 方法和 put 等方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123; ... &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以当一个线程访问 HashTable 的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。因此Hashtable效率很低，基本被废弃。。</p><h5 id="二、SynchronizedMap"><a href="#二、SynchronizedMap" class="headerlink" title="二、SynchronizedMap"></a>二、SynchronizedMap</h5><p>SynchronizedMap是Collectionis的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure><p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。效率还是硬伤。</p><h5 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a>三、ConcurrentHashMap</h5><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问,极大提升了效率。相关源码敬请期待！</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>参考： </p><ul><li><a href="https://www.cnblogs.com/zhuyapeng/p/13750644.html">https://www.cnblogs.com/zhuyapeng/p/13750644.html</a></li><li><a href="https://www.cnblogs.com/gofighting/p/5437998.html">https://www.cnblogs.com/gofighting/p/5437998.html</a></li><li><a href="https://tech.meituan.com/2016/12/02/redblack-tree.html">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></li></ul><p>红黑树:二叉树+高度限制<br>二叉树：确定了它的查找非常快。<br>高度限制：这个是取普通二叉树和平衡二叉树之间。<br>普通二叉树，只管插入不做调整，可能会出现单链很长。<br>平衡二叉树，所有的链高度相等，但存就需要调整，非常耗时。<br>红黑树，最长单链不会超过最短单链2倍，这样也确定它存的耗时也居中。</p><p>红黑树特点5条：<br>1.所有节点非红即黑。<br>2.根节点为黑节点。<br>3.所有叶子节（null）点为黑色。<br>4.所有节点到叶子节点中黑色节点数目相同。（确定最长单链不会超过最短单链2倍）<br>5.如果一个节点为红色，则它的子节点节点必须为黑色。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点</p><p>红黑树的操作：<br>查：二叉树的特性决定它高效。<br>增：加入红节点，根据旋转、着色来保持红黑树特性。<br>删：根据旋转、着色来保持红黑树特性。</p><p><strong>红黑树相关定理</strong></p><p><strong>1. 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></p><p>   根据上面的性质5我们知道上图的红黑树每条路径上都是3个黑结点。因此最短路径长度为2(没有红结点的路径)。再根据性质4(两个红结点不能相连)和性质1，2(叶子和根必须是黑结点)。那么我们可以得出：一条具有3个黑结点的路径上最多只能有2个红结点(红黑间隔存在)。也就是说黑深度为2（根结点也是黑色）的红黑树最长路径为4，最短路径为2。从这一点我们可以看出红黑树是 大致平衡的。 (当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p><p><strong>2. 红黑的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;=2bd</strong></p><p>   根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;=2bd。</p><p><strong>3. 一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;=2log(n+1)</strong></p><p>   下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;=2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h=0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;=2^0-1成立。假设树高h&lt;=t时，n&gt;=2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;=t，于是有nl&gt;=2^bd’-1以及nr&gt;=2^bd’-1，将这两个不等式相加有nl+nr&gt;=2^(bd’+1)-2，将该不等式左右加1，得到n&gt;=2^(bd’+1)-1，很显然bd’+1&gt;=bd，于是前面的不等式可以 变为n&gt;=2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;=2^bd-1。</p><p>​    在根据定理2，h&lt;=2bd。即n&gt;=2^(h/2)-1，那么h&lt;=2log(n+1)</p><p>​    从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p><p><strong>红黑树的操作</strong></p><p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，在红黑树上进行插入操作和删除操作会导致不 再符合红黑树的性质。恢复红黑树的属性需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。 虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次 。</p><p><strong>红黑树的优势</strong></p><p>红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。</p><p>而且实际应用中，很多语言都实现了红黑树的数据结构。比如 TreeMap, TreeSet(Java )、 STL(C++)等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://sssuper-bear.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-03T09:38:14.000Z</published>
    <updated>2022-01-07T01:56:51.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></h4><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p><p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p><p><strong>说明:</strong></p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li><li>输入单词数组 <code>words</code> 至少包含一个单词。</li></ul><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br><span class="line">     因为最后一行应为左对齐，而不是左右两端对齐。       </span><br><span class="line">     第二行同样为左对齐，这是因为这行只包含一个单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth = 20</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解答：分三种情况一种是一个单词一行、普通情况、最后一行；每个写成一个 函数，返回String，主函数ArrayList.append();算出每行还剩多少空格在进行分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            count += words[i].length();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxWidth) &#123;</span><br><span class="line">                resultList.add(helper(words, start, i - <span class="number">1</span>, maxWidth));</span><br><span class="line">                start = i ;</span><br><span class="line">                count =  words[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//单词结束后的空格</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后一截</span></span><br><span class="line">        resultList.add(helper(words,start,words.length-<span class="number">1</span>,maxWidth));</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">            <span class="comment">// 一行只有一个单词</span></span><br><span class="line">            oneWordOneRow(words,start,maxWidth,sb);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end == words.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//最后一行</span></span><br><span class="line">            lastRow(words,start,end,maxWidth,sb);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            normal(words,start,end,maxWidth,sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneWordOneRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb.append(words[start]);</span><br><span class="line">        <span class="keyword">int</span> num = maxWidth - words[start].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lastRow</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end; i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = maxWidth - sb.length();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">normal</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> maxWidth, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordsLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            wordsLength += words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> seperate =  (maxWidth -wordsLength) / (end - start);</span><br><span class="line">        <span class="keyword">int</span> remain = (maxWidth -wordsLength) % (end - start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=end;i++) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != end) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; seperate; j++) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(remain-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>难度中等6301</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>思路：</strong></p><ul><li>不同的 圈起来，逐步右移，</li><li>出现相同的，最左边位置就变成相同的中下标最大的地方，这样可以避免重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (s.length()==0) return 0;</span></span><br><span class="line">        <span class="comment">// HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span></span><br><span class="line">        <span class="comment">// int max = 0;</span></span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; s.length(); i ++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(map.containsKey(s.charAt(i)))&#123;</span></span><br><span class="line">        <span class="comment">//         left = Math.max(left,map.get(s.charAt(i)) + 1);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     map.put(s.charAt(i),i);</span></span><br><span class="line">        <span class="comment">//     max = Math.max(max,i-left+1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return max;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            max = Math.max(max, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></h4><p>难度简单164</p><p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p><p><strong>美式键盘</strong> 中：</p><ul><li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li><li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li><li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li></ul><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/keyboard.png" alt="American keyboard"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;omk&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;adsdf&quot;,&quot;sfd&quot;]</span><br><span class="line">输出：[&quot;adsdf&quot;,&quot;sfd&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 20</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li></ul><p><strong>思路：</strong></p><ul><li>大小写的处理：全部存入String遍历</li><li>返回字符串数组 的构造： List<String> ans = new ArrayList&lt;&gt;(); 返回String需要对其进行重新构造ans.toArray(new String[ans.size()]);</li><li>字符串的s.contains()使用：最后+“”，使其变成字符串</li><li></li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span>, <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span>, <span class="string">&quot;zxcvbnmZXCVBNM&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, n3 = <span class="number">0</span>, leng = word.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leng; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ss[<span class="number">0</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>].contains(word.charAt(i)+<span class="string">&quot;&quot;</span>)) n2++;</span><br><span class="line">                <span class="keyword">else</span> n3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n1 == leng || n2 == leng || n3 == leng) ans.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-03T09:38:08.000Z</published>
    <updated>2022-01-09T03:05:32.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 循环判断左右指针是否走到一起，判断中间值大于还是小于目标值，等于则返回否则，重新复制左右指针，继续循环。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></h4><p>难度简单184</p><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 <code>duration</code> 秒。</p><p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p><p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p><p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [1,4], duration = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。</span><br><span class="line">艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [1,2], duration = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</span><br><span class="line">- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。</span><br><span class="line">艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= timeSeries.length &lt;= 104</code></li><li><code>0 &lt;= timeSeries[i], duration &lt;= 107</code></li><li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li></ul><p><strong>思路：</strong>抛开惯性思维，不要本能 想着 从前往后 看，可以从后往前看，最后一个单独处理。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastTime = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timeSeries.length; i++) &#123;</span><br><span class="line">            ans += Math.min(timeSeries[i]-timeSeries[i-<span class="number">1</span>], duration);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += duration;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p>难度中等1653</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>思路：</strong>每次for没 执行完就继续dfs了，return回来之后，后面的就是没有执行的数放进去，接着遍历，然后不断重复回到根节点之时，就是遍历完成之时。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">                used[i]=<span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><p>难度中等870</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>思路：</strong>对数组进行排序，当前与前一个的根节点相同时，跳过这一次遍历</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        dfs(nums, len,<span class="number">0</span>,path, used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i-1] == false保证前一个根节点，刚撤销选择</span></span><br><span class="line">            <span class="comment">// i&gt;0保证第二位开始</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            dfs(nums, len, depth+<span class="number">1</span>, path, used, res);</span><br><span class="line">            used[i]=<span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NC41-最长无重复子数组"><a href="#NC41-最长无重复子数组" class="headerlink" title="NC41 最长无重复子数组"></a><a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=188&&tqId=38553&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC41 最长无重复子数组</a></h4><p>知识点<a href="https://www.nowcoder.com/ta/job-code-high-week?tag=585">哈希</a><a href="https://www.nowcoder.com/ta/job-code-high-week?tag=5054">双指针</a><a href="https://www.nowcoder.com/ta/job-code-high-week?tag=578">数组</a></p><p> 描述</p><p>给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。</p><p>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p><p>数据范围：0≤arre.length*≤10<sup>6</sup>，0&lt;*a**r**r*[*i*]≤10<sup>5</sup></p><p>要求：空间复杂度 O*(*n)，时间复杂度 O(nlogn)</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4,5]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4,5]是最长子数组      </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,2,3,4,3]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4]是最长子数组      </span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[9]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例4</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,1,2,3,2,2]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长子数组为[1,2,3]     </span><br></pre></td></tr></table></figure><p><strong>示例5</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,2,3,4,8,99,3]</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长子数组为[2,3,4,8,99]  </span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>两个指针，一个i一个j，最开始的时候i和j指向第一个元素</li><li>然后i往后移，把扫描过的元素都放到map中</li><li>如果i扫描过的元素没有重复的就一直往后移，顺便记录一下最大值<code>max</code></li><li>移动j的时候应该为 Math.max(j, map.get(arr[i]) + 1)</li><li>重复的数字可能在之前<strong>移动j的时候跳过了</strong>，所以j的位置不动。</li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i])) j = Math.max(j, map.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">            max = Math.max(max, i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NC65-斐波那契数列"><a href="#NC65-斐波那契数列" class="headerlink" title="NC65 斐波那契数列"></a>NC65 斐波那契数列</h4><p>知识点<a href="https://www.nowcoder.com/ta/job-code-high-week?tag=578">数组</a></p><p><strong>描述</strong></p><p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。</p><p>斐波那契数列是一个满足$$f i b ( x ) = { \begin{array}  { l l  }  { 1 }   &amp; { x = 1 , 2 } \ { fib ( x - 1 ) + fib ( x - 2 ) } &amp; { x \gt 2 } \end{array}$$的数列</p><p>数据范围：1≤<em>n</em>≤39</p><p>要求：空间复杂度 O*(1)，时间复杂度 <em>O</em>(<em>n</em>) ，本题也有时间复杂度 O(logn)的解法</p><p><strong>输入描述：</strong></p><p>一个正整数n</p><p><strong>返回值描述：</strong></p><p>输出一个正整数。</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据斐波那契数列的定义可知，fib(1)=1,fib(2)=1,fib(3)=fib(3-1)+fib(3-2)=2,fib(4)=fib(4-1)+fib(4-2)=3，所以答案为4。      </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>递归<ul><li>往前推，遇到1或2才返回</li></ul></li><li>循环<ul><li>循环n-2次，直接交换数据a,b,c</li></ul></li></ul><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         if (n == 1 || n == 2) return 1;</span></span><br><span class="line"><span class="comment">//         int a = 1, b = 1, c = 0;</span></span><br><span class="line"><span class="comment">//         for (int i = 2; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             c = a+b;</span></span><br><span class="line"><span class="comment">//             a = b;</span></span><br><span class="line"><span class="comment">//             b = c; </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return c;</span></span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    <id>https://sssuper-bear.github.io/2022/01/03/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-03T09:38:02.000Z</published>
    <updated>2022-01-07T01:55:11.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NC78-反转链表"><a href="#NC78-反转链表" class="headerlink" title="NC78 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&&tqId=38547&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC78 反转链表</a></h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： n\leq1000<em>n</em>≤1000</p><p>要求：空间复杂度 O(1)<em>O</em>(1) ，时间复杂度 O(n)<em>O</em>(<em>n</em>) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/4A47A0DB6E60853DEDFCFDF08A5CA249.jpg" alt="img"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空链表则输出空         </span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>利用next往head列表下一步走</li><li>利用pre来保存拼接信息</li></ul><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/image-20211226122019794.png" alt="image-20211226122019794"></p><h1 id="NC4-判断链表中是否有环"><a href="#NC4-判断链表中是否有环" class="headerlink" title="NC4 判断链表中是否有环"></a>NC4 判断链表中是否有环</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p><p>数据范围：链表长度 0 \le n \le 100000≤<em>n</em>≤10000，链表中任意节点的值满足 |val| &lt;= 100000∣<em>v<strong>a</strong>l</em>∣&lt;=100000</p><p>要求：空间复杂度 O(1)<em>O</em>(1)，时间复杂度 O(n)<em>O</em>(<em>n</em>)</p><p>输入分为2部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p><p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：</p><p><img src="https://gitee.com/sssuperbear/typora/raw/master/img/9A058E6590B998B9F7B637155842F993.jpg" alt="img"></p><p>可以看出环的入口结点为从头结点开始的第1个结点，所以输出true。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,0,-4&#125;,1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分&#123;3,2,0,-4&#125;代表一个链表，第二部分的1表示，-4到位置1，即-4-&gt;3存在一个链接，组成传入的head为一个带环的链表，返回true        </span><br></pre></td></tr></table></figure><h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#125;,-1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分&#123;1&#125;代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false        </span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;-1,-7,7,-4,19,6,-9,-5,-2,-5&#125;,6</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><ul><li>构建快慢指针</li><li>快的走两步，慢的走一步</li><li>判断每次只能判断当前与下一步的所指情况，否则容易出现越界的问题（null.next）</li></ul><h2 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="刷题" scheme="https://sssuper-bear.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
